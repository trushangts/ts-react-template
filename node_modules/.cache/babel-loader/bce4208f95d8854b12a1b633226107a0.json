{"ast":null,"code":"/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Creates an interactive, zoomable graph based on a CSV file or\n * string. Dygraph can handle multiple series with or without error bars. The\n * date/value ranges will be automatically set. Dygraph uses the\n * &lt;canvas&gt; tag, so it only works in FF1.5+.\n * @author danvdk@gmail.com (Dan Vanderkam)\n\n  Usage:\n   <div id=\"graphdiv\" style=\"width:800px; height:500px;\"></div>\n   <script type=\"text/javascript\">\n     new Dygraph(document.getElementById(\"graphdiv\"),\n                 \"datafile.csv\",  // CSV file with headers\n                 { }); // options\n   </script>\n\n The CSV file is of the form\n\n   Date,SeriesA,SeriesB,SeriesC\n   YYYYMMDD,A1,B1,C1\n   YYYYMMDD,A2,B2,C2\n\n If the 'errorBars' option is set in the constructor, the input should be of\n the form\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1,sigmaA1,B1,sigmaB1,...\n   YYYYMMDD,A2,sigmaA2,B2,sigmaB2,...\n\n If the 'fractions' option is set, the input should be of the form:\n\n   Date,SeriesA,SeriesB,...\n   YYYYMMDD,A1/B1,A2/B2,...\n   YYYYMMDD,A1/B1,A2/B2,...\n\n And error bars will be calculated automatically using a binomial distribution.\n\n For further documentation and examples, see http://dygraphs.com/\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i['return']) _i['return']();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError('Invalid attempt to destructure non-iterable instance');\n    }\n  };\n}();\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _dygraphLayout = require('./dygraph-layout');\n\nvar _dygraphLayout2 = _interopRequireDefault(_dygraphLayout);\n\nvar _dygraphCanvas = require('./dygraph-canvas');\n\nvar _dygraphCanvas2 = _interopRequireDefault(_dygraphCanvas);\n\nvar _dygraphOptions = require('./dygraph-options');\n\nvar _dygraphOptions2 = _interopRequireDefault(_dygraphOptions);\n\nvar _dygraphInteractionModel = require('./dygraph-interaction-model');\n\nvar _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);\n\nvar _dygraphTickers = require('./dygraph-tickers');\n\nvar DygraphTickers = _interopRequireWildcard(_dygraphTickers);\n\nvar _dygraphUtils = require('./dygraph-utils');\n\nvar utils = _interopRequireWildcard(_dygraphUtils);\n\nvar _dygraphDefaultAttrs = require('./dygraph-default-attrs');\n\nvar _dygraphDefaultAttrs2 = _interopRequireDefault(_dygraphDefaultAttrs);\n\nvar _dygraphOptionsReference = require('./dygraph-options-reference');\n\nvar _dygraphOptionsReference2 = _interopRequireDefault(_dygraphOptionsReference);\n\nvar _iframeTarp = require('./iframe-tarp');\n\nvar _iframeTarp2 = _interopRequireDefault(_iframeTarp);\n\nvar _datahandlerDefault = require('./datahandler/default');\n\nvar _datahandlerDefault2 = _interopRequireDefault(_datahandlerDefault);\n\nvar _datahandlerBarsError = require('./datahandler/bars-error');\n\nvar _datahandlerBarsError2 = _interopRequireDefault(_datahandlerBarsError);\n\nvar _datahandlerBarsCustom = require('./datahandler/bars-custom');\n\nvar _datahandlerBarsCustom2 = _interopRequireDefault(_datahandlerBarsCustom);\n\nvar _datahandlerDefaultFractions = require('./datahandler/default-fractions');\n\nvar _datahandlerDefaultFractions2 = _interopRequireDefault(_datahandlerDefaultFractions);\n\nvar _datahandlerBarsFractions = require('./datahandler/bars-fractions');\n\nvar _datahandlerBarsFractions2 = _interopRequireDefault(_datahandlerBarsFractions);\n\nvar _datahandlerBars = require('./datahandler/bars');\n\nvar _datahandlerBars2 = _interopRequireDefault(_datahandlerBars);\n\nvar _pluginsAnnotations = require('./plugins/annotations');\n\nvar _pluginsAnnotations2 = _interopRequireDefault(_pluginsAnnotations);\n\nvar _pluginsAxes = require('./plugins/axes');\n\nvar _pluginsAxes2 = _interopRequireDefault(_pluginsAxes);\n\nvar _pluginsChartLabels = require('./plugins/chart-labels');\n\nvar _pluginsChartLabels2 = _interopRequireDefault(_pluginsChartLabels);\n\nvar _pluginsGrid = require('./plugins/grid');\n\nvar _pluginsGrid2 = _interopRequireDefault(_pluginsGrid);\n\nvar _pluginsLegend = require('./plugins/legend');\n\nvar _pluginsLegend2 = _interopRequireDefault(_pluginsLegend);\n\nvar _pluginsRangeSelector = require('./plugins/range-selector');\n\nvar _pluginsRangeSelector2 = _interopRequireDefault(_pluginsRangeSelector);\n\nvar _dygraphGviz = require('./dygraph-gviz');\n\nvar _dygraphGviz2 = _interopRequireDefault(_dygraphGviz);\n\n\"use strict\";\n/**\n * Creates an interactive, zoomable chart.\n *\n * @constructor\n * @param {div | String} div A div or the id of a div into which to construct\n * the chart.\n * @param {String | Function} file A file containing CSV data or a function\n * that returns this data. The most basic expected format for each line is\n * \"YYYY/MM/DD,val1,val2,...\". For more information, see\n * http://dygraphs.com/data.html.\n * @param {Object} attrs Various other attributes, e.g. errorBars determines\n * whether the input data contains error ranges. For a complete list of\n * options, see http://dygraphs.com/options.html.\n */\n\n\nvar Dygraph = function Dygraph(div, data, opts) {\n  this.__init__(div, data, opts);\n};\n\nDygraph.NAME = \"Dygraph\";\nDygraph.VERSION = \"2.0.0\"; // Various default values\n\nDygraph.DEFAULT_ROLL_PERIOD = 1;\nDygraph.DEFAULT_WIDTH = 480;\nDygraph.DEFAULT_HEIGHT = 320; // For max 60 Hz. animation:\n\nDygraph.ANIMATION_STEPS = 12;\nDygraph.ANIMATION_DURATION = 200;\n/**\n * Standard plotters. These may be used by clients.\n * Available plotters are:\n * - Dygraph.Plotters.linePlotter: draws central lines (most common)\n * - Dygraph.Plotters.errorPlotter: draws error bars\n * - Dygraph.Plotters.fillPlotter: draws fills under lines (used with fillGraph)\n *\n * By default, the plotter is [fillPlotter, errorPlotter, linePlotter].\n * This causes all the lines to be drawn over all the fills/error bars.\n */\n\nDygraph.Plotters = _dygraphCanvas2['default']._Plotters; // Used for initializing annotation CSS rules only once.\n\nDygraph.addedAnnotationCSS = false;\n/**\n * Initializes the Dygraph. This creates a new DIV and constructs the PlotKit\n * and context &lt;canvas&gt; inside of it. See the constructor for details.\n * on the parameters.\n * @param {Element} div the Element to render the graph into.\n * @param {string | Function} file Source data\n * @param {Object} attrs Miscellaneous other options\n * @private\n */\n\nDygraph.prototype.__init__ = function (div, file, attrs) {\n  this.is_initial_draw_ = true;\n  this.readyFns_ = []; // Support two-argument constructor\n\n  if (attrs === null || attrs === undefined) {\n    attrs = {};\n  }\n\n  attrs = Dygraph.copyUserAttrs_(attrs);\n\n  if (typeof div == 'string') {\n    div = document.getElementById(div);\n  }\n\n  if (!div) {\n    throw new Error('Constructing dygraph with a non-existent div!');\n  } // Copy the important bits into the object\n  // TODO(danvk): most of these should just stay in the attrs_ dictionary.\n\n\n  this.maindiv_ = div;\n  this.file_ = file;\n  this.rollPeriod_ = attrs.rollPeriod || Dygraph.DEFAULT_ROLL_PERIOD;\n  this.previousVerticalX_ = -1;\n  this.fractions_ = attrs.fractions || false;\n  this.dateWindow_ = attrs.dateWindow || null;\n  this.annotations_ = []; // Clear the div. This ensure that, if multiple dygraphs are passed the same\n  // div, then only one will be drawn.\n\n  div.innerHTML = \"\"; // For historical reasons, the 'width' and 'height' options trump all CSS\n  // rules _except_ for an explicit 'width' or 'height' on the div.\n  // As an added convenience, if the div has zero height (like <div></div> does\n  // without any styles), then we use a default height/width.\n\n  if (div.style.width === '' && attrs.width) {\n    div.style.width = attrs.width + \"px\";\n  }\n\n  if (div.style.height === '' && attrs.height) {\n    div.style.height = attrs.height + \"px\";\n  }\n\n  if (div.style.height === '' && div.clientHeight === 0) {\n    div.style.height = Dygraph.DEFAULT_HEIGHT + \"px\";\n\n    if (div.style.width === '') {\n      div.style.width = Dygraph.DEFAULT_WIDTH + \"px\";\n    }\n  } // These will be zero if the dygraph's div is hidden. In that case,\n  // use the user-specified attributes if present. If not, use zero\n  // and assume the user will call resize to fix things later.\n\n\n  this.width_ = div.clientWidth || attrs.width || 0;\n  this.height_ = div.clientHeight || attrs.height || 0; // TODO(danvk): set fillGraph to be part of attrs_ here, not user_attrs_.\n\n  if (attrs.stackedGraph) {\n    attrs.fillGraph = true; // TODO(nikhilk): Add any other stackedGraph checks here.\n  } // DEPRECATION WARNING: All option processing should be moved from\n  // attrs_ and user_attrs_ to options_, which holds all this information.\n  //\n  // Dygraphs has many options, some of which interact with one another.\n  // To keep track of everything, we maintain two sets of options:\n  //\n  //  this.user_attrs_   only options explicitly set by the user.\n  //  this.attrs_        defaults, options derived from user_attrs_, data.\n  //\n  // Options are then accessed this.attr_('attr'), which first looks at\n  // user_attrs_ and then computed attrs_. This way Dygraphs can set intelligent\n  // defaults without overriding behavior that the user specifically asks for.\n\n\n  this.user_attrs_ = {};\n  utils.update(this.user_attrs_, attrs); // This sequence ensures that Dygraph.DEFAULT_ATTRS is never modified.\n\n  this.attrs_ = {};\n  utils.updateDeep(this.attrs_, _dygraphDefaultAttrs2['default']);\n  this.boundaryIds_ = [];\n  this.setIndexByName_ = {};\n  this.datasetIndex_ = [];\n  this.registeredEvents_ = [];\n  this.eventListeners_ = {};\n  this.attributes_ = new _dygraphOptions2['default'](this); // Create the containing DIV and other interactive elements\n\n  this.createInterface_(); // Activate plugins.\n\n  this.plugins_ = [];\n  var plugins = Dygraph.PLUGINS.concat(this.getOption('plugins'));\n\n  for (var i = 0; i < plugins.length; i++) {\n    // the plugins option may contain either plugin classes or instances.\n    // Plugin instances contain an activate method.\n    var Plugin = plugins[i]; // either a constructor or an instance.\n\n    var pluginInstance;\n\n    if (typeof Plugin.activate !== 'undefined') {\n      pluginInstance = Plugin;\n    } else {\n      pluginInstance = new Plugin();\n    }\n\n    var pluginDict = {\n      plugin: pluginInstance,\n      events: {},\n      options: {},\n      pluginOptions: {}\n    };\n    var handlers = pluginInstance.activate(this);\n\n    for (var eventName in handlers) {\n      if (!handlers.hasOwnProperty(eventName)) continue; // TODO(danvk): validate eventName.\n\n      pluginDict.events[eventName] = handlers[eventName];\n    }\n\n    this.plugins_.push(pluginDict);\n  } // At this point, plugins can no longer register event handlers.\n  // Construct a map from event -> ordered list of [callback, plugin].\n\n\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var plugin_dict = this.plugins_[i];\n\n    for (var eventName in plugin_dict.events) {\n      if (!plugin_dict.events.hasOwnProperty(eventName)) continue;\n      var callback = plugin_dict.events[eventName];\n      var pair = [plugin_dict.plugin, callback];\n\n      if (!(eventName in this.eventListeners_)) {\n        this.eventListeners_[eventName] = [pair];\n      } else {\n        this.eventListeners_[eventName].push(pair);\n      }\n    }\n  }\n\n  this.createDragInterface_();\n  this.start_();\n};\n/**\n * Triggers a cascade of events to the various plugins which are interested in them.\n * Returns true if the \"default behavior\" should be prevented, i.e. if one\n * of the event listeners called event.preventDefault().\n * @private\n */\n\n\nDygraph.prototype.cascadeEvents_ = function (name, extra_props) {\n  if (!(name in this.eventListeners_)) return false; // QUESTION: can we use objects & prototypes to speed this up?\n\n  var e = {\n    dygraph: this,\n    cancelable: false,\n    defaultPrevented: false,\n    preventDefault: function preventDefault() {\n      if (!e.cancelable) throw \"Cannot call preventDefault on non-cancelable event.\";\n      e.defaultPrevented = true;\n    },\n    propagationStopped: false,\n    stopPropagation: function stopPropagation() {\n      e.propagationStopped = true;\n    }\n  };\n  utils.update(e, extra_props);\n  var callback_plugin_pairs = this.eventListeners_[name];\n\n  if (callback_plugin_pairs) {\n    for (var i = callback_plugin_pairs.length - 1; i >= 0; i--) {\n      var plugin = callback_plugin_pairs[i][0];\n      var callback = callback_plugin_pairs[i][1];\n      callback.call(plugin, e);\n      if (e.propagationStopped) break;\n    }\n  }\n\n  return e.defaultPrevented;\n};\n/**\n * Fetch a plugin instance of a particular class. Only for testing.\n * @private\n * @param {!Class} type The type of the plugin.\n * @return {Object} Instance of the plugin, or null if there is none.\n */\n\n\nDygraph.prototype.getPluginInstance_ = function (type) {\n  for (var i = 0; i < this.plugins_.length; i++) {\n    var p = this.plugins_[i];\n\n    if (p.plugin instanceof type) {\n      return p.plugin;\n    }\n  }\n\n  return null;\n};\n/**\n * Returns the zoomed status of the chart for one or both axes.\n *\n * Axis is an optional parameter. Can be set to 'x' or 'y'.\n *\n * The zoomed status for an axis is set whenever a user zooms using the mouse\n * or when the dateWindow or valueRange are updated. Double-clicking or calling\n * resetZoom() resets the zoom status for the chart.\n */\n\n\nDygraph.prototype.isZoomed = function (axis) {\n  var isZoomedX = !!this.dateWindow_;\n  if (axis === 'x') return isZoomedX;\n  var isZoomedY = this.axes_.map(function (axis) {\n    return !!axis.valueRange;\n  }).indexOf(true) >= 0;\n\n  if (axis === null || axis === undefined) {\n    return isZoomedX || isZoomedY;\n  }\n\n  if (axis === 'y') return isZoomedY;\n  throw new Error('axis parameter is [' + axis + '] must be null, \\'x\\' or \\'y\\'.');\n};\n/**\n * Returns information about the Dygraph object, including its containing ID.\n */\n\n\nDygraph.prototype.toString = function () {\n  var maindiv = this.maindiv_;\n  var id = maindiv && maindiv.id ? maindiv.id : maindiv;\n  return \"[Dygraph \" + id + \"]\";\n};\n/**\n * @private\n * Returns the value of an option. This may be set by the user (either in the\n * constructor or by calling updateOptions) or by dygraphs, and may be set to a\n * per-series value.\n * @param {string} name The name of the option, e.g. 'rollPeriod'.\n * @param {string} [seriesName] The name of the series to which the option\n * will be applied. If no per-series value of this option is available, then\n * the global value is returned. This is optional.\n * @return { ... } The value of the option.\n */\n\n\nDygraph.prototype.attr_ = function (name, seriesName) {\n  // For \"production\" code, this gets removed by uglifyjs.\n  if (typeof process !== 'undefined') {\n    if (process.env.NODE_ENV != 'production') {\n      if (typeof _dygraphOptionsReference2['default'] === 'undefined') {\n        console.error('Must include options reference JS for testing');\n      } else if (!_dygraphOptionsReference2['default'].hasOwnProperty(name)) {\n        console.error('Dygraphs is using property ' + name + ', which has no ' + 'entry in the Dygraphs.OPTIONS_REFERENCE listing.'); // Only log this error once.\n\n        _dygraphOptionsReference2['default'][name] = true;\n      }\n    }\n  }\n\n  return seriesName ? this.attributes_.getForSeries(name, seriesName) : this.attributes_.get(name);\n};\n/**\n * Returns the current value for an option, as set in the constructor or via\n * updateOptions. You may pass in an (optional) series name to get per-series\n * values for the option.\n *\n * All values returned by this method should be considered immutable. If you\n * modify them, there is no guarantee that the changes will be honored or that\n * dygraphs will remain in a consistent state. If you want to modify an option,\n * use updateOptions() instead.\n *\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {*} The value of the option.\n */\n\n\nDygraph.prototype.getOption = function (name, opt_seriesName) {\n  return this.attr_(name, opt_seriesName);\n};\n/**\n * Like getOption(), but specifically returns a number.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {number} The value of the option.\n * @private\n */\n\n\nDygraph.prototype.getNumericOption = function (name, opt_seriesName) {\n  return (\n    /** @type{number} */\n    this.getOption(name, opt_seriesName)\n  );\n};\n/**\n * Like getOption(), but specifically returns a string.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {string} The value of the option.\n * @private\n */\n\n\nDygraph.prototype.getStringOption = function (name, opt_seriesName) {\n  return (\n    /** @type{string} */\n    this.getOption(name, opt_seriesName)\n  );\n};\n/**\n * Like getOption(), but specifically returns a boolean.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {boolean} The value of the option.\n * @private\n */\n\n\nDygraph.prototype.getBooleanOption = function (name, opt_seriesName) {\n  return (\n    /** @type{boolean} */\n    this.getOption(name, opt_seriesName)\n  );\n};\n/**\n * Like getOption(), but specifically returns a function.\n * This is a convenience function for working with the Closure Compiler.\n * @param {string} name The name of the option (e.g. 'strokeWidth')\n * @param {string=} opt_seriesName Series name to get per-series values.\n * @return {function(...)} The value of the option.\n * @private\n */\n\n\nDygraph.prototype.getFunctionOption = function (name, opt_seriesName) {\n  return (\n    /** @type{function(...)} */\n    this.getOption(name, opt_seriesName)\n  );\n};\n\nDygraph.prototype.getOptionForAxis = function (name, axis) {\n  return this.attributes_.getForAxis(name, axis);\n};\n/**\n * @private\n * @param {string} axis The name of the axis (i.e. 'x', 'y' or 'y2')\n * @return { ... } A function mapping string -> option value\n */\n\n\nDygraph.prototype.optionsViewForAxis_ = function (axis) {\n  var self = this;\n  return function (opt) {\n    var axis_opts = self.user_attrs_.axes;\n\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    } // I don't like that this is in a second spot.\n\n\n    if (axis === 'x' && opt === 'logscale') {\n      // return the default value.\n      // TODO(konigsberg): pull the default from a global default.\n      return false;\n    } // user-specified attributes always trump defaults, even if they're less\n    // specific.\n\n\n    if (typeof self.user_attrs_[opt] != 'undefined') {\n      return self.user_attrs_[opt];\n    }\n\n    axis_opts = self.attrs_.axes;\n\n    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {\n      return axis_opts[axis][opt];\n    } // check old-style axis options\n    // TODO(danvk): add a deprecation warning if either of these match.\n\n\n    if (axis == 'y' && self.axes_[0].hasOwnProperty(opt)) {\n      return self.axes_[0][opt];\n    } else if (axis == 'y2' && self.axes_[1].hasOwnProperty(opt)) {\n      return self.axes_[1][opt];\n    }\n\n    return self.attr_(opt);\n  };\n};\n/**\n * Returns the current rolling period, as set by the user or an option.\n * @return {number} The number of points in the rolling window\n */\n\n\nDygraph.prototype.rollPeriod = function () {\n  return this.rollPeriod_;\n};\n/**\n * Returns the currently-visible x-range. This can be affected by zooming,\n * panning or a call to updateOptions.\n * Returns a two-element array: [left, right].\n * If the Dygraph has dates on the x-axis, these will be millis since epoch.\n */\n\n\nDygraph.prototype.xAxisRange = function () {\n  return this.dateWindow_ ? this.dateWindow_ : this.xAxisExtremes();\n};\n/**\n * Returns the lower- and upper-bound x-axis values of the data set.\n */\n\n\nDygraph.prototype.xAxisExtremes = function () {\n  var pad = this.getNumericOption('xRangePad') / this.plotter_.area.w;\n\n  if (this.numRows() === 0) {\n    return [0 - pad, 1 + pad];\n  }\n\n  var left = this.rawData_[0][0];\n  var right = this.rawData_[this.rawData_.length - 1][0];\n\n  if (pad) {\n    // Must keep this in sync with dygraph-layout _evaluateLimits()\n    var range = right - left;\n    left -= range * pad;\n    right += range * pad;\n  }\n\n  return [left, right];\n};\n/**\n * Returns the lower- and upper-bound y-axis values for each axis. These are\n * the ranges you'll get if you double-click to zoom out or call resetZoom().\n * The return value is an array of [low, high] tuples, one for each y-axis.\n */\n\n\nDygraph.prototype.yAxisExtremes = function () {\n  // TODO(danvk): this is pretty inefficient\n  var packed = this.gatherDatasets_(this.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var saveAxes = this.axes_;\n  this.computeYAxisRanges_(extremes);\n  var newAxes = this.axes_;\n  this.axes_ = saveAxes;\n  return newAxes.map(function (axis) {\n    return axis.extremeRange;\n  });\n};\n/**\n * Returns the currently-visible y-range for an axis. This can be affected by\n * zooming, panning or a call to updateOptions. Axis indices are zero-based. If\n * called with no arguments, returns the range of the first axis.\n * Returns a two-element array: [bottom, top].\n */\n\n\nDygraph.prototype.yAxisRange = function (idx) {\n  if (typeof idx == \"undefined\") idx = 0;\n\n  if (idx < 0 || idx >= this.axes_.length) {\n    return null;\n  }\n\n  var axis = this.axes_[idx];\n  return [axis.computedValueRange[0], axis.computedValueRange[1]];\n};\n/**\n * Returns the currently-visible y-ranges for each axis. This can be affected by\n * zooming, panning, calls to updateOptions, etc.\n * Returns an array of [bottom, top] pairs, one for each y-axis.\n */\n\n\nDygraph.prototype.yAxisRanges = function () {\n  var ret = [];\n\n  for (var i = 0; i < this.axes_.length; i++) {\n    ret.push(this.yAxisRange(i));\n  }\n\n  return ret;\n}; // TODO(danvk): use these functions throughout dygraphs.\n\n/**\n * Convert from data coordinates to canvas/div X/Y coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y]\n *\n * Note: use toDomXCoord instead of toDomCoords(x, null) and use toDomYCoord\n * instead of toDomCoords(null, y, axis).\n */\n\n\nDygraph.prototype.toDomCoords = function (x, y, axis) {\n  return [this.toDomXCoord(x), this.toDomYCoord(y, axis)];\n};\n/**\n * Convert from data x coordinates to canvas/div X coordinate.\n * If specified, do this conversion for the coordinate system of a particular\n * axis.\n * Returns a single value or null if x is null.\n */\n\n\nDygraph.prototype.toDomXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n  return area.x + (x - xRange[0]) / (xRange[1] - xRange[0]) * area.w;\n};\n/**\n * Convert from data x coordinates to canvas/div Y coordinate and optional\n * axis. Uses the first axis by default.\n *\n * returns a single value or null if y is null.\n */\n\n\nDygraph.prototype.toDomYCoord = function (y, axis) {\n  var pct = this.toPercentYCoord(y, axis);\n\n  if (pct === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  return area.y + pct * area.h;\n};\n/**\n * Convert from canvas/div coords to data coordinates.\n * If specified, do this conversion for the coordinate system of a particular\n * axis. Uses the first axis by default.\n * Returns a two-element array: [X, Y].\n *\n * Note: use toDataXCoord instead of toDataCoords(x, null) and use toDataYCoord\n * instead of toDataCoords(null, y, axis).\n */\n\n\nDygraph.prototype.toDataCoords = function (x, y, axis) {\n  return [this.toDataXCoord(x), this.toDataYCoord(y, axis)];\n};\n/**\n * Convert from canvas/div x coordinate to data coordinate.\n *\n * If x is null, this returns null.\n */\n\n\nDygraph.prototype.toDataXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var xRange = this.xAxisRange();\n\n  if (!this.attributes_.getForAxis(\"logscale\", 'x')) {\n    return xRange[0] + (x - area.x) / area.w * (xRange[1] - xRange[0]);\n  } else {\n    var pct = (x - area.x) / area.w;\n    return utils.logRangeFraction(xRange[0], xRange[1], pct);\n  }\n};\n/**\n * Convert from canvas/div y coord to value.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n */\n\n\nDygraph.prototype.toDataYCoord = function (y, axis) {\n  if (y === null) {\n    return null;\n  }\n\n  var area = this.plotter_.area;\n  var yRange = this.yAxisRange(axis);\n  if (typeof axis == \"undefined\") axis = 0;\n\n  if (!this.attributes_.getForAxis(\"logscale\", axis)) {\n    return yRange[0] + (area.y + area.h - y) / area.h * (yRange[1] - yRange[0]);\n  } else {\n    // Computing the inverse of toDomCoord.\n    var pct = (y - area.y) / area.h; // Note reversed yRange, y1 is on top with pct==0.\n\n    return utils.logRangeFraction(yRange[1], yRange[0], pct);\n  }\n};\n/**\n * Converts a y for an axis to a percentage from the top to the\n * bottom of the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the top of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If y is null, this returns null.\n * if axis is null, this uses the first axis.\n *\n * @param {number} y The data y-coordinate.\n * @param {number} [axis] The axis number on which the data coordinate lives.\n * @return {number} A fraction in [0, 1] where 0 = the top edge.\n */\n\n\nDygraph.prototype.toPercentYCoord = function (y, axis) {\n  if (y === null) {\n    return null;\n  }\n\n  if (typeof axis == \"undefined\") axis = 0;\n  var yRange = this.yAxisRange(axis);\n  var pct;\n  var logscale = this.attributes_.getForAxis(\"logscale\", axis);\n\n  if (logscale) {\n    var logr0 = utils.log10(yRange[0]);\n    var logr1 = utils.log10(yRange[1]);\n    pct = (logr1 - utils.log10(y)) / (logr1 - logr0);\n  } else {\n    // yRange[1] - y is unit distance from the bottom.\n    // yRange[1] - yRange[0] is the scale of the range.\n    // (yRange[1] - y) / (yRange[1] - yRange[0]) is the % from the bottom.\n    pct = (yRange[1] - y) / (yRange[1] - yRange[0]);\n  }\n\n  return pct;\n};\n/**\n * Converts an x value to a percentage from the left to the right of\n * the drawing area.\n *\n * If the coordinate represents a value visible on the canvas, then\n * the value will be between 0 and 1, where 0 is the left of the canvas.\n * However, this method will return values outside the range, as\n * values can fall outside the canvas.\n *\n * If x is null, this returns null.\n * @param {number} x The data x-coordinate.\n * @return {number} A fraction in [0, 1] where 0 = the left edge.\n */\n\n\nDygraph.prototype.toPercentXCoord = function (x) {\n  if (x === null) {\n    return null;\n  }\n\n  var xRange = this.xAxisRange();\n  var pct;\n  var logscale = this.attributes_.getForAxis(\"logscale\", 'x');\n\n  if (logscale === true) {\n    // logscale can be null so we test for true explicitly.\n    var logr0 = utils.log10(xRange[0]);\n    var logr1 = utils.log10(xRange[1]);\n    pct = (utils.log10(x) - logr0) / (logr1 - logr0);\n  } else {\n    // x - xRange[0] is unit distance from the left.\n    // xRange[1] - xRange[0] is the scale of the range.\n    // The full expression below is the % from the left.\n    pct = (x - xRange[0]) / (xRange[1] - xRange[0]);\n  }\n\n  return pct;\n};\n/**\n * Returns the number of columns (including the independent variable).\n * @return {number} The number of columns.\n */\n\n\nDygraph.prototype.numColumns = function () {\n  if (!this.rawData_) return 0;\n  return this.rawData_[0] ? this.rawData_[0].length : this.attr_(\"labels\").length;\n};\n/**\n * Returns the number of rows (excluding any header/label row).\n * @return {number} The number of rows, less any header.\n */\n\n\nDygraph.prototype.numRows = function () {\n  if (!this.rawData_) return 0;\n  return this.rawData_.length;\n};\n/**\n * Returns the value in the given row and column. If the row and column exceed\n * the bounds on the data, returns null. Also returns null if the value is\n * missing.\n * @param {number} row The row number of the data (0-based). Row 0 is the\n *     first row of data, not a header row.\n * @param {number} col The column number of the data (0-based)\n * @return {number} The value in the specified cell or null if the row/col\n *     were out of range.\n */\n\n\nDygraph.prototype.getValue = function (row, col) {\n  if (row < 0 || row > this.rawData_.length) return null;\n  if (col < 0 || col > this.rawData_[row].length) return null;\n  return this.rawData_[row][col];\n};\n/**\n * Generates interface elements for the Dygraph: a containing div, a div to\n * display the current point, and a textbox to adjust the rolling average\n * period. Also creates the Renderer/Layout elements.\n * @private\n */\n\n\nDygraph.prototype.createInterface_ = function () {\n  // Create the all-enclosing graph div\n  var enclosing = this.maindiv_;\n  this.graphDiv = document.createElement(\"div\"); // TODO(danvk): any other styles that are useful to set here?\n\n  this.graphDiv.style.textAlign = 'left'; // This is a CSS \"reset\"\n\n  this.graphDiv.style.position = 'relative';\n  enclosing.appendChild(this.graphDiv); // Create the canvas for interactive parts of the chart.\n\n  this.canvas_ = utils.createCanvas();\n  this.canvas_.style.position = \"absolute\"; // ... and for static parts of the chart.\n\n  this.hidden_ = this.createPlotKitCanvas_(this.canvas_);\n  this.canvas_ctx_ = utils.getContext(this.canvas_);\n  this.hidden_ctx_ = utils.getContext(this.hidden_);\n  this.resizeElements_(); // The interactive parts of the graph are drawn on top of the chart.\n\n  this.graphDiv.appendChild(this.hidden_);\n  this.graphDiv.appendChild(this.canvas_);\n  this.mouseEventElement_ = this.createMouseEventElement_(); // Create the grapher\n\n  this.layout_ = new _dygraphLayout2['default'](this);\n  var dygraph = this;\n\n  this.mouseMoveHandler_ = function (e) {\n    dygraph.mouseMove_(e);\n  };\n\n  this.mouseOutHandler_ = function (e) {\n    // The mouse has left the chart if:\n    // 1. e.target is inside the chart\n    // 2. e.relatedTarget is outside the chart\n    var target = e.target || e.fromElement;\n    var relatedTarget = e.relatedTarget || e.toElement;\n\n    if (utils.isNodeContainedBy(target, dygraph.graphDiv) && !utils.isNodeContainedBy(relatedTarget, dygraph.graphDiv)) {\n      dygraph.mouseOut_(e);\n    }\n  };\n\n  this.addAndTrackEvent(window, 'mouseout', this.mouseOutHandler_);\n  this.addAndTrackEvent(this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_); // Don't recreate and register the resize handler on subsequent calls.\n  // This happens when the graph is resized.\n\n  if (!this.resizeHandler_) {\n    this.resizeHandler_ = function (e) {\n      dygraph.resize();\n    }; // Update when the window is resized.\n    // TODO(danvk): drop frames depending on complexity of the chart.\n\n\n    this.addAndTrackEvent(window, 'resize', this.resizeHandler_);\n  }\n};\n\nDygraph.prototype.resizeElements_ = function () {\n  this.graphDiv.style.width = this.width_ + \"px\";\n  this.graphDiv.style.height = this.height_ + \"px\";\n  var pixelRatioOption = this.getNumericOption('pixelRatio');\n  var canvasScale = pixelRatioOption || utils.getContextPixelRatio(this.canvas_ctx_);\n  this.canvas_.width = this.width_ * canvasScale;\n  this.canvas_.height = this.height_ * canvasScale;\n  this.canvas_.style.width = this.width_ + \"px\"; // for IE\n\n  this.canvas_.style.height = this.height_ + \"px\"; // for IE\n\n  if (canvasScale !== 1) {\n    this.canvas_ctx_.scale(canvasScale, canvasScale);\n  }\n\n  var hiddenScale = pixelRatioOption || utils.getContextPixelRatio(this.hidden_ctx_);\n  this.hidden_.width = this.width_ * hiddenScale;\n  this.hidden_.height = this.height_ * hiddenScale;\n  this.hidden_.style.width = this.width_ + \"px\"; // for IE\n\n  this.hidden_.style.height = this.height_ + \"px\"; // for IE\n\n  if (hiddenScale !== 1) {\n    this.hidden_ctx_.scale(hiddenScale, hiddenScale);\n  }\n};\n/**\n * Detach DOM elements in the dygraph and null out all data references.\n * Calling this when you're done with a dygraph can dramatically reduce memory\n * usage. See, e.g., the tests/perf.html example.\n */\n\n\nDygraph.prototype.destroy = function () {\n  this.canvas_ctx_.restore();\n  this.hidden_ctx_.restore(); // Destroy any plugins, in the reverse order that they were registered.\n\n  for (var i = this.plugins_.length - 1; i >= 0; i--) {\n    var p = this.plugins_.pop();\n    if (p.plugin.destroy) p.plugin.destroy();\n  }\n\n  var removeRecursive = function removeRecursive(node) {\n    while (node.hasChildNodes()) {\n      removeRecursive(node.firstChild);\n      node.removeChild(node.firstChild);\n    }\n  };\n\n  this.removeTrackedEvents_(); // remove mouse event handlers (This may not be necessary anymore)\n\n  utils.removeEvent(window, 'mouseout', this.mouseOutHandler_);\n  utils.removeEvent(this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_); // remove window handlers\n\n  utils.removeEvent(window, 'resize', this.resizeHandler_);\n  this.resizeHandler_ = null;\n  removeRecursive(this.maindiv_);\n\n  var nullOut = function nullOut(obj) {\n    for (var n in obj) {\n      if (typeof obj[n] === 'object') {\n        obj[n] = null;\n      }\n    }\n  }; // These may not all be necessary, but it can't hurt...\n\n\n  nullOut(this.layout_);\n  nullOut(this.plotter_);\n  nullOut(this);\n};\n/**\n * Creates the canvas on which the chart will be drawn. Only the Renderer ever\n * draws on this particular canvas. All Dygraph work (i.e. drawing hover dots\n * or the zoom rectangles) is done on this.canvas_.\n * @param {Object} canvas The Dygraph canvas over which to overlay the plot\n * @return {Object} The newly-created canvas\n * @private\n */\n\n\nDygraph.prototype.createPlotKitCanvas_ = function (canvas) {\n  var h = utils.createCanvas();\n  h.style.position = \"absolute\"; // TODO(danvk): h should be offset from canvas. canvas needs to include\n  // some extra area to make it easier to zoom in on the far left and far\n  // right. h needs to be precisely the plot area, so that clipping occurs.\n\n  h.style.top = canvas.style.top;\n  h.style.left = canvas.style.left;\n  h.width = this.width_;\n  h.height = this.height_;\n  h.style.width = this.width_ + \"px\"; // for IE\n\n  h.style.height = this.height_ + \"px\"; // for IE\n\n  return h;\n};\n/**\n * Creates an overlay element used to handle mouse events.\n * @return {Object} The mouse event element.\n * @private\n */\n\n\nDygraph.prototype.createMouseEventElement_ = function () {\n  return this.canvas_;\n};\n/**\n * Generate a set of distinct colors for the data series. This is done with a\n * color wheel. Saturation/Value are customizable, and the hue is\n * equally-spaced around the color wheel. If a custom set of colors is\n * specified, that is used instead.\n * @private\n */\n\n\nDygraph.prototype.setColors_ = function () {\n  var labels = this.getLabels();\n  var num = labels.length - 1;\n  this.colors_ = [];\n  this.colorsMap_ = {}; // These are used for when no custom colors are specified.\n\n  var sat = this.getNumericOption('colorSaturation') || 1.0;\n  var val = this.getNumericOption('colorValue') || 0.5;\n  var half = Math.ceil(num / 2);\n  var colors = this.getOption('colors');\n  var visibility = this.visibility();\n\n  for (var i = 0; i < num; i++) {\n    if (!visibility[i]) {\n      continue;\n    }\n\n    var label = labels[i + 1];\n    var colorStr = this.attributes_.getForSeries('color', label);\n\n    if (!colorStr) {\n      if (colors) {\n        colorStr = colors[i % colors.length];\n      } else {\n        // alternate colors for high contrast.\n        var idx = i % 2 ? half + (i + 1) / 2 : Math.ceil((i + 1) / 2);\n        var hue = 1.0 * idx / (1 + num);\n        colorStr = utils.hsvToRGB(hue, sat, val);\n      }\n    }\n\n    this.colors_.push(colorStr);\n    this.colorsMap_[label] = colorStr;\n  }\n};\n/**\n * Return the list of colors. This is either the list of colors passed in the\n * attributes or the autogenerated list of rgb(r,g,b) strings.\n * This does not return colors for invisible series.\n * @return {Array.<string>} The list of colors.\n */\n\n\nDygraph.prototype.getColors = function () {\n  return this.colors_;\n};\n/**\n * Returns a few attributes of a series, i.e. its color, its visibility, which\n * axis it's assigned to, and its column in the original data.\n * Returns null if the series does not exist.\n * Otherwise, returns an object with column, visibility, color and axis properties.\n * The \"axis\" property will be set to 1 for y1 and 2 for y2.\n * The \"column\" property can be fed back into getValue(row, column) to get\n * values for this series.\n */\n\n\nDygraph.prototype.getPropertiesForSeries = function (series_name) {\n  var idx = -1;\n  var labels = this.getLabels();\n\n  for (var i = 1; i < labels.length; i++) {\n    if (labels[i] == series_name) {\n      idx = i;\n      break;\n    }\n  }\n\n  if (idx == -1) return null;\n  return {\n    name: series_name,\n    column: idx,\n    visible: this.visibility()[idx - 1],\n    color: this.colorsMap_[series_name],\n    axis: 1 + this.attributes_.axisForSeries(series_name)\n  };\n};\n/**\n * Create the text box to adjust the averaging period\n * @private\n */\n\n\nDygraph.prototype.createRollInterface_ = function () {\n  var _this = this; // Create a roller if one doesn't exist already.\n\n\n  var roller = this.roller_;\n\n  if (!roller) {\n    this.roller_ = roller = document.createElement(\"input\");\n    roller.type = \"text\";\n    roller.style.display = \"none\";\n    roller.className = 'dygraph-roller';\n    this.graphDiv.appendChild(roller);\n  }\n\n  var display = this.getBooleanOption('showRoller') ? 'block' : 'none';\n  var area = this.getArea();\n  var textAttr = {\n    \"top\": area.y + area.h - 25 + \"px\",\n    \"left\": area.x + 1 + \"px\",\n    \"display\": display\n  };\n  roller.size = \"2\";\n  roller.value = this.rollPeriod_;\n  utils.update(roller.style, textAttr);\n\n  roller.onchange = function () {\n    return _this.adjustRoll(roller.value);\n  };\n};\n/**\n * Set up all the mouse handlers needed to capture dragging behavior for zoom\n * events.\n * @private\n */\n\n\nDygraph.prototype.createDragInterface_ = function () {\n  var context = {\n    // Tracks whether the mouse is down right now\n    isZooming: false,\n    isPanning: false,\n    // is this drag part of a pan?\n    is2DPan: false,\n    // if so, is that pan 1- or 2-dimensional?\n    dragStartX: null,\n    // pixel coordinates\n    dragStartY: null,\n    // pixel coordinates\n    dragEndX: null,\n    // pixel coordinates\n    dragEndY: null,\n    // pixel coordinates\n    dragDirection: null,\n    prevEndX: null,\n    // pixel coordinates\n    prevEndY: null,\n    // pixel coordinates\n    prevDragDirection: null,\n    cancelNextDblclick: false,\n    // see comment in dygraph-interaction-model.js\n    // The value on the left side of the graph when a pan operation starts.\n    initialLeftmostDate: null,\n    // The number of units each pixel spans. (This won't be valid for log\n    // scales)\n    xUnitsPerPixel: null,\n    // TODO(danvk): update this comment\n    // The range in second/value units that the viewport encompasses during a\n    // panning operation.\n    dateRange: null,\n    // Top-left corner of the canvas, in DOM coords\n    // TODO(konigsberg): Rename topLeftCanvasX, topLeftCanvasY.\n    px: 0,\n    py: 0,\n    // Values for use with panEdgeFraction, which limit how far outside the\n    // graph's data boundaries it can be panned.\n    boundedDates: null,\n    // [minDate, maxDate]\n    boundedValues: null,\n    // [[minValue, maxValue] ...]\n    // We cover iframes during mouse interactions. See comments in\n    // dygraph-utils.js for more info on why this is a good idea.\n    tarp: new _iframeTarp2['default'](),\n    // contextB is the same thing as this context object but renamed.\n    initializeMouseDown: function initializeMouseDown(event, g, contextB) {\n      // prevents mouse drags from selecting page text.\n      if (event.preventDefault) {\n        event.preventDefault(); // Firefox, Chrome, etc.\n      } else {\n        event.returnValue = false; // IE\n\n        event.cancelBubble = true;\n      }\n\n      var canvasPos = utils.findPos(g.canvas_);\n      contextB.px = canvasPos.x;\n      contextB.py = canvasPos.y;\n      contextB.dragStartX = utils.dragGetX_(event, contextB);\n      contextB.dragStartY = utils.dragGetY_(event, contextB);\n      contextB.cancelNextDblclick = false;\n      contextB.tarp.cover();\n    },\n    destroy: function destroy() {\n      var context = this;\n\n      if (context.isZooming || context.isPanning) {\n        context.isZooming = false;\n        context.dragStartX = null;\n        context.dragStartY = null;\n      }\n\n      if (context.isPanning) {\n        context.isPanning = false;\n        context.draggingDate = null;\n        context.dateRange = null;\n\n        for (var i = 0; i < self.axes_.length; i++) {\n          delete self.axes_[i].draggingValue;\n          delete self.axes_[i].dragValueRange;\n        }\n      }\n\n      context.tarp.uncover();\n    }\n  };\n  var interactionModel = this.getOption(\"interactionModel\"); // Self is the graph.\n\n  var self = this; // Function that binds the graph and context to the handler.\n\n  var bindHandler = function bindHandler(handler) {\n    return function (event) {\n      handler(event, self, context);\n    };\n  };\n\n  for (var eventName in interactionModel) {\n    if (!interactionModel.hasOwnProperty(eventName)) continue;\n    this.addAndTrackEvent(this.mouseEventElement_, eventName, bindHandler(interactionModel[eventName]));\n  } // If the user releases the mouse button during a drag, but not over the\n  // canvas, then it doesn't count as a zooming action.\n\n\n  if (!interactionModel.willDestroyContextMyself) {\n    var mouseUpHandler = function mouseUpHandler(event) {\n      context.destroy();\n    };\n\n    this.addAndTrackEvent(document, 'mouseup', mouseUpHandler);\n  }\n};\n/**\n * Draw a gray zoom rectangle over the desired area of the canvas. Also clears\n * up any previous zoom rectangles that were drawn. This could be optimized to\n * avoid extra redrawing, but it's tricky to avoid interactions with the status\n * dots.\n *\n * @param {number} direction the direction of the zoom rectangle. Acceptable\n *     values are utils.HORIZONTAL and utils.VERTICAL.\n * @param {number} startX The X position where the drag started, in canvas\n *     coordinates.\n * @param {number} endX The current X position of the drag, in canvas coords.\n * @param {number} startY The Y position where the drag started, in canvas\n *     coordinates.\n * @param {number} endY The current Y position of the drag, in canvas coords.\n * @param {number} prevDirection the value of direction on the previous call to\n *     this function. Used to avoid excess redrawing\n * @param {number} prevEndX The value of endX on the previous call to this\n *     function. Used to avoid excess redrawing\n * @param {number} prevEndY The value of endY on the previous call to this\n *     function. Used to avoid excess redrawing\n * @private\n */\n\n\nDygraph.prototype.drawZoomRect_ = function (direction, startX, endX, startY, endY, prevDirection, prevEndX, prevEndY) {\n  var ctx = this.canvas_ctx_; // Clean up from the previous rect if necessary\n\n  if (prevDirection == utils.HORIZONTAL) {\n    ctx.clearRect(Math.min(startX, prevEndX), this.layout_.getPlotArea().y, Math.abs(startX - prevEndX), this.layout_.getPlotArea().h);\n  } else if (prevDirection == utils.VERTICAL) {\n    ctx.clearRect(this.layout_.getPlotArea().x, Math.min(startY, prevEndY), this.layout_.getPlotArea().w, Math.abs(startY - prevEndY));\n  } // Draw a light-grey rectangle to show the new viewing area\n\n\n  if (direction == utils.HORIZONTAL) {\n    if (endX && startX) {\n      ctx.fillStyle = \"rgba(128,128,128,0.33)\";\n      ctx.fillRect(Math.min(startX, endX), this.layout_.getPlotArea().y, Math.abs(endX - startX), this.layout_.getPlotArea().h);\n    }\n  } else if (direction == utils.VERTICAL) {\n    if (endY && startY) {\n      ctx.fillStyle = \"rgba(128,128,128,0.33)\";\n      ctx.fillRect(this.layout_.getPlotArea().x, Math.min(startY, endY), this.layout_.getPlotArea().w, Math.abs(endY - startY));\n    }\n  }\n};\n/**\n * Clear the zoom rectangle (and perform no zoom).\n * @private\n */\n\n\nDygraph.prototype.clearZoomRect_ = function () {\n  this.currentZoomRectArgs_ = null;\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n};\n/**\n * Zoom to something containing [lowX, highX]. These are pixel coordinates in\n * the canvas. The exact zoom window may be slightly larger if there are no data\n * points near lowX or highX. Don't confuse this function with doZoomXDates,\n * which accepts dates that match the raw data. This function redraws the graph.\n *\n * @param {number} lowX The leftmost pixel value that should be visible.\n * @param {number} highX The rightmost pixel value that should be visible.\n * @private\n */\n\n\nDygraph.prototype.doZoomX_ = function (lowX, highX) {\n  this.currentZoomRectArgs_ = null; // Find the earliest and latest dates contained in this canvasx range.\n  // Convert the call to date ranges of the raw data.\n\n  var minDate = this.toDataXCoord(lowX);\n  var maxDate = this.toDataXCoord(highX);\n  this.doZoomXDates_(minDate, maxDate);\n};\n/**\n * Zoom to something containing [minDate, maxDate] values. Don't confuse this\n * method with doZoomX which accepts pixel coordinates. This function redraws\n * the graph.\n *\n * @param {number} minDate The minimum date that should be visible.\n * @param {number} maxDate The maximum date that should be visible.\n * @private\n */\n\n\nDygraph.prototype.doZoomXDates_ = function (minDate, maxDate) {\n  var _this2 = this; // TODO(danvk): when xAxisRange is null (i.e. \"fit to data\", the animation\n  // can produce strange effects. Rather than the x-axis transitioning slowly\n  // between values, it can jerk around.)\n\n\n  var old_window = this.xAxisRange();\n  var new_window = [minDate, maxDate];\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n  this.doAnimatedZoom(old_window, new_window, null, null, function () {\n    if (zoomCallback) {\n      zoomCallback.call(_this2, minDate, maxDate, _this2.yAxisRanges());\n    }\n  });\n};\n/**\n * Zoom to something containing [lowY, highY]. These are pixel coordinates in\n * the canvas. This function redraws the graph.\n *\n * @param {number} lowY The topmost pixel value that should be visible.\n * @param {number} highY The lowest pixel value that should be visible.\n * @private\n */\n\n\nDygraph.prototype.doZoomY_ = function (lowY, highY) {\n  var _this3 = this;\n\n  this.currentZoomRectArgs_ = null; // Find the highest and lowest values in pixel range for each axis.\n  // Note that lowY (in pixels) corresponds to the max Value (in data coords).\n  // This is because pixels increase as you go down on the screen, whereas data\n  // coordinates increase as you go up the screen.\n\n  var oldValueRanges = this.yAxisRanges();\n  var newValueRanges = [];\n\n  for (var i = 0; i < this.axes_.length; i++) {\n    var hi = this.toDataYCoord(lowY, i);\n    var low = this.toDataYCoord(highY, i);\n    newValueRanges.push([low, hi]);\n  }\n\n  var zoomCallback = this.getFunctionOption('zoomCallback');\n  this.doAnimatedZoom(null, null, oldValueRanges, newValueRanges, function () {\n    if (zoomCallback) {\n      var _xAxisRange = _this3.xAxisRange();\n\n      var _xAxisRange2 = _slicedToArray(_xAxisRange, 2);\n\n      var minX = _xAxisRange2[0];\n      var maxX = _xAxisRange2[1];\n      zoomCallback.call(_this3, minX, maxX, _this3.yAxisRanges());\n    }\n  });\n};\n/**\n * Transition function to use in animations. Returns values between 0.0\n * (totally old values) and 1.0 (totally new values) for each frame.\n * @private\n */\n\n\nDygraph.zoomAnimationFunction = function (frame, numFrames) {\n  var k = 1.5;\n  return (1.0 - Math.pow(k, -frame)) / (1.0 - Math.pow(k, -numFrames));\n};\n/**\n * Reset the zoom to the original view coordinates. This is the same as\n * double-clicking on the graph.\n */\n\n\nDygraph.prototype.resetZoom = function () {\n  var _this4 = this;\n\n  var dirtyX = this.isZoomed('x');\n  var dirtyY = this.isZoomed('y');\n  var dirty = dirtyX || dirtyY; // Clear any selection, since it's likely to be drawn in the wrong place.\n\n  this.clearSelection();\n  if (!dirty) return; // Calculate extremes to avoid lack of padding on reset.\n\n  var _xAxisExtremes = this.xAxisExtremes();\n\n  var _xAxisExtremes2 = _slicedToArray(_xAxisExtremes, 2);\n\n  var minDate = _xAxisExtremes2[0];\n  var maxDate = _xAxisExtremes2[1];\n  var animatedZooms = this.getBooleanOption('animatedZooms');\n  var zoomCallback = this.getFunctionOption('zoomCallback'); // TODO(danvk): merge this block w/ the code below.\n  // TODO(danvk): factor out a generic, public zoomTo method.\n\n  if (!animatedZooms) {\n    this.dateWindow_ = null;\n    this.axes_.forEach(function (axis) {\n      if (axis.valueRange) delete axis.valueRange;\n    });\n    this.drawGraph_();\n\n    if (zoomCallback) {\n      zoomCallback.call(this, minDate, maxDate, this.yAxisRanges());\n    }\n\n    return;\n  }\n\n  var oldWindow = null,\n      newWindow = null,\n      oldValueRanges = null,\n      newValueRanges = null;\n\n  if (dirtyX) {\n    oldWindow = this.xAxisRange();\n    newWindow = [minDate, maxDate];\n  }\n\n  if (dirtyY) {\n    oldValueRanges = this.yAxisRanges();\n    newValueRanges = this.yAxisExtremes();\n  }\n\n  this.doAnimatedZoom(oldWindow, newWindow, oldValueRanges, newValueRanges, function () {\n    _this4.dateWindow_ = null;\n\n    _this4.axes_.forEach(function (axis) {\n      if (axis.valueRange) delete axis.valueRange;\n    });\n\n    if (zoomCallback) {\n      zoomCallback.call(_this4, minDate, maxDate, _this4.yAxisRanges());\n    }\n  });\n};\n/**\n * Combined animation logic for all zoom functions.\n * either the x parameters or y parameters may be null.\n * @private\n */\n\n\nDygraph.prototype.doAnimatedZoom = function (oldXRange, newXRange, oldYRanges, newYRanges, callback) {\n  var _this5 = this;\n\n  var steps = this.getBooleanOption(\"animatedZooms\") ? Dygraph.ANIMATION_STEPS : 1;\n  var windows = [];\n  var valueRanges = [];\n  var step, frac;\n\n  if (oldXRange !== null && newXRange !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      windows[step - 1] = [oldXRange[0] * (1 - frac) + frac * newXRange[0], oldXRange[1] * (1 - frac) + frac * newXRange[1]];\n    }\n  }\n\n  if (oldYRanges !== null && newYRanges !== null) {\n    for (step = 1; step <= steps; step++) {\n      frac = Dygraph.zoomAnimationFunction(step, steps);\n      var thisRange = [];\n\n      for (var j = 0; j < this.axes_.length; j++) {\n        thisRange.push([oldYRanges[j][0] * (1 - frac) + frac * newYRanges[j][0], oldYRanges[j][1] * (1 - frac) + frac * newYRanges[j][1]]);\n      }\n\n      valueRanges[step - 1] = thisRange;\n    }\n  }\n\n  utils.repeatAndCleanup(function (step) {\n    if (valueRanges.length) {\n      for (var i = 0; i < _this5.axes_.length; i++) {\n        var w = valueRanges[step][i];\n        _this5.axes_[i].valueRange = [w[0], w[1]];\n      }\n    }\n\n    if (windows.length) {\n      _this5.dateWindow_ = windows[step];\n    }\n\n    _this5.drawGraph_();\n  }, steps, Dygraph.ANIMATION_DURATION / steps, callback);\n};\n/**\n * Get the current graph's area object.\n *\n * Returns: {x, y, w, h}\n */\n\n\nDygraph.prototype.getArea = function () {\n  return this.plotter_.area;\n};\n/**\n * Convert a mouse event to DOM coordinates relative to the graph origin.\n *\n * Returns a two-element array: [X, Y].\n */\n\n\nDygraph.prototype.eventToDomCoords = function (event) {\n  if (event.offsetX && event.offsetY) {\n    return [event.offsetX, event.offsetY];\n  } else {\n    var eventElementPos = utils.findPos(this.mouseEventElement_);\n    var canvasx = utils.pageX(event) - eventElementPos.x;\n    var canvasy = utils.pageY(event) - eventElementPos.y;\n    return [canvasx, canvasy];\n  }\n};\n/**\n * Given a canvas X coordinate, find the closest row.\n * @param {number} domX graph-relative DOM X coordinate\n * Returns {number} row number.\n * @private\n */\n\n\nDygraph.prototype.findClosestRow = function (domX) {\n  var minDistX = Infinity;\n  var closestRow = -1;\n  var sets = this.layout_.points;\n\n  for (var i = 0; i < sets.length; i++) {\n    var points = sets[i];\n    var len = points.length;\n\n    for (var j = 0; j < len; j++) {\n      var point = points[j];\n      if (!utils.isValidPoint(point, true)) continue;\n      var dist = Math.abs(point.canvasx - domX);\n\n      if (dist < minDistX) {\n        minDistX = dist;\n        closestRow = point.idx;\n      }\n    }\n  }\n\n  return closestRow;\n};\n/**\n * Given canvas X,Y coordinates, find the closest point.\n *\n * This finds the individual data point across all visible series\n * that's closest to the supplied DOM coordinates using the standard\n * Euclidean X,Y distance.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\n\n\nDygraph.prototype.findClosestPoint = function (domX, domY) {\n  var minDist = Infinity;\n  var dist, dx, dy, point, closestPoint, closestSeries, closestRow;\n\n  for (var setIdx = this.layout_.points.length - 1; setIdx >= 0; --setIdx) {\n    var points = this.layout_.points[setIdx];\n\n    for (var i = 0; i < points.length; ++i) {\n      point = points[i];\n      if (!utils.isValidPoint(point)) continue;\n      dx = point.canvasx - domX;\n      dy = point.canvasy - domY;\n      dist = dx * dx + dy * dy;\n\n      if (dist < minDist) {\n        minDist = dist;\n        closestPoint = point;\n        closestSeries = setIdx;\n        closestRow = point.idx;\n      }\n    }\n  }\n\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: closestRow,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n/**\n * Given canvas X,Y coordinates, find the touched area in a stacked graph.\n *\n * This first finds the X data point closest to the supplied DOM X coordinate,\n * then finds the series which puts the Y coordinate on top of its filled area,\n * using linear interpolation between adjacent point pairs.\n *\n * @param {number} domX graph-relative DOM X coordinate\n * @param {number} domY graph-relative DOM Y coordinate\n * Returns: {row, seriesName, point}\n * @private\n */\n\n\nDygraph.prototype.findStackedPoint = function (domX, domY) {\n  var row = this.findClosestRow(domX);\n  var closestPoint, closestSeries;\n\n  for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n    var boundary = this.getLeftBoundary_(setIdx);\n    var rowIdx = row - boundary;\n    var points = this.layout_.points[setIdx];\n    if (rowIdx >= points.length) continue;\n    var p1 = points[rowIdx];\n    if (!utils.isValidPoint(p1)) continue;\n    var py = p1.canvasy;\n\n    if (domX > p1.canvasx && rowIdx + 1 < points.length) {\n      // interpolate series Y value using next point\n      var p2 = points[rowIdx + 1];\n\n      if (utils.isValidPoint(p2)) {\n        var dx = p2.canvasx - p1.canvasx;\n\n        if (dx > 0) {\n          var r = (domX - p1.canvasx) / dx;\n          py += r * (p2.canvasy - p1.canvasy);\n        }\n      }\n    } else if (domX < p1.canvasx && rowIdx > 0) {\n      // interpolate series Y value using previous point\n      var p0 = points[rowIdx - 1];\n\n      if (utils.isValidPoint(p0)) {\n        var dx = p1.canvasx - p0.canvasx;\n\n        if (dx > 0) {\n          var r = (p1.canvasx - domX) / dx;\n          py += r * (p0.canvasy - p1.canvasy);\n        }\n      }\n    } // Stop if the point (domX, py) is above this series' upper edge\n\n\n    if (setIdx === 0 || py < domY) {\n      closestPoint = p1;\n      closestSeries = setIdx;\n    }\n  }\n\n  var name = this.layout_.setNames[closestSeries];\n  return {\n    row: row,\n    seriesName: name,\n    point: closestPoint\n  };\n};\n/**\n * When the mouse moves in the canvas, display information about a nearby data\n * point and draw dots over those points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @param {Object} event The mousemove event from the browser.\n * @private\n */\n\n\nDygraph.prototype.mouseMove_ = function (event) {\n  // This prevents JS errors when mousing over the canvas before data loads.\n  var points = this.layout_.points;\n  if (points === undefined || points === null) return;\n  var canvasCoords = this.eventToDomCoords(event);\n  var canvasx = canvasCoords[0];\n  var canvasy = canvasCoords[1];\n  var highlightSeriesOpts = this.getOption(\"highlightSeriesOpts\");\n  var selectionChanged = false;\n\n  if (highlightSeriesOpts && !this.isSeriesLocked()) {\n    var closest;\n\n    if (this.getBooleanOption(\"stackedGraph\")) {\n      closest = this.findStackedPoint(canvasx, canvasy);\n    } else {\n      closest = this.findClosestPoint(canvasx, canvasy);\n    }\n\n    selectionChanged = this.setSelection(closest.row, closest.seriesName);\n  } else {\n    var idx = this.findClosestRow(canvasx);\n    selectionChanged = this.setSelection(idx);\n  }\n\n  var callback = this.getFunctionOption(\"highlightCallback\");\n\n  if (callback && selectionChanged) {\n    callback.call(this, event, this.lastx_, this.selPoints_, this.lastRow_, this.highlightSet_);\n  }\n};\n/**\n * Fetch left offset from the specified set index or if not passed, the\n * first defined boundaryIds record (see bug #236).\n * @private\n */\n\n\nDygraph.prototype.getLeftBoundary_ = function (setIdx) {\n  if (this.boundaryIds_[setIdx]) {\n    return this.boundaryIds_[setIdx][0];\n  } else {\n    for (var i = 0; i < this.boundaryIds_.length; i++) {\n      if (this.boundaryIds_[i] !== undefined) {\n        return this.boundaryIds_[i][0];\n      }\n    }\n\n    return 0;\n  }\n};\n\nDygraph.prototype.animateSelection_ = function (direction) {\n  var totalSteps = 10;\n  var millis = 30;\n  if (this.fadeLevel === undefined) this.fadeLevel = 0;\n  if (this.animateId === undefined) this.animateId = 0;\n  var start = this.fadeLevel;\n  var steps = direction < 0 ? start : totalSteps - start;\n\n  if (steps <= 0) {\n    if (this.fadeLevel) {\n      this.updateSelection_(1.0);\n    }\n\n    return;\n  }\n\n  var thisId = ++this.animateId;\n  var that = this;\n\n  var cleanupIfClearing = function cleanupIfClearing() {\n    // if we haven't reached fadeLevel 0 in the max frame time,\n    // ensure that the clear happens and just go to 0\n    if (that.fadeLevel !== 0 && direction < 0) {\n      that.fadeLevel = 0;\n      that.clearSelection();\n    }\n  };\n\n  utils.repeatAndCleanup(function (n) {\n    // ignore simultaneous animations\n    if (that.animateId != thisId) return;\n    that.fadeLevel += direction;\n\n    if (that.fadeLevel === 0) {\n      that.clearSelection();\n    } else {\n      that.updateSelection_(that.fadeLevel / totalSteps);\n    }\n  }, steps, millis, cleanupIfClearing);\n};\n/**\n * Draw dots over the selectied points in the data series. This function\n * takes care of cleanup of previously-drawn dots.\n * @private\n */\n\n\nDygraph.prototype.updateSelection_ = function (opt_animFraction) {\n  /*var defaultPrevented = */\n  this.cascadeEvents_('select', {\n    selectedRow: this.lastRow_ === -1 ? undefined : this.lastRow_,\n    selectedX: this.lastx_ === -1 ? undefined : this.lastx_,\n    selectedPoints: this.selPoints_\n  }); // TODO(danvk): use defaultPrevented here?\n  // Clear the previously drawn vertical, if there is one\n\n  var i;\n  var ctx = this.canvas_ctx_;\n\n  if (this.getOption('highlightSeriesOpts')) {\n    ctx.clearRect(0, 0, this.width_, this.height_);\n    var alpha = 1.0 - this.getNumericOption('highlightSeriesBackgroundAlpha');\n    var backgroundColor = utils.toRGB_(this.getOption('highlightSeriesBackgroundColor'));\n\n    if (alpha) {\n      // Activating background fade includes an animation effect for a gradual\n      // fade. TODO(klausw): make this independently configurable if it causes\n      // issues? Use a shared preference to control animations?\n      var animateBackgroundFade = true;\n\n      if (animateBackgroundFade) {\n        if (opt_animFraction === undefined) {\n          // start a new animation\n          this.animateSelection_(1);\n          return;\n        }\n\n        alpha *= opt_animFraction;\n      }\n\n      ctx.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + alpha + ')';\n      ctx.fillRect(0, 0, this.width_, this.height_);\n    } // Redraw only the highlighted series in the interactive canvas (not the\n    // static plot canvas, which is where series are usually drawn).\n\n\n    this.plotter_._renderLineChart(this.highlightSet_, ctx);\n  } else if (this.previousVerticalX_ >= 0) {\n    // Determine the maximum highlight circle size.\n    var maxCircleSize = 0;\n    var labels = this.attr_('labels');\n\n    for (i = 1; i < labels.length; i++) {\n      var r = this.getNumericOption('highlightCircleSize', labels[i]);\n      if (r > maxCircleSize) maxCircleSize = r;\n    }\n\n    var px = this.previousVerticalX_;\n    ctx.clearRect(px - maxCircleSize - 1, 0, 2 * maxCircleSize + 2, this.height_);\n  }\n\n  if (this.selPoints_.length > 0) {\n    // Draw colored circles over the center of each selected point\n    var canvasx = this.selPoints_[0].canvasx;\n    ctx.save();\n\n    for (i = 0; i < this.selPoints_.length; i++) {\n      var pt = this.selPoints_[i];\n      if (isNaN(pt.canvasy)) continue;\n      var circleSize = this.getNumericOption('highlightCircleSize', pt.name);\n      var callback = this.getFunctionOption(\"drawHighlightPointCallback\", pt.name);\n      var color = this.plotter_.colors[pt.name];\n\n      if (!callback) {\n        callback = utils.Circles.DEFAULT;\n      }\n\n      ctx.lineWidth = this.getNumericOption('strokeWidth', pt.name);\n      ctx.strokeStyle = color;\n      ctx.fillStyle = color;\n      callback.call(this, this, pt.name, ctx, canvasx, pt.canvasy, color, circleSize, pt.idx);\n    }\n\n    ctx.restore();\n    this.previousVerticalX_ = canvasx;\n  }\n};\n/**\n * Manually set the selected points and display information about them in the\n * legend. The selection can be cleared using clearSelection() and queried\n * using getSelection().\n *\n * To set a selected series but not a selected point, call setSelection with\n * row=false and the selected series name.\n *\n * @param {number} row Row number that should be highlighted (i.e. appear with\n * hover dots on the chart).\n * @param {seriesName} optional series name to highlight that series with the\n * the highlightSeriesOpts setting.\n * @param { locked } optional If true, keep seriesName selected when mousing\n * over the graph, disabling closest-series highlighting. Call clearSelection()\n * to unlock it.\n */\n\n\nDygraph.prototype.setSelection = function (row, opt_seriesName, opt_locked) {\n  // Extract the points we've selected\n  this.selPoints_ = [];\n  var changed = false;\n\n  if (row !== false && row >= 0) {\n    if (row != this.lastRow_) changed = true;\n    this.lastRow_ = row;\n\n    for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {\n      var points = this.layout_.points[setIdx]; // Check if the point at the appropriate index is the point we're looking\n      // for.  If it is, just use it, otherwise search the array for a point\n      // in the proper place.\n\n      var setRow = row - this.getLeftBoundary_(setIdx);\n\n      if (setRow >= 0 && setRow < points.length && points[setRow].idx == row) {\n        var point = points[setRow];\n        if (point.yval !== null) this.selPoints_.push(point);\n      } else {\n        for (var pointIdx = 0; pointIdx < points.length; ++pointIdx) {\n          var point = points[pointIdx];\n\n          if (point.idx == row) {\n            if (point.yval !== null) {\n              this.selPoints_.push(point);\n            }\n\n            break;\n          }\n        }\n      }\n    }\n  } else {\n    if (this.lastRow_ >= 0) changed = true;\n    this.lastRow_ = -1;\n  }\n\n  if (this.selPoints_.length) {\n    this.lastx_ = this.selPoints_[0].xval;\n  } else {\n    this.lastx_ = -1;\n  }\n\n  if (opt_seriesName !== undefined) {\n    if (this.highlightSet_ !== opt_seriesName) changed = true;\n    this.highlightSet_ = opt_seriesName;\n  }\n\n  if (opt_locked !== undefined) {\n    this.lockedSet_ = opt_locked;\n  }\n\n  if (changed) {\n    this.updateSelection_(undefined);\n  }\n\n  return changed;\n};\n/**\n * The mouse has left the canvas. Clear out whatever artifacts remain\n * @param {Object} event the mouseout event from the browser.\n * @private\n */\n\n\nDygraph.prototype.mouseOut_ = function (event) {\n  if (this.getFunctionOption(\"unhighlightCallback\")) {\n    this.getFunctionOption(\"unhighlightCallback\").call(this, event);\n  }\n\n  if (this.getBooleanOption(\"hideOverlayOnMouseOut\") && !this.lockedSet_) {\n    this.clearSelection();\n  }\n};\n/**\n * Clears the current selection (i.e. points that were highlighted by moving\n * the mouse over the chart).\n */\n\n\nDygraph.prototype.clearSelection = function () {\n  this.cascadeEvents_('deselect', {});\n  this.lockedSet_ = false; // Get rid of the overlay data\n\n  if (this.fadeLevel) {\n    this.animateSelection_(-1);\n    return;\n  }\n\n  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);\n  this.fadeLevel = 0;\n  this.selPoints_ = [];\n  this.lastx_ = -1;\n  this.lastRow_ = -1;\n  this.highlightSet_ = null;\n};\n/**\n * Returns the number of the currently selected row. To get data for this row,\n * you can use the getValue method.\n * @return {number} row number, or -1 if nothing is selected\n */\n\n\nDygraph.prototype.getSelection = function () {\n  if (!this.selPoints_ || this.selPoints_.length < 1) {\n    return -1;\n  }\n\n  for (var setIdx = 0; setIdx < this.layout_.points.length; setIdx++) {\n    var points = this.layout_.points[setIdx];\n\n    for (var row = 0; row < points.length; row++) {\n      if (points[row].x == this.selPoints_[0].x) {\n        return points[row].idx;\n      }\n    }\n  }\n\n  return -1;\n};\n/**\n * Returns the name of the currently-highlighted series.\n * Only available when the highlightSeriesOpts option is in use.\n */\n\n\nDygraph.prototype.getHighlightSeries = function () {\n  return this.highlightSet_;\n};\n/**\n * Returns true if the currently-highlighted series was locked\n * via setSelection(..., seriesName, true).\n */\n\n\nDygraph.prototype.isSeriesLocked = function () {\n  return this.lockedSet_;\n};\n/**\n * Fires when there's data available to be graphed.\n * @param {string} data Raw CSV data to be plotted\n * @private\n */\n\n\nDygraph.prototype.loadedEvent_ = function (data) {\n  this.rawData_ = this.parseCSV_(data);\n  this.cascadeDataDidUpdateEvent_();\n  this.predraw_();\n};\n/**\n * Add ticks on the x-axis representing years, months, quarters, weeks, or days\n * @private\n */\n\n\nDygraph.prototype.addXTicks_ = function () {\n  // Determine the correct ticks scale on the x-axis: quarterly, monthly, ...\n  var range;\n\n  if (this.dateWindow_) {\n    range = [this.dateWindow_[0], this.dateWindow_[1]];\n  } else {\n    range = this.xAxisExtremes();\n  }\n\n  var xAxisOptionsView = this.optionsViewForAxis_('x');\n  var xTicks = xAxisOptionsView('ticker')(range[0], range[1], this.plotter_.area.w, // TODO(danvk): should be area.width\n  xAxisOptionsView, this); // var msg = 'ticker(' + range[0] + ', ' + range[1] + ', ' + this.width_ + ', ' + this.attr_('pixelsPerXLabel') + ') -> ' + JSON.stringify(xTicks);\n  // console.log(msg);\n\n  this.layout_.setXTicks(xTicks);\n};\n/**\n * Returns the correct handler class for the currently set options.\n * @private\n */\n\n\nDygraph.prototype.getHandlerClass_ = function () {\n  var handlerClass;\n\n  if (this.attr_('dataHandler')) {\n    handlerClass = this.attr_('dataHandler');\n  } else if (this.fractions_) {\n    if (this.getBooleanOption('errorBars')) {\n      handlerClass = _datahandlerBarsFractions2['default'];\n    } else {\n      handlerClass = _datahandlerDefaultFractions2['default'];\n    }\n  } else if (this.getBooleanOption('customBars')) {\n    handlerClass = _datahandlerBarsCustom2['default'];\n  } else if (this.getBooleanOption('errorBars')) {\n    handlerClass = _datahandlerBarsError2['default'];\n  } else {\n    handlerClass = _datahandlerDefault2['default'];\n  }\n\n  return handlerClass;\n};\n/**\n * @private\n * This function is called once when the chart's data is changed or the options\n * dictionary is updated. It is _not_ called when the user pans or zooms. The\n * idea is that values derived from the chart's data can be computed here,\n * rather than every time the chart is drawn. This includes things like the\n * number of axes, rolling averages, etc.\n */\n\n\nDygraph.prototype.predraw_ = function () {\n  var start = new Date(); // Create the correct dataHandler\n\n  this.dataHandler_ = new (this.getHandlerClass_())();\n  this.layout_.computePlotArea(); // TODO(danvk): move more computations out of drawGraph_ and into here.\n\n  this.computeYAxes_();\n\n  if (!this.is_initial_draw_) {\n    this.canvas_ctx_.restore();\n    this.hidden_ctx_.restore();\n  }\n\n  this.canvas_ctx_.save();\n  this.hidden_ctx_.save(); // Create a new plotter.\n\n  this.plotter_ = new _dygraphCanvas2['default'](this, this.hidden_, this.hidden_ctx_, this.layout_); // The roller sits in the bottom left corner of the chart. We don't know where\n  // this will be until the options are available, so it's positioned here.\n\n  this.createRollInterface_();\n  this.cascadeEvents_('predraw'); // Convert the raw data (a 2D array) into the internal format and compute\n  // rolling averages.\n\n  this.rolledSeries_ = [null]; // x-axis is the first series and it's special\n\n  for (var i = 1; i < this.numColumns(); i++) {\n    // var logScale = this.attr_('logscale', i); // TODO(klausw): this looks wrong // konigsberg thinks so too.\n    var series = this.dataHandler_.extractSeries(this.rawData_, i, this.attributes_);\n\n    if (this.rollPeriod_ > 1) {\n      series = this.dataHandler_.rollingAverage(series, this.rollPeriod_, this.attributes_);\n    }\n\n    this.rolledSeries_.push(series);\n  } // If the data or options have changed, then we'd better redraw.\n\n\n  this.drawGraph_(); // This is used to determine whether to do various animations.\n\n  var end = new Date();\n  this.drawingTimeMs_ = end - start;\n};\n/**\n * Point structure.\n *\n * xval_* and yval_* are the original unscaled data values,\n * while x_* and y_* are scaled to the range (0.0-1.0) for plotting.\n * yval_stacked is the cumulative Y value used for stacking graphs,\n * and bottom/top/minus/plus are used for error bar graphs.\n *\n * @typedef {{\n *     idx: number,\n *     name: string,\n *     x: ?number,\n *     xval: ?number,\n *     y_bottom: ?number,\n *     y: ?number,\n *     y_stacked: ?number,\n *     y_top: ?number,\n *     yval_minus: ?number,\n *     yval: ?number,\n *     yval_plus: ?number,\n *     yval_stacked\n * }}\n */\n\n\nDygraph.PointType = undefined;\n/**\n * Calculates point stacking for stackedGraph=true.\n *\n * For stacking purposes, interpolate or extend neighboring data across\n * NaN values based on stackedGraphNaNFill settings. This is for display\n * only, the underlying data value as shown in the legend remains NaN.\n *\n * @param {Array.<Dygraph.PointType>} points Point array for a single series.\n *     Updates each Point's yval_stacked property.\n * @param {Array.<number>} cumulativeYval Accumulated top-of-graph stacked Y\n *     values for the series seen so far. Index is the row number. Updated\n *     based on the current series's values.\n * @param {Array.<number>} seriesExtremes Min and max values, updated\n *     to reflect the stacked values.\n * @param {string} fillMethod Interpolation method, one of 'all', 'inside', or\n *     'none'.\n * @private\n */\n\nDygraph.stackPoints_ = function (points, cumulativeYval, seriesExtremes, fillMethod) {\n  var lastXval = null;\n  var prevPoint = null;\n  var nextPoint = null;\n  var nextPointIdx = -1; // Find the next stackable point starting from the given index.\n\n  var updateNextPoint = function updateNextPoint(idx) {\n    // If we've previously found a non-NaN point and haven't gone past it yet,\n    // just use that.\n    if (nextPointIdx >= idx) return; // We haven't found a non-NaN point yet or have moved past it,\n    // look towards the right to find a non-NaN point.\n\n    for (var j = idx; j < points.length; ++j) {\n      // Clear out a previously-found point (if any) since it's no longer\n      // valid, we shouldn't use it for interpolation anymore.\n      nextPoint = null;\n\n      if (!isNaN(points[j].yval) && points[j].yval !== null) {\n        nextPointIdx = j;\n        nextPoint = points[j];\n        break;\n      }\n    }\n  };\n\n  for (var i = 0; i < points.length; ++i) {\n    var point = points[i];\n    var xval = point.xval;\n\n    if (cumulativeYval[xval] === undefined) {\n      cumulativeYval[xval] = 0;\n    }\n\n    var actualYval = point.yval;\n\n    if (isNaN(actualYval) || actualYval === null) {\n      if (fillMethod == 'none') {\n        actualYval = 0;\n      } else {\n        // Interpolate/extend for stacking purposes if possible.\n        updateNextPoint(i);\n\n        if (prevPoint && nextPoint && fillMethod != 'none') {\n          // Use linear interpolation between prevPoint and nextPoint.\n          actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) * ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n        } else if (prevPoint && fillMethod == 'all') {\n          actualYval = prevPoint.yval;\n        } else if (nextPoint && fillMethod == 'all') {\n          actualYval = nextPoint.yval;\n        } else {\n          actualYval = 0;\n        }\n      }\n    } else {\n      prevPoint = point;\n    }\n\n    var stackedYval = cumulativeYval[xval];\n\n    if (lastXval != xval) {\n      // If an x-value is repeated, we ignore the duplicates.\n      stackedYval += actualYval;\n      cumulativeYval[xval] = stackedYval;\n    }\n\n    lastXval = xval;\n    point.yval_stacked = stackedYval;\n\n    if (stackedYval > seriesExtremes[1]) {\n      seriesExtremes[1] = stackedYval;\n    }\n\n    if (stackedYval < seriesExtremes[0]) {\n      seriesExtremes[0] = stackedYval;\n    }\n  }\n};\n/**\n * Loop over all fields and create datasets, calculating extreme y-values for\n * each series and extreme x-indices as we go.\n *\n * dateWindow is passed in as an explicit parameter so that we can compute\n * extreme values \"speculatively\", i.e. without actually setting state on the\n * dygraph.\n *\n * @param {Array.<Array.<Array.<(number|Array<number>)>>} rolledSeries, where\n *     rolledSeries[seriesIndex][row] = raw point, where\n *     seriesIndex is the column number starting with 1, and\n *     rawPoint is [x,y] or [x, [y, err]] or [x, [y, yminus, yplus]].\n * @param {?Array.<number>} dateWindow [xmin, xmax] pair, or null.\n * @return {{\n *     points: Array.<Array.<Dygraph.PointType>>,\n *     seriesExtremes: Array.<Array.<number>>,\n *     boundaryIds: Array.<number>}}\n * @private\n */\n\n\nDygraph.prototype.gatherDatasets_ = function (rolledSeries, dateWindow) {\n  var boundaryIds = [];\n  var points = [];\n  var cumulativeYval = []; // For stacked series.\n\n  var extremes = {}; // series name -> [low, high]\n\n  var seriesIdx, sampleIdx;\n  var firstIdx, lastIdx;\n  var axisIdx; // Loop over the fields (series).  Go from the last to the first,\n  // because if they're stacked that's how we accumulate the values.\n\n  var num_series = rolledSeries.length - 1;\n  var series;\n\n  for (seriesIdx = num_series; seriesIdx >= 1; seriesIdx--) {\n    if (!this.visibility()[seriesIdx - 1]) continue; // Prune down to the desired range, if necessary (for zooming)\n    // Because there can be lines going to points outside of the visible area,\n    // we actually prune to visible points, plus one on either side.\n\n    if (dateWindow) {\n      series = rolledSeries[seriesIdx];\n      var low = dateWindow[0];\n      var high = dateWindow[1]; // TODO(danvk): do binary search instead of linear search.\n      // TODO(danvk): pass firstIdx and lastIdx directly to the renderer.\n\n      firstIdx = null;\n      lastIdx = null;\n\n      for (sampleIdx = 0; sampleIdx < series.length; sampleIdx++) {\n        if (series[sampleIdx][0] >= low && firstIdx === null) {\n          firstIdx = sampleIdx;\n        }\n\n        if (series[sampleIdx][0] <= high) {\n          lastIdx = sampleIdx;\n        }\n      }\n\n      if (firstIdx === null) firstIdx = 0;\n      var correctedFirstIdx = firstIdx;\n      var isInvalidValue = true;\n\n      while (isInvalidValue && correctedFirstIdx > 0) {\n        correctedFirstIdx--; // check if the y value is null.\n\n        isInvalidValue = series[correctedFirstIdx][1] === null;\n      }\n\n      if (lastIdx === null) lastIdx = series.length - 1;\n      var correctedLastIdx = lastIdx;\n      isInvalidValue = true;\n\n      while (isInvalidValue && correctedLastIdx < series.length - 1) {\n        correctedLastIdx++;\n        isInvalidValue = series[correctedLastIdx][1] === null;\n      }\n\n      if (correctedFirstIdx !== firstIdx) {\n        firstIdx = correctedFirstIdx;\n      }\n\n      if (correctedLastIdx !== lastIdx) {\n        lastIdx = correctedLastIdx;\n      }\n\n      boundaryIds[seriesIdx - 1] = [firstIdx, lastIdx]; // .slice's end is exclusive, we want to include lastIdx.\n\n      series = series.slice(firstIdx, lastIdx + 1);\n    } else {\n      series = rolledSeries[seriesIdx];\n      boundaryIds[seriesIdx - 1] = [0, series.length - 1];\n    }\n\n    var seriesName = this.attr_(\"labels\")[seriesIdx];\n    var seriesExtremes = this.dataHandler_.getExtremeYValues(series, dateWindow, this.getBooleanOption(\"stepPlot\", seriesName));\n    var seriesPoints = this.dataHandler_.seriesToPoints(series, seriesName, boundaryIds[seriesIdx - 1][0]);\n\n    if (this.getBooleanOption(\"stackedGraph\")) {\n      axisIdx = this.attributes_.axisForSeries(seriesName);\n\n      if (cumulativeYval[axisIdx] === undefined) {\n        cumulativeYval[axisIdx] = [];\n      }\n\n      Dygraph.stackPoints_(seriesPoints, cumulativeYval[axisIdx], seriesExtremes, this.getBooleanOption(\"stackedGraphNaNFill\"));\n    }\n\n    extremes[seriesName] = seriesExtremes;\n    points[seriesIdx] = seriesPoints;\n  }\n\n  return {\n    points: points,\n    extremes: extremes,\n    boundaryIds: boundaryIds\n  };\n};\n/**\n * Update the graph with new data. This method is called when the viewing area\n * has changed. If the underlying data or options have changed, predraw_ will\n * be called before drawGraph_ is called.\n *\n * @private\n */\n\n\nDygraph.prototype.drawGraph_ = function () {\n  var start = new Date(); // This is used to set the second parameter to drawCallback, below.\n\n  var is_initial_draw = this.is_initial_draw_;\n  this.is_initial_draw_ = false;\n  this.layout_.removeAllDatasets();\n  this.setColors_();\n  this.attrs_.pointSize = 0.5 * this.getNumericOption('highlightCircleSize');\n  var packed = this.gatherDatasets_(this.rolledSeries_, this.dateWindow_);\n  var points = packed.points;\n  var extremes = packed.extremes;\n  this.boundaryIds_ = packed.boundaryIds;\n  this.setIndexByName_ = {};\n  var labels = this.attr_(\"labels\");\n  var dataIdx = 0;\n\n  for (var i = 1; i < points.length; i++) {\n    if (!this.visibility()[i - 1]) continue;\n    this.layout_.addDataset(labels[i], points[i]);\n    this.datasetIndex_[i] = dataIdx++;\n  }\n\n  for (var i = 0; i < labels.length; i++) {\n    this.setIndexByName_[labels[i]] = i;\n  }\n\n  this.computeYAxisRanges_(extremes);\n  this.layout_.setYAxes(this.axes_);\n  this.addXTicks_(); // Tell PlotKit to use this new data and render itself\n\n  this.layout_.evaluate();\n  this.renderGraph_(is_initial_draw);\n\n  if (this.getStringOption(\"timingName\")) {\n    var end = new Date();\n    console.log(this.getStringOption(\"timingName\") + \" - drawGraph: \" + (end - start) + \"ms\");\n  }\n};\n/**\n * This does the work of drawing the chart. It assumes that the layout and axis\n * scales have already been set (e.g. by predraw_).\n *\n * @private\n */\n\n\nDygraph.prototype.renderGraph_ = function (is_initial_draw) {\n  this.cascadeEvents_('clearChart');\n  this.plotter_.clear();\n  var underlayCallback = this.getFunctionOption('underlayCallback');\n\n  if (underlayCallback) {\n    // NOTE: we pass the dygraph object to this callback twice to avoid breaking\n    // users who expect a deprecated form of this callback.\n    underlayCallback.call(this, this.hidden_ctx_, this.layout_.getPlotArea(), this, this);\n  }\n\n  var e = {\n    canvas: this.hidden_,\n    drawingContext: this.hidden_ctx_\n  };\n  this.cascadeEvents_('willDrawChart', e);\n  this.plotter_.render();\n  this.cascadeEvents_('didDrawChart', e);\n  this.lastRow_ = -1; // because plugins/legend.js clears the legend\n  // TODO(danvk): is this a performance bottleneck when panning?\n  // The interaction canvas should already be empty in that situation.\n\n  this.canvas_.getContext('2d').clearRect(0, 0, this.width_, this.height_);\n  var drawCallback = this.getFunctionOption(\"drawCallback\");\n\n  if (drawCallback !== null) {\n    drawCallback.call(this, this, is_initial_draw);\n  }\n\n  if (is_initial_draw) {\n    this.readyFired_ = true;\n\n    while (this.readyFns_.length > 0) {\n      var fn = this.readyFns_.pop();\n      fn(this);\n    }\n  }\n};\n/**\n * @private\n * Determine properties of the y-axes which are independent of the data\n * currently being displayed. This includes things like the number of axes and\n * the style of the axes. It does not include the range of each axis and its\n * tick marks.\n * This fills in this.axes_.\n * axes_ = [ { options } ]\n *   indices are into the axes_ array.\n */\n\n\nDygraph.prototype.computeYAxes_ = function () {\n  var axis, index, opts, v; // this.axes_ doesn't match this.attributes_.axes_.options. It's used for\n  // data computation as well as options storage.\n  // Go through once and add all the axes.\n\n  this.axes_ = [];\n\n  for (axis = 0; axis < this.attributes_.numAxes(); axis++) {\n    // Add a new axis, making a copy of its per-axis options.\n    opts = {\n      g: this\n    };\n    utils.update(opts, this.attributes_.axisOptions(axis));\n    this.axes_[axis] = opts;\n  }\n\n  for (axis = 0; axis < this.axes_.length; axis++) {\n    if (axis === 0) {\n      opts = this.optionsViewForAxis_('y' + (axis ? '2' : ''));\n      v = opts(\"valueRange\");\n      if (v) this.axes_[axis].valueRange = v;\n    } else {\n      // To keep old behavior\n      var axes = this.user_attrs_.axes;\n\n      if (axes && axes.y2) {\n        v = axes.y2.valueRange;\n        if (v) this.axes_[axis].valueRange = v;\n      }\n    }\n  }\n};\n/**\n * Returns the number of y-axes on the chart.\n * @return {number} the number of axes.\n */\n\n\nDygraph.prototype.numAxes = function () {\n  return this.attributes_.numAxes();\n};\n/**\n * @private\n * Returns axis properties for the given series.\n * @param {string} setName The name of the series for which to get axis\n * properties, e.g. 'Y1'.\n * @return {Object} The axis properties.\n */\n\n\nDygraph.prototype.axisPropertiesForSeries = function (series) {\n  // TODO(danvk): handle errors.\n  return this.axes_[this.attributes_.axisForSeries(series)];\n};\n/**\n * @private\n * Determine the value range and tick marks for each axis.\n * @param {Object} extremes A mapping from seriesName -> [low, high]\n * This fills in the valueRange and ticks fields in each entry of this.axes_.\n */\n\n\nDygraph.prototype.computeYAxisRanges_ = function (extremes) {\n  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(num) {\n    return isNaN(parseFloat(num));\n  };\n\n  var numAxes = this.attributes_.numAxes();\n  var ypadCompat, span, series, ypad;\n  var p_axis; // Compute extreme values, a span and tick marks for each axis.\n\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n    var logscale = this.attributes_.getForAxis(\"logscale\", i);\n    var includeZero = this.attributes_.getForAxis(\"includeZero\", i);\n    var independentTicks = this.attributes_.getForAxis(\"independentTicks\", i);\n    series = this.attributes_.seriesForAxis(i); // Add some padding. This supports two Y padding operation modes:\n    //\n    // - backwards compatible (yRangePad not set):\n    //   10% padding for automatic Y ranges, but not for user-supplied\n    //   ranges, and move a close-to-zero edge to zero, since drawing at the edge\n    //   results in invisible lines. Unfortunately lines drawn at the edge of a\n    //   user-supplied range will still be invisible. If logscale is\n    //   set, add a variable amount of padding at the top but\n    //   none at the bottom.\n    //\n    // - new-style (yRangePad set by the user):\n    //   always add the specified Y padding.\n    //\n\n    ypadCompat = true;\n    ypad = 0.1; // add 10%\n\n    var yRangePad = this.getNumericOption('yRangePad');\n\n    if (yRangePad !== null) {\n      ypadCompat = false; // Convert pixel padding to ratio\n\n      ypad = yRangePad / this.plotter_.area.h;\n    }\n\n    if (series.length === 0) {\n      // If no series are defined or visible then use a reasonable default\n      axis.extremeRange = [0, 1];\n    } else {\n      // Calculate the extremes of extremes.\n      var minY = Infinity; // extremes[series[0]][0];\n\n      var maxY = -Infinity; // extremes[series[0]][1];\n\n      var extremeMinY, extremeMaxY;\n\n      for (var j = 0; j < series.length; j++) {\n        // this skips invisible series\n        if (!extremes.hasOwnProperty(series[j])) continue; // Only use valid extremes to stop null data series' from corrupting the scale.\n\n        extremeMinY = extremes[series[j]][0];\n\n        if (extremeMinY !== null) {\n          minY = Math.min(extremeMinY, minY);\n        }\n\n        extremeMaxY = extremes[series[j]][1];\n\n        if (extremeMaxY !== null) {\n          maxY = Math.max(extremeMaxY, maxY);\n        }\n      } // Include zero if requested by the user.\n\n\n      if (includeZero && !logscale) {\n        if (minY > 0) minY = 0;\n        if (maxY < 0) maxY = 0;\n      } // Ensure we have a valid scale, otherwise default to [0, 1] for safety.\n\n\n      if (minY == Infinity) minY = 0;\n      if (maxY == -Infinity) maxY = 1;\n      span = maxY - minY; // special case: if we have no sense of scale, center on the sole value.\n\n      if (span === 0) {\n        if (maxY !== 0) {\n          span = Math.abs(maxY);\n        } else {\n          // ... and if the sole value is zero, use range 0-1.\n          maxY = 1;\n          span = 1;\n        }\n      }\n\n      var maxAxisY = maxY,\n          minAxisY = minY;\n\n      if (ypadCompat) {\n        if (logscale) {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY;\n        } else {\n          maxAxisY = maxY + ypad * span;\n          minAxisY = minY - ypad * span; // Backwards-compatible behavior: Move the span to start or end at zero if it's\n          // close to zero.\n\n          if (minAxisY < 0 && minY >= 0) minAxisY = 0;\n          if (maxAxisY > 0 && maxY <= 0) maxAxisY = 0;\n        }\n      }\n\n      axis.extremeRange = [minAxisY, maxAxisY];\n    }\n\n    if (axis.valueRange) {\n      // This is a user-set value range for this axis.\n      var y0 = isNullUndefinedOrNaN(axis.valueRange[0]) ? axis.extremeRange[0] : axis.valueRange[0];\n      var y1 = isNullUndefinedOrNaN(axis.valueRange[1]) ? axis.extremeRange[1] : axis.valueRange[1];\n      axis.computedValueRange = [y0, y1];\n    } else {\n      axis.computedValueRange = axis.extremeRange;\n    }\n\n    if (!ypadCompat) {\n      // When using yRangePad, adjust the upper/lower bounds to add\n      // padding unless the user has zoomed/panned the Y axis range.\n      if (logscale) {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        var y0pct = ypad / (2 * ypad - 1);\n        var y1pct = (ypad - 1) / (2 * ypad - 1);\n        axis.computedValueRange[0] = utils.logRangeFraction(y0, y1, y0pct);\n        axis.computedValueRange[1] = utils.logRangeFraction(y0, y1, y1pct);\n      } else {\n        y0 = axis.computedValueRange[0];\n        y1 = axis.computedValueRange[1];\n        span = y1 - y0;\n        axis.computedValueRange[0] = y0 - span * ypad;\n        axis.computedValueRange[1] = y1 + span * ypad;\n      }\n    }\n\n    if (independentTicks) {\n      axis.independentTicks = independentTicks;\n      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));\n      var ticker = opts('ticker');\n      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this); // Define the first independent axis as primary axis.\n\n      if (!p_axis) p_axis = axis;\n    }\n  }\n\n  if (p_axis === undefined) {\n    throw \"Configuration Error: At least one axis has to have the \\\"independentTicks\\\" option activated.\";\n  } // Add ticks. By default, all axes inherit the tick positions of the\n  // primary axis. However, if an axis is specifically marked as having\n  // independent ticks, then that is permissible as well.\n\n\n  for (var i = 0; i < numAxes; i++) {\n    var axis = this.axes_[i];\n\n    if (!axis.independentTicks) {\n      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));\n      var ticker = opts('ticker');\n      var p_ticks = p_axis.ticks;\n      var p_scale = p_axis.computedValueRange[1] - p_axis.computedValueRange[0];\n      var scale = axis.computedValueRange[1] - axis.computedValueRange[0];\n      var tick_values = [];\n\n      for (var k = 0; k < p_ticks.length; k++) {\n        var y_frac = (p_ticks[k].v - p_axis.computedValueRange[0]) / p_scale;\n        var y_val = axis.computedValueRange[0] + y_frac * scale;\n        tick_values.push(y_val);\n      }\n\n      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this, tick_values);\n    }\n  }\n};\n/**\n * Detects the type of the str (date or numeric) and sets the various\n * formatting attributes in this.attrs_ based on this type.\n * @param {string} str An x value.\n * @private\n */\n\n\nDygraph.prototype.detectTypeFromString_ = function (str) {\n  var isDate = false;\n  var dashPos = str.indexOf('-'); // could be 2006-01-01 _or_ 1.0e-2\n\n  if (dashPos > 0 && str[dashPos - 1] != 'e' && str[dashPos - 1] != 'E' || str.indexOf('/') >= 0 || isNaN(parseFloat(str))) {\n    isDate = true;\n  } else if (str.length == 8 && str > '19700101' && str < '20371231') {\n    // TODO(danvk): remove support for this format.\n    isDate = true;\n  }\n\n  this.setXAxisOptions_(isDate);\n};\n\nDygraph.prototype.setXAxisOptions_ = function (isDate) {\n  if (isDate) {\n    this.attrs_.xValueParser = utils.dateParser;\n    this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;\n    this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;\n    this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;\n  } else {\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.xValueParser = function (x) {\n      return parseFloat(x);\n    }; // TODO(danvk): use Dygraph.numberValueFormatter here?\n\n    /** @private (shut up, jsdoc!) */\n\n\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n\n    this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  }\n};\n/**\n * @private\n * Parses a string in a special csv format.  We expect a csv file where each\n * line is a date point, and the first field in each line is the date string.\n * We also expect that all remaining fields represent series.\n * if the errorBars attribute is set, then interpret the fields as:\n * date, series1, stddev1, series2, stddev2, ...\n * @param {[Object]} data See above.\n *\n * @return [Object] An array with one entry for each row. These entries\n * are an array of cells in that row. The first entry is the parsed x-value for\n * the row. The second, third, etc. are the y-values. These can take on one of\n * three forms, depending on the CSV and constructor parameters:\n * 1. numeric value\n * 2. [ value, stddev ]\n * 3. [ low value, center value, high value ]\n */\n\n\nDygraph.prototype.parseCSV_ = function (data) {\n  var ret = [];\n  var line_delimiter = utils.detectLineDelimiter(data);\n  var lines = data.split(line_delimiter || \"\\n\");\n  var vals, j; // Use the default delimiter or fall back to a tab if that makes sense.\n\n  var delim = this.getStringOption('delimiter');\n\n  if (lines[0].indexOf(delim) == -1 && lines[0].indexOf('\\t') >= 0) {\n    delim = '\\t';\n  }\n\n  var start = 0;\n\n  if (!('labels' in this.user_attrs_)) {\n    // User hasn't explicitly set labels, so they're (presumably) in the CSV.\n    start = 1;\n    this.attrs_.labels = lines[0].split(delim); // NOTE: _not_ user_attrs_.\n\n    this.attributes_.reparseSeries();\n  }\n\n  var line_no = 0;\n  var xParser;\n  var defaultParserSet = false; // attempt to auto-detect x value type\n\n  var expectedCols = this.attr_(\"labels\").length;\n  var outOfOrder = false;\n\n  for (var i = start; i < lines.length; i++) {\n    var line = lines[i];\n    line_no = i;\n    if (line.length === 0) continue; // skip blank lines\n\n    if (line[0] == '#') continue; // skip comment lines\n\n    var inFields = line.split(delim);\n    if (inFields.length < 2) continue;\n    var fields = [];\n\n    if (!defaultParserSet) {\n      this.detectTypeFromString_(inFields[0]);\n      xParser = this.getFunctionOption(\"xValueParser\");\n      defaultParserSet = true;\n    }\n\n    fields[0] = xParser(inFields[0], this); // If fractions are expected, parse the numbers as \"A/B\"\n\n    if (this.fractions_) {\n      for (j = 1; j < inFields.length; j++) {\n        // TODO(danvk): figure out an appropriate way to flag parse errors.\n        vals = inFields[j].split(\"/\");\n\n        if (vals.length != 2) {\n          console.error('Expected fractional \"num/den\" values in CSV data ' + \"but found a value '\" + inFields[j] + \"' on line \" + (1 + i) + \" ('\" + line + \"') which is not of this form.\");\n          fields[j] = [0, 0];\n        } else {\n          fields[j] = [utils.parseFloat_(vals[0], i, line), utils.parseFloat_(vals[1], i, line)];\n        }\n      }\n    } else if (this.getBooleanOption(\"errorBars\")) {\n      // If there are error bars, values are (value, stddev) pairs\n      if (inFields.length % 2 != 1) {\n        console.error('Expected alternating (value, stdev.) pairs in CSV data ' + 'but line ' + (1 + i) + ' has an odd number of values (' + (inFields.length - 1) + \"): '\" + line + \"'\");\n      }\n\n      for (j = 1; j < inFields.length; j += 2) {\n        fields[(j + 1) / 2] = [utils.parseFloat_(inFields[j], i, line), utils.parseFloat_(inFields[j + 1], i, line)];\n      }\n    } else if (this.getBooleanOption(\"customBars\")) {\n      // Bars are a low;center;high tuple\n      for (j = 1; j < inFields.length; j++) {\n        var val = inFields[j];\n\n        if (/^ *$/.test(val)) {\n          fields[j] = [null, null, null];\n        } else {\n          vals = val.split(\";\");\n\n          if (vals.length == 3) {\n            fields[j] = [utils.parseFloat_(vals[0], i, line), utils.parseFloat_(vals[1], i, line), utils.parseFloat_(vals[2], i, line)];\n          } else {\n            console.warn('When using customBars, values must be either blank ' + 'or \"low;center;high\" tuples (got \"' + val + '\" on line ' + (1 + i));\n          }\n        }\n      }\n    } else {\n      // Values are just numbers\n      for (j = 1; j < inFields.length; j++) {\n        fields[j] = utils.parseFloat_(inFields[j], i, line);\n      }\n    }\n\n    if (ret.length > 0 && fields[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n\n    if (fields.length != expectedCols) {\n      console.error(\"Number of columns in line \" + i + \" (\" + fields.length + \") does not agree with number of labels (\" + expectedCols + \") \" + line);\n    } // If the user specified the 'labels' option and none of the cells of the\n    // first row parsed correctly, then they probably double-specified the\n    // labels. We go with the values set in the option, discard this row and\n    // log a warning to the JS console.\n\n\n    if (i === 0 && this.attr_('labels')) {\n      var all_null = true;\n\n      for (j = 0; all_null && j < fields.length; j++) {\n        if (fields[j]) all_null = false;\n      }\n\n      if (all_null) {\n        console.warn(\"The dygraphs 'labels' option is set, but the first row \" + \"of CSV data ('\" + line + \"') appears to also contain \" + \"labels. Will drop the CSV labels and use the option \" + \"labels.\");\n        continue;\n      }\n    }\n\n    ret.push(fields);\n  }\n\n  if (outOfOrder) {\n    console.warn(\"CSV is out of order; order it correctly to speed loading.\");\n    ret.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n  }\n\n  return ret;\n}; // In native format, all values must be dates or numbers.\n// This check isn't perfect but will catch most mistaken uses of strings.\n\n\nfunction validateNativeFormat(data) {\n  var firstRow = data[0];\n  var firstX = firstRow[0];\n\n  if (typeof firstX !== 'number' && !utils.isDateLike(firstX)) {\n    throw new Error('Expected number or date but got ' + typeof firstX + ': ' + firstX + '.');\n  }\n\n  for (var i = 1; i < firstRow.length; i++) {\n    var val = firstRow[i];\n    if (val === null || val === undefined) continue;\n    if (typeof val === 'number') continue;\n    if (utils.isArrayLike(val)) continue; // e.g. error bars or custom bars.\n\n    throw new Error('Expected number or array but got ' + typeof val + ': ' + val + '.');\n  }\n}\n/**\n * The user has provided their data as a pre-packaged JS array. If the x values\n * are numeric, this is the same as dygraphs' internal format. If the x values\n * are dates, we need to convert them from Date objects to ms since epoch.\n * @param {!Array} data\n * @return {Object} data with numeric x values.\n * @private\n */\n\n\nDygraph.prototype.parseArray_ = function (data) {\n  // Peek at the first x value to see if it's numeric.\n  if (data.length === 0) {\n    console.error(\"Can't plot empty data set\");\n    return null;\n  }\n\n  if (data[0].length === 0) {\n    console.error(\"Data set cannot contain an empty row\");\n    return null;\n  }\n\n  validateNativeFormat(data);\n  var i;\n\n  if (this.attr_(\"labels\") === null) {\n    console.warn(\"Using default labels. Set labels explicitly via 'labels' \" + \"in the options parameter\");\n    this.attrs_.labels = [\"X\"];\n\n    for (i = 1; i < data[0].length; i++) {\n      this.attrs_.labels.push(\"Y\" + i); // Not user_attrs_.\n    }\n\n    this.attributes_.reparseSeries();\n  } else {\n    var num_labels = this.attr_(\"labels\");\n\n    if (num_labels.length != data[0].length) {\n      console.error(\"Mismatch between number of labels (\" + num_labels + \")\" + \" and number of columns in array (\" + data[0].length + \")\");\n      return null;\n    }\n  }\n\n  if (utils.isDateLike(data[0][0])) {\n    // Some intelligent defaults for a date x-axis.\n    this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;\n    this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;\n    this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter; // Assume they're all dates.\n\n    var parsedData = utils.clone(data);\n\n    for (i = 0; i < data.length; i++) {\n      if (parsedData[i].length === 0) {\n        console.error(\"Row \" + (1 + i) + \" of data is empty\");\n        return null;\n      }\n\n      if (parsedData[i][0] === null || typeof parsedData[i][0].getTime != 'function' || isNaN(parsedData[i][0].getTime())) {\n        console.error(\"x value in row \" + (1 + i) + \" is not a Date\");\n        return null;\n      }\n\n      parsedData[i][0] = parsedData[i][0].getTime();\n    }\n\n    return parsedData;\n  } else {\n    // Some intelligent defaults for a numeric x-axis.\n\n    /** @private (shut up, jsdoc!) */\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n\n    this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;\n    this.attrs_.axes.x.axisLabelFormatter = utils.numberAxisLabelFormatter;\n    return data;\n  }\n};\n/**\n * Parses a DataTable object from gviz.\n * The data is expected to have a first column that is either a date or a\n * number. All subsequent columns must be numbers. If there is a clear mismatch\n * between this.xValueParser_ and the type of the first column, it will be\n * fixed. Fills out rawData_.\n * @param {!google.visualization.DataTable} data See above.\n * @private\n */\n\n\nDygraph.prototype.parseDataTable_ = function (data) {\n  var shortTextForAnnotationNum = function shortTextForAnnotationNum(num) {\n    // converts [0-9]+ [A-Z][a-z]*\n    // example: 0=A, 1=B, 25=Z, 26=Aa, 27=Ab\n    // and continues like.. Ba Bb .. Za .. Zz..Aaa...Zzz Aaaa Zzzz\n    var shortText = String.fromCharCode(65\n    /* A */\n    + num % 26);\n    num = Math.floor(num / 26);\n\n    while (num > 0) {\n      shortText = String.fromCharCode(65\n      /* A */\n      + (num - 1) % 26) + shortText.toLowerCase();\n      num = Math.floor((num - 1) / 26);\n    }\n\n    return shortText;\n  };\n\n  var cols = data.getNumberOfColumns();\n  var rows = data.getNumberOfRows();\n  var indepType = data.getColumnType(0);\n\n  if (indepType == 'date' || indepType == 'datetime') {\n    this.attrs_.xValueParser = utils.dateParser;\n    this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;\n    this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;\n    this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;\n  } else if (indepType == 'number') {\n    this.attrs_.xValueParser = function (x) {\n      return parseFloat(x);\n    };\n\n    this.attrs_.axes.x.valueFormatter = function (x) {\n      return x;\n    };\n\n    this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;\n    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;\n  } else {\n    throw new Error(\"only 'date', 'datetime' and 'number' types are supported \" + \"for column 1 of DataTable input (Got '\" + indepType + \"')\");\n  } // Array of the column indices which contain data (and not annotations).\n\n\n  var colIdx = [];\n  var annotationCols = {}; // data index -> [annotation cols]\n\n  var hasAnnotations = false;\n  var i, j;\n\n  for (i = 1; i < cols; i++) {\n    var type = data.getColumnType(i);\n\n    if (type == 'number') {\n      colIdx.push(i);\n    } else if (type == 'string' && this.getBooleanOption('displayAnnotations')) {\n      // This is OK -- it's an annotation column.\n      var dataIdx = colIdx[colIdx.length - 1];\n\n      if (!annotationCols.hasOwnProperty(dataIdx)) {\n        annotationCols[dataIdx] = [i];\n      } else {\n        annotationCols[dataIdx].push(i);\n      }\n\n      hasAnnotations = true;\n    } else {\n      throw new Error(\"Only 'number' is supported as a dependent type with Gviz.\" + \" 'string' is only supported if displayAnnotations is true\");\n    }\n  } // Read column labels\n  // TODO(danvk): add support back for errorBars\n\n\n  var labels = [data.getColumnLabel(0)];\n\n  for (i = 0; i < colIdx.length; i++) {\n    labels.push(data.getColumnLabel(colIdx[i]));\n    if (this.getBooleanOption(\"errorBars\")) i += 1;\n  }\n\n  this.attrs_.labels = labels;\n  cols = labels.length;\n  var ret = [];\n  var outOfOrder = false;\n  var annotations = [];\n\n  for (i = 0; i < rows; i++) {\n    var row = [];\n\n    if (typeof data.getValue(i, 0) === 'undefined' || data.getValue(i, 0) === null) {\n      console.warn(\"Ignoring row \" + i + \" of DataTable because of undefined or null first column.\");\n      continue;\n    }\n\n    if (indepType == 'date' || indepType == 'datetime') {\n      row.push(data.getValue(i, 0).getTime());\n    } else {\n      row.push(data.getValue(i, 0));\n    }\n\n    if (!this.getBooleanOption(\"errorBars\")) {\n      for (j = 0; j < colIdx.length; j++) {\n        var col = colIdx[j];\n        row.push(data.getValue(i, col));\n\n        if (hasAnnotations && annotationCols.hasOwnProperty(col) && data.getValue(i, annotationCols[col][0]) !== null) {\n          var ann = {};\n          ann.series = data.getColumnLabel(col);\n          ann.xval = row[0];\n          ann.shortText = shortTextForAnnotationNum(annotations.length);\n          ann.text = '';\n\n          for (var k = 0; k < annotationCols[col].length; k++) {\n            if (k) ann.text += \"\\n\";\n            ann.text += data.getValue(i, annotationCols[col][k]);\n          }\n\n          annotations.push(ann);\n        }\n      } // Strip out infinities, which give dygraphs problems later on.\n\n\n      for (j = 0; j < row.length; j++) {\n        if (!isFinite(row[j])) row[j] = null;\n      }\n    } else {\n      for (j = 0; j < cols - 1; j++) {\n        row.push([data.getValue(i, 1 + 2 * j), data.getValue(i, 2 + 2 * j)]);\n      }\n    }\n\n    if (ret.length > 0 && row[0] < ret[ret.length - 1][0]) {\n      outOfOrder = true;\n    }\n\n    ret.push(row);\n  }\n\n  if (outOfOrder) {\n    console.warn(\"DataTable is out of order; order it correctly to speed loading.\");\n    ret.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n  }\n\n  this.rawData_ = ret;\n\n  if (annotations.length > 0) {\n    this.setAnnotations(annotations, true);\n  }\n\n  this.attributes_.reparseSeries();\n};\n/**\n * Signals to plugins that the chart data has updated.\n * This happens after the data has updated but before the chart has redrawn.\n * @private\n */\n\n\nDygraph.prototype.cascadeDataDidUpdateEvent_ = function () {\n  // TODO(danvk): there are some issues checking xAxisRange() and using\n  // toDomCoords from handlers of this event. The visible range should be set\n  // when the chart is drawn, not derived from the data.\n  this.cascadeEvents_('dataDidUpdate', {});\n};\n/**\n * Get the CSV data. If it's in a function, call that function. If it's in a\n * file, do an XMLHttpRequest to get it.\n * @private\n */\n\n\nDygraph.prototype.start_ = function () {\n  var data = this.file_; // Functions can return references of all other types.\n\n  if (typeof data == 'function') {\n    data = data();\n  }\n\n  if (utils.isArrayLike(data)) {\n    this.rawData_ = this.parseArray_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if (typeof data == 'object' && typeof data.getColumnRange == 'function') {\n    // must be a DataTable from gviz.\n    this.parseDataTable_(data);\n    this.cascadeDataDidUpdateEvent_();\n    this.predraw_();\n  } else if (typeof data == 'string') {\n    // Heuristic: a newline means it's CSV data. Otherwise it's an URL.\n    var line_delimiter = utils.detectLineDelimiter(data);\n\n    if (line_delimiter) {\n      this.loadedEvent_(data);\n    } else {\n      // REMOVE_FOR_IE\n      var req;\n\n      if (window.XMLHttpRequest) {\n        // Firefox, Opera, IE7, and other browsers will use the native object\n        req = new XMLHttpRequest();\n      } else {\n        // IE 5 and 6 will use the ActiveX control\n        req = new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n\n      var caller = this;\n\n      req.onreadystatechange = function () {\n        if (req.readyState == 4) {\n          if (req.status === 200 || // Normal http\n          req.status === 0) {\n            // Chrome w/ --allow-file-access-from-files\n            caller.loadedEvent_(req.responseText);\n          }\n        }\n      };\n\n      req.open(\"GET\", data, true);\n      req.send(null);\n    }\n  } else {\n    console.error(\"Unknown data format: \" + typeof data);\n  }\n};\n/**\n * Changes various properties of the graph. These can include:\n * <ul>\n * <li>file: changes the source data for the graph</li>\n * <li>errorBars: changes whether the data contains stddev</li>\n * </ul>\n *\n * There's a huge variety of options that can be passed to this method. For a\n * full list, see http://dygraphs.com/options.html.\n *\n * @param {Object} input_attrs The new properties and values\n * @param {boolean} block_redraw Usually the chart is redrawn after every\n *     call to updateOptions(). If you know better, you can pass true to\n *     explicitly block the redraw. This can be useful for chaining\n *     updateOptions() calls, avoiding the occasional infinite loop and\n *     preventing redraws when it's not necessary (e.g. when updating a\n *     callback).\n */\n\n\nDygraph.prototype.updateOptions = function (input_attrs, block_redraw) {\n  if (typeof block_redraw == 'undefined') block_redraw = false; // copyUserAttrs_ drops the \"file\" parameter as a convenience to us.\n\n  var file = input_attrs.file;\n  var attrs = Dygraph.copyUserAttrs_(input_attrs); // TODO(danvk): this is a mess. Move these options into attr_.\n\n  if ('rollPeriod' in attrs) {\n    this.rollPeriod_ = attrs.rollPeriod;\n  }\n\n  if ('dateWindow' in attrs) {\n    this.dateWindow_ = attrs.dateWindow;\n  } // TODO(danvk): validate per-series options.\n  // Supported:\n  // strokeWidth\n  // pointSize\n  // drawPoints\n  // highlightCircleSize\n  // Check if this set options will require new points.\n\n\n  var requiresNewPoints = utils.isPixelChangingOptionList(this.attr_(\"labels\"), attrs);\n  utils.updateDeep(this.user_attrs_, attrs);\n  this.attributes_.reparseSeries();\n\n  if (file) {\n    // This event indicates that the data is about to change, but hasn't yet.\n    // TODO(danvk): support cancellation of the update via this event.\n    this.cascadeEvents_('dataWillUpdate', {});\n    this.file_ = file;\n    if (!block_redraw) this.start_();\n  } else {\n    if (!block_redraw) {\n      if (requiresNewPoints) {\n        this.predraw_();\n      } else {\n        this.renderGraph_(false);\n      }\n    }\n  }\n};\n/**\n * Make a copy of input attributes, removing file as a convenience.\n * @private\n */\n\n\nDygraph.copyUserAttrs_ = function (attrs) {\n  var my_attrs = {};\n\n  for (var k in attrs) {\n    if (!attrs.hasOwnProperty(k)) continue;\n    if (k == 'file') continue;\n    if (attrs.hasOwnProperty(k)) my_attrs[k] = attrs[k];\n  }\n\n  return my_attrs;\n};\n/**\n * Resizes the dygraph. If no parameters are specified, resizes to fill the\n * containing div (which has presumably changed size since the dygraph was\n * instantiated. If the width/height are specified, the div will be resized.\n *\n * This is far more efficient than destroying and re-instantiating a\n * Dygraph, since it doesn't have to reparse the underlying data.\n *\n * @param {number} width Width (in pixels)\n * @param {number} height Height (in pixels)\n */\n\n\nDygraph.prototype.resize = function (width, height) {\n  if (this.resize_lock) {\n    return;\n  }\n\n  this.resize_lock = true;\n\n  if (width === null != (height === null)) {\n    console.warn(\"Dygraph.resize() should be called with zero parameters or \" + \"two non-NULL parameters. Pretending it was zero.\");\n    width = height = null;\n  }\n\n  var old_width = this.width_;\n  var old_height = this.height_;\n\n  if (width) {\n    this.maindiv_.style.width = width + \"px\";\n    this.maindiv_.style.height = height + \"px\";\n    this.width_ = width;\n    this.height_ = height;\n  } else {\n    this.width_ = this.maindiv_.clientWidth;\n    this.height_ = this.maindiv_.clientHeight;\n  }\n\n  if (old_width != this.width_ || old_height != this.height_) {\n    // Resizing a canvas erases it, even when the size doesn't change, so\n    // any resize needs to be followed by a redraw.\n    this.resizeElements_();\n    this.predraw_();\n  }\n\n  this.resize_lock = false;\n};\n/**\n * Adjusts the number of points in the rolling average. Updates the graph to\n * reflect the new averaging period.\n * @param {number} length Number of points over which to average the data.\n */\n\n\nDygraph.prototype.adjustRoll = function (length) {\n  this.rollPeriod_ = length;\n  this.predraw_();\n};\n/**\n * Returns a boolean array of visibility statuses.\n */\n\n\nDygraph.prototype.visibility = function () {\n  // Do lazy-initialization, so that this happens after we know the number of\n  // data series.\n  if (!this.getOption(\"visibility\")) {\n    this.attrs_.visibility = [];\n  } // TODO(danvk): it looks like this could go into an infinite loop w/ user_attrs.\n\n\n  while (this.getOption(\"visibility\").length < this.numColumns() - 1) {\n    this.attrs_.visibility.push(true);\n  }\n\n  return this.getOption(\"visibility\");\n};\n/**\n * Changes the visibility of one or more series.\n *\n * @param {number|number[]|object} num the series index or an array of series indices\n *                                     or a boolean array of visibility states by index\n *                                     or an object mapping series numbers, as keys, to\n *                                     visibility state (boolean values)\n * @param {boolean} value the visibility state expressed as a boolean\n */\n\n\nDygraph.prototype.setVisibility = function (num, value) {\n  var x = this.visibility();\n  var numIsObject = false;\n\n  if (!Array.isArray(num)) {\n    if (num !== null && typeof num === 'object') {\n      numIsObject = true;\n    } else {\n      num = [num];\n    }\n  }\n\n  if (numIsObject) {\n    for (var i in num) {\n      if (num.hasOwnProperty(i)) {\n        if (i < 0 || i >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + i);\n        } else {\n          x[i] = num[i];\n        }\n      }\n    }\n  } else {\n    for (var i = 0; i < num.length; i++) {\n      if (typeof num[i] === 'boolean') {\n        if (i >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + i);\n        } else {\n          x[i] = num[i];\n        }\n      } else {\n        if (num[i] < 0 || num[i] >= x.length) {\n          console.warn(\"Invalid series number in setVisibility: \" + num[i]);\n        } else {\n          x[num[i]] = value;\n        }\n      }\n    }\n  }\n\n  this.predraw_();\n};\n/**\n * How large of an area will the dygraph render itself in?\n * This is used for testing.\n * @return A {width: w, height: h} object.\n * @private\n */\n\n\nDygraph.prototype.size = function () {\n  return {\n    width: this.width_,\n    height: this.height_\n  };\n};\n/**\n * Update the list of annotations and redraw the chart.\n * See dygraphs.com/annotations.html for more info on how to use annotations.\n * @param ann {Array} An array of annotation objects.\n * @param suppressDraw {Boolean} Set to \"true\" to block chart redraw (optional).\n */\n\n\nDygraph.prototype.setAnnotations = function (ann, suppressDraw) {\n  // Only add the annotation CSS rule once we know it will be used.\n  this.annotations_ = ann;\n\n  if (!this.layout_) {\n    console.warn(\"Tried to setAnnotations before dygraph was ready. \" + \"Try setting them in a ready() block. See \" + \"dygraphs.com/tests/annotation.html\");\n    return;\n  }\n\n  this.layout_.setAnnotations(this.annotations_);\n\n  if (!suppressDraw) {\n    this.predraw_();\n  }\n};\n/**\n * Return the list of annotations.\n */\n\n\nDygraph.prototype.annotations = function () {\n  return this.annotations_;\n};\n/**\n * Get the list of label names for this graph. The first column is the\n * x-axis, so the data series names start at index 1.\n *\n * Returns null when labels have not yet been defined.\n */\n\n\nDygraph.prototype.getLabels = function () {\n  var labels = this.attr_(\"labels\");\n  return labels ? labels.slice() : null;\n};\n/**\n * Get the index of a series (column) given its name. The first column is the\n * x-axis, so the data series start with index 1.\n */\n\n\nDygraph.prototype.indexFromSetName = function (name) {\n  return this.setIndexByName_[name];\n};\n/**\n * Find the row number corresponding to the given x-value.\n * Returns null if there is no such x-value in the data.\n * If there are multiple rows with the same x-value, this will return the\n * first one.\n * @param {number} xVal The x-value to look for (e.g. millis since epoch).\n * @return {?number} The row number, which you can pass to getValue(), or null.\n */\n\n\nDygraph.prototype.getRowForX = function (xVal) {\n  var low = 0,\n      high = this.numRows() - 1;\n\n  while (low <= high) {\n    var idx = high + low >> 1;\n    var x = this.getValue(idx, 0);\n\n    if (x < xVal) {\n      low = idx + 1;\n    } else if (x > xVal) {\n      high = idx - 1;\n    } else if (low != idx) {\n      // equal, but there may be an earlier match.\n      high = idx;\n    } else {\n      return idx;\n    }\n  }\n\n  return null;\n};\n/**\n * Trigger a callback when the dygraph has drawn itself and is ready to be\n * manipulated. This is primarily useful when dygraphs has to do an XHR for the\n * data (i.e. a URL is passed as the data source) and the chart is drawn\n * asynchronously. If the chart has already drawn, the callback will fire\n * immediately.\n *\n * This is a good place to call setAnnotation().\n *\n * @param {function(!Dygraph)} callback The callback to trigger when the chart\n *     is ready.\n */\n\n\nDygraph.prototype.ready = function (callback) {\n  if (this.is_initial_draw_) {\n    this.readyFns_.push(callback);\n  } else {\n    callback.call(this, this);\n  }\n};\n/**\n * Add an event handler. This event handler is kept until the graph is\n * destroyed with a call to graph.destroy().\n *\n * @param {!Node} elem The element to add the event to.\n * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.\n * @param {function(Event):(boolean|undefined)} fn The function to call\n *     on the event. The function takes one parameter: the event object.\n * @private\n */\n\n\nDygraph.prototype.addAndTrackEvent = function (elem, type, fn) {\n  utils.addEvent(elem, type, fn);\n  this.registeredEvents_.push({\n    elem: elem,\n    type: type,\n    fn: fn\n  });\n};\n\nDygraph.prototype.removeTrackedEvents_ = function () {\n  if (this.registeredEvents_) {\n    for (var idx = 0; idx < this.registeredEvents_.length; idx++) {\n      var reg = this.registeredEvents_[idx];\n      utils.removeEvent(reg.elem, reg.type, reg.fn);\n    }\n  }\n\n  this.registeredEvents_ = [];\n}; // Installed plugins, in order of precedence (most-general to most-specific).\n\n\nDygraph.PLUGINS = [_pluginsLegend2['default'], _pluginsAxes2['default'], _pluginsRangeSelector2['default'], // Has to be before ChartLabels so that its callbacks are called after ChartLabels' callbacks.\n_pluginsChartLabels2['default'], _pluginsAnnotations2['default'], _pluginsGrid2['default']]; // There are many symbols which have historically been available through the\n// Dygraph class. These are exported here for backwards compatibility.\n\nDygraph.GVizChart = _dygraphGviz2['default'];\nDygraph.DASHED_LINE = utils.DASHED_LINE;\nDygraph.DOT_DASH_LINE = utils.DOT_DASH_LINE;\nDygraph.dateAxisLabelFormatter = utils.dateAxisLabelFormatter;\nDygraph.toRGB_ = utils.toRGB_;\nDygraph.findPos = utils.findPos;\nDygraph.pageX = utils.pageX;\nDygraph.pageY = utils.pageY;\nDygraph.dateString_ = utils.dateString_;\nDygraph.defaultInteractionModel = _dygraphInteractionModel2['default'].defaultModel;\nDygraph.nonInteractiveModel = Dygraph.nonInteractiveModel_ = _dygraphInteractionModel2['default'].nonInteractiveModel_;\nDygraph.Circles = utils.Circles;\nDygraph.Plugins = {\n  Legend: _pluginsLegend2['default'],\n  Axes: _pluginsAxes2['default'],\n  Annotations: _pluginsAnnotations2['default'],\n  ChartLabels: _pluginsChartLabels2['default'],\n  Grid: _pluginsGrid2['default'],\n  RangeSelector: _pluginsRangeSelector2['default']\n};\nDygraph.DataHandlers = {\n  DefaultHandler: _datahandlerDefault2['default'],\n  BarsHandler: _datahandlerBars2['default'],\n  CustomBarsHandler: _datahandlerBarsCustom2['default'],\n  DefaultFractionHandler: _datahandlerDefaultFractions2['default'],\n  ErrorBarsHandler: _datahandlerBarsError2['default'],\n  FractionsBarsHandler: _datahandlerBarsFractions2['default']\n};\nDygraph.startPan = _dygraphInteractionModel2['default'].startPan;\nDygraph.startZoom = _dygraphInteractionModel2['default'].startZoom;\nDygraph.movePan = _dygraphInteractionModel2['default'].movePan;\nDygraph.moveZoom = _dygraphInteractionModel2['default'].moveZoom;\nDygraph.endPan = _dygraphInteractionModel2['default'].endPan;\nDygraph.endZoom = _dygraphInteractionModel2['default'].endZoom;\nDygraph.numericLinearTicks = DygraphTickers.numericLinearTicks;\nDygraph.numericTicks = DygraphTickers.numericTicks;\nDygraph.dateTicker = DygraphTickers.dateTicker;\nDygraph.Granularity = DygraphTickers.Granularity;\nDygraph.getDateAxis = DygraphTickers.getDateAxis;\nDygraph.floatFormat = utils.floatFormat;\nexports['default'] = Dygraph;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}