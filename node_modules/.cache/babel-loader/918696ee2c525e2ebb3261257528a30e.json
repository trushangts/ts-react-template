{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.toMarkdown = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) {\n      s(r[o]);\n    }\n\n    return s;\n  }({\n    1: [function (require, module, exports) {\n      /*\n       * to-markdown - an HTML to Markdown converter\n       *\n       * Copyright 2011+, Dom Christie\n       * Licenced under the MIT licence\n       *\n       */\n      'use strict';\n\n      var toMarkdown;\n      var converters;\n\n      var mdConverters = require('./lib/md-converters');\n\n      var gfmConverters = require('./lib/gfm-converters');\n\n      var HtmlParser = require('./lib/html-parser');\n\n      var collapse = require('collapse-whitespace');\n      /*\n       * Utilities\n       */\n\n\n      var blocks = ['address', 'article', 'aside', 'audio', 'blockquote', 'body', 'canvas', 'center', 'dd', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'html', 'isindex', 'li', 'main', 'menu', 'nav', 'noframes', 'noscript', 'ol', 'output', 'p', 'pre', 'section', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul'];\n\n      function isBlock(node) {\n        return blocks.indexOf(node.nodeName.toLowerCase()) !== -1;\n      }\n\n      var voids = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n\n      function isVoid(node) {\n        return voids.indexOf(node.nodeName.toLowerCase()) !== -1;\n      }\n\n      function htmlToDom(string) {\n        var tree = new HtmlParser().parseFromString(string, 'text/html');\n        collapse(tree.documentElement, isBlock);\n        return tree;\n      }\n      /*\n       * Flattens DOM tree into single array\n       */\n\n\n      function bfsOrder(node) {\n        var inqueue = [node];\n        var outqueue = [];\n        var elem;\n        var children;\n        var i;\n\n        while (inqueue.length > 0) {\n          elem = inqueue.shift();\n          outqueue.push(elem);\n          children = elem.childNodes;\n\n          for (i = 0; i < children.length; i++) {\n            if (children[i].nodeType === 1) inqueue.push(children[i]);\n          }\n        }\n\n        outqueue.shift();\n        return outqueue;\n      }\n      /*\n       * Contructs a Markdown string of replacement text for a given node\n       */\n\n\n      function getContent(node) {\n        var text = '';\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n          if (node.childNodes[i].nodeType === 1) {\n            text += node.childNodes[i]._replacement;\n          } else if (node.childNodes[i].nodeType === 3) {\n            text += node.childNodes[i].data;\n          } else continue;\n        }\n\n        return text;\n      }\n      /*\n       * Returns the HTML string of an element with its contents converted\n       */\n\n\n      function outer(node, content) {\n        return node.cloneNode(false).outerHTML.replace('><', '>' + content + '<');\n      }\n\n      function canConvert(node, filter) {\n        if (typeof filter === 'string') {\n          return filter === node.nodeName.toLowerCase();\n        }\n\n        if (Array.isArray(filter)) {\n          return filter.indexOf(node.nodeName.toLowerCase()) !== -1;\n        } else if (typeof filter === 'function') {\n          return filter.call(toMarkdown, node);\n        } else {\n          throw new TypeError('`filter` needs to be a string, array, or function');\n        }\n      }\n\n      function isFlankedByWhitespace(side, node) {\n        var sibling;\n        var regExp;\n        var isFlanked;\n\n        if (side === 'left') {\n          sibling = node.previousSibling;\n          regExp = / $/;\n        } else {\n          sibling = node.nextSibling;\n          regExp = /^ /;\n        }\n\n        if (sibling) {\n          if (sibling.nodeType === 3) {\n            isFlanked = regExp.test(sibling.nodeValue);\n          } else if (sibling.nodeType === 1 && !isBlock(sibling)) {\n            isFlanked = regExp.test(sibling.textContent);\n          }\n        }\n\n        return isFlanked;\n      }\n\n      function flankingWhitespace(node, content) {\n        var leading = '';\n        var trailing = '';\n\n        if (!isBlock(node)) {\n          var hasLeading = /^[ \\r\\n\\t]/.test(content);\n          var hasTrailing = /[ \\r\\n\\t]$/.test(content);\n\n          if (hasLeading && !isFlankedByWhitespace('left', node)) {\n            leading = ' ';\n          }\n\n          if (hasTrailing && !isFlankedByWhitespace('right', node)) {\n            trailing = ' ';\n          }\n        }\n\n        return {\n          leading: leading,\n          trailing: trailing\n        };\n      }\n      /*\n       * Finds a Markdown converter, gets the replacement, and sets it on\n       * `_replacement`\n       */\n\n\n      function process(node) {\n        var replacement;\n        var content = getContent(node); // Remove blank nodes\n\n        if (!isVoid(node) && !/A|TH|TD/.test(node.nodeName) && /^\\s*$/i.test(content)) {\n          node._replacement = '';\n          return;\n        }\n\n        for (var i = 0; i < converters.length; i++) {\n          var converter = converters[i];\n\n          if (canConvert(node, converter.filter)) {\n            if (typeof converter.replacement !== 'function') {\n              throw new TypeError('`replacement` needs to be a function that returns a string');\n            }\n\n            var whitespace = flankingWhitespace(node, content);\n\n            if (whitespace.leading || whitespace.trailing) {\n              content = content.trim();\n            }\n\n            replacement = whitespace.leading + converter.replacement.call(toMarkdown, content, node) + whitespace.trailing;\n            break;\n          }\n        }\n\n        node._replacement = replacement;\n      }\n\n      toMarkdown = function toMarkdown(input, options) {\n        options = options || {};\n\n        if (typeof input !== 'string') {\n          throw new TypeError(input + ' is not a string');\n        }\n\n        if (input === '') {\n          return '';\n        } // Escape potential ol triggers\n\n\n        input = input.replace(/(\\d+)\\. /g, '$1\\\\. ');\n        var clone = htmlToDom(input).body;\n        var nodes = bfsOrder(clone);\n        var output;\n        converters = mdConverters.slice(0);\n\n        if (options.gfm) {\n          converters = gfmConverters.concat(converters);\n        }\n\n        if (options.converters) {\n          converters = options.converters.concat(converters);\n        } // Process through nodes in reverse (so deepest child elements are first).\n\n\n        for (var i = nodes.length - 1; i >= 0; i--) {\n          process(nodes[i]);\n        }\n\n        output = getContent(clone);\n        return output.replace(/^[\\t\\r\\n]+|[\\t\\r\\n\\s]+$/g, '').replace(/\\n\\s+\\n/g, '\\n\\n').replace(/\\n{3,}/g, '\\n\\n');\n      };\n\n      toMarkdown.isBlock = isBlock;\n      toMarkdown.isVoid = isVoid;\n      toMarkdown.outer = outer;\n      module.exports = toMarkdown;\n    }, {\n      \"./lib/gfm-converters\": 2,\n      \"./lib/html-parser\": 3,\n      \"./lib/md-converters\": 4,\n      \"collapse-whitespace\": 7\n    }],\n    2: [function (require, module, exports) {\n      'use strict';\n\n      function cell(content, node) {\n        var index = Array.prototype.indexOf.call(node.parentNode.childNodes, node);\n        var prefix = ' ';\n        if (index === 0) prefix = '| ';\n        return prefix + content + ' |';\n      }\n\n      var highlightRegEx = /highlight highlight-(\\S+)/;\n      module.exports = [{\n        filter: 'br',\n        replacement: function replacement() {\n          return '\\n';\n        }\n      }, {\n        filter: ['del', 's', 'strike'],\n        replacement: function replacement(content) {\n          return '~~' + content + '~~';\n        }\n      }, {\n        filter: function filter(node) {\n          return node.type === 'checkbox' && node.parentNode.nodeName === 'LI';\n        },\n        replacement: function replacement(content, node) {\n          return (node.checked ? '[x]' : '[ ]') + ' ';\n        }\n      }, {\n        filter: ['th', 'td'],\n        replacement: function replacement(content, node) {\n          return cell(content, node);\n        }\n      }, {\n        filter: 'tr',\n        replacement: function replacement(content, node) {\n          var borderCells = '';\n          var alignMap = {\n            left: ':--',\n            right: '--:',\n            center: ':-:'\n          };\n\n          if (node.parentNode.nodeName === 'THEAD') {\n            for (var i = 0; i < node.childNodes.length; i++) {\n              var align = node.childNodes[i].attributes.align;\n              var border = '---';\n              if (align) border = alignMap[align.value] || border;\n              borderCells += cell(border, node.childNodes[i]);\n            }\n          }\n\n          return '\\n' + content + (borderCells ? '\\n' + borderCells : '');\n        }\n      }, {\n        filter: 'table',\n        replacement: function replacement(content) {\n          return '\\n\\n' + content + '\\n\\n';\n        }\n      }, {\n        filter: ['thead', 'tbody', 'tfoot'],\n        replacement: function replacement(content) {\n          return content;\n        }\n      }, // Fenced code blocks\n      {\n        filter: function filter(node) {\n          return node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';\n        },\n        replacement: function replacement(content, node) {\n          return '\\n\\n```\\n' + node.firstChild.textContent + '\\n```\\n\\n';\n        }\n      }, // Syntax-highlighted code blocks\n      {\n        filter: function filter(node) {\n          return node.nodeName === 'PRE' && node.parentNode.nodeName === 'DIV' && highlightRegEx.test(node.parentNode.className);\n        },\n        replacement: function replacement(content, node) {\n          var language = node.parentNode.className.match(highlightRegEx)[1];\n          return '\\n\\n```' + language + '\\n' + node.textContent + '\\n```\\n\\n';\n        }\n      }, {\n        filter: function filter(node) {\n          return node.nodeName === 'DIV' && highlightRegEx.test(node.className);\n        },\n        replacement: function replacement(content) {\n          return '\\n\\n' + content + '\\n\\n';\n        }\n      }];\n    }, {}],\n    3: [function (require, module, exports) {\n      /*\n       * Set up window for Node.js\n       */\n      var _window = typeof window !== 'undefined' ? window : this;\n      /*\n       * Parsing HTML strings\n       */\n\n\n      function canParseHtmlNatively() {\n        var Parser = _window.DOMParser;\n        var canParse = false; // Adapted from https://gist.github.com/1129031\n        // Firefox/Opera/IE throw errors on unsupported types\n\n        try {\n          // WebKit returns null on unsupported types\n          if (new Parser().parseFromString('', 'text/html')) {\n            canParse = true;\n          }\n        } catch (e) {}\n\n        return canParse;\n      }\n\n      function createHtmlParser() {\n        var Parser = function Parser() {}; // For Node.js environments\n\n\n        if (typeof document === 'undefined') {\n          var jsdom = require('jsdom');\n\n          Parser.prototype.parseFromString = function (string) {\n            return jsdom.jsdom(string, {\n              features: {\n                FetchExternalResources: [],\n                ProcessExternalResources: false\n              }\n            });\n          };\n        } else {\n          if (!shouldUseActiveX()) {\n            Parser.prototype.parseFromString = function (string) {\n              var doc = document.implementation.createHTMLDocument('');\n              doc.open();\n              doc.write(string);\n              doc.close();\n              return doc;\n            };\n          } else {\n            Parser.prototype.parseFromString = function (string) {\n              var doc = new window.ActiveXObject('htmlfile');\n              doc.designMode = 'on'; // disable on-page scripts\n\n              doc.open();\n              doc.write(string);\n              doc.close();\n              return doc;\n            };\n          }\n        }\n\n        return Parser;\n      }\n\n      function shouldUseActiveX() {\n        var useActiveX = false;\n\n        try {\n          document.implementation.createHTMLDocument('').open();\n        } catch (e) {\n          if (window.ActiveXObject) useActiveX = true;\n        }\n\n        return useActiveX;\n      }\n\n      module.exports = canParseHtmlNatively() ? _window.DOMParser : createHtmlParser();\n    }, {\n      \"jsdom\": 6\n    }],\n    4: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = [{\n        filter: 'p',\n        replacement: function replacement(content) {\n          return '\\n\\n' + content + '\\n\\n';\n        }\n      }, {\n        filter: 'br',\n        replacement: function replacement() {\n          return '  \\n';\n        }\n      }, {\n        filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n        replacement: function replacement(content, node) {\n          var hLevel = node.nodeName.charAt(1);\n          var hPrefix = '';\n\n          for (var i = 0; i < hLevel; i++) {\n            hPrefix += '#';\n          }\n\n          return '\\n\\n' + hPrefix + ' ' + content + '\\n\\n';\n        }\n      }, {\n        filter: 'hr',\n        replacement: function replacement() {\n          return '\\n\\n* * *\\n\\n';\n        }\n      }, {\n        filter: ['em', 'i'],\n        replacement: function replacement(content) {\n          return '_' + content + '_';\n        }\n      }, {\n        filter: ['strong', 'b'],\n        replacement: function replacement(content) {\n          return '**' + content + '**';\n        }\n      }, // Inline code\n      {\n        filter: function filter(node) {\n          var hasSiblings = node.previousSibling || node.nextSibling;\n          var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;\n          return node.nodeName === 'CODE' && !isCodeBlock;\n        },\n        replacement: function replacement(content) {\n          return '`' + content + '`';\n        }\n      }, {\n        filter: function filter(node) {\n          return node.nodeName === 'A' && node.getAttribute('href');\n        },\n        replacement: function replacement(content, node) {\n          var titlePart = node.title ? ' \"' + node.title + '\"' : '';\n          return '[' + content + '](' + node.getAttribute('href') + titlePart + ')';\n        }\n      }, {\n        filter: 'img',\n        replacement: function replacement(content, node) {\n          var alt = node.alt || '';\n          var src = node.getAttribute('src') || '';\n          var title = node.title || '';\n          var titlePart = title ? ' \"' + title + '\"' : '';\n          return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : '';\n        }\n      }, // Code blocks\n      {\n        filter: function filter(node) {\n          return node.nodeName === 'PRE' && node.firstChild.nodeName === 'CODE';\n        },\n        replacement: function replacement(content, node) {\n          return '\\n\\n    ' + node.firstChild.textContent.replace(/\\n/g, '\\n    ') + '\\n\\n';\n        }\n      }, {\n        filter: 'blockquote',\n        replacement: function replacement(content) {\n          content = content.trim();\n          content = content.replace(/\\n{3,}/g, '\\n\\n');\n          content = content.replace(/^/gm, '> ');\n          return '\\n\\n' + content + '\\n\\n';\n        }\n      }, {\n        filter: 'li',\n        replacement: function replacement(content, node) {\n          content = content.replace(/^\\s+/, '').replace(/\\n/gm, '\\n    ');\n          var prefix = '*   ';\n          var parent = node.parentNode;\n          var index = Array.prototype.indexOf.call(parent.children, node) + 1;\n          prefix = /ol/i.test(parent.nodeName) ? index + '.  ' : '*   ';\n          return prefix + content;\n        }\n      }, {\n        filter: ['ul', 'ol'],\n        replacement: function replacement(content, node) {\n          var strings = [];\n\n          for (var i = 0; i < node.childNodes.length; i++) {\n            strings.push(node.childNodes[i]._replacement);\n          }\n\n          if (/li/i.test(node.parentNode.nodeName)) {\n            return '\\n' + strings.join('\\n');\n          }\n\n          return '\\n\\n' + strings.join('\\n') + '\\n\\n';\n        }\n      }, {\n        filter: function filter(node) {\n          return this.isBlock(node);\n        },\n        replacement: function replacement(content, node) {\n          return '\\n\\n' + this.outer(node, content) + '\\n\\n';\n        }\n      }, // Anything else!\n      {\n        filter: function filter() {\n          return true;\n        },\n        replacement: function replacement(content, node) {\n          return this.outer(node, content);\n        }\n      }];\n    }, {}],\n    5: [function (require, module, exports) {\n      /**\n       * This file automatically generated from `build.js`.\n       * Do not manually edit.\n       */\n      module.exports = [\"address\", \"article\", \"aside\", \"audio\", \"blockquote\", \"canvas\", \"dd\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"hgroup\", \"hr\", \"main\", \"nav\", \"noscript\", \"ol\", \"output\", \"p\", \"pre\", \"section\", \"table\", \"tfoot\", \"ul\", \"video\"];\n    }, {}],\n    6: [function (require, module, exports) {}, {}],\n    7: [function (require, module, exports) {\n      'use strict';\n\n      var voidElements = require('void-elements');\n\n      Object.keys(voidElements).forEach(function (name) {\n        voidElements[name.toUpperCase()] = 1;\n      });\n      var blockElements = {};\n\n      require('block-elements').forEach(function (name) {\n        blockElements[name.toUpperCase()] = 1;\n      });\n      /**\n       * isBlockElem(node) determines if the given node is a block element.\n       *\n       * @param {Node} node\n       * @return {Boolean}\n       */\n\n\n      function isBlockElem(node) {\n        return !!(node && blockElements[node.nodeName]);\n      }\n      /**\n       * isVoid(node) determines if the given node is a void element.\n       *\n       * @param {Node} node\n       * @return {Boolean}\n       */\n\n\n      function isVoid(node) {\n        return !!(node && voidElements[node.nodeName]);\n      }\n      /**\n       * whitespace(elem [, isBlock]) removes extraneous whitespace from an\n       * the given element. The function isBlock may optionally be passed in\n       * to determine whether or not an element is a block element; if none\n       * is provided, defaults to using the list of block elements provided\n       * by the `block-elements` module.\n       *\n       * @param {Node} elem\n       * @param {Function} blockTest\n       */\n\n\n      function collapseWhitespace(elem, isBlock) {\n        if (!elem.firstChild || elem.nodeName === 'PRE') return;\n\n        if (typeof isBlock !== 'function') {\n          isBlock = isBlockElem;\n        }\n\n        var prevText = null;\n        var prevVoid = false;\n        var prev = null;\n        var node = next(prev, elem);\n\n        while (node !== elem) {\n          if (node.nodeType === 3) {\n            // Node.TEXT_NODE\n            var text = node.data.replace(/[ \\r\\n\\t]+/g, ' ');\n\n            if ((!prevText || / $/.test(prevText.data)) && !prevVoid && text[0] === ' ') {\n              text = text.substr(1);\n            } // `text` might be empty at this point.\n\n\n            if (!text) {\n              node = remove(node);\n              continue;\n            }\n\n            node.data = text;\n            prevText = node;\n          } else if (node.nodeType === 1) {\n            // Node.ELEMENT_NODE\n            if (isBlock(node) || node.nodeName === 'BR') {\n              if (prevText) {\n                prevText.data = prevText.data.replace(/ $/, '');\n              }\n\n              prevText = null;\n              prevVoid = false;\n            } else if (isVoid(node)) {\n              // Avoid trimming space around non-block, non-BR void elements.\n              prevText = null;\n              prevVoid = true;\n            }\n          } else {\n            node = remove(node);\n            continue;\n          }\n\n          var nextNode = next(prev, node);\n          prev = node;\n          node = nextNode;\n        }\n\n        if (prevText) {\n          prevText.data = prevText.data.replace(/ $/, '');\n\n          if (!prevText.data) {\n            remove(prevText);\n          }\n        }\n      }\n      /**\n       * remove(node) removes the given node from the DOM and returns the\n       * next node in the sequence.\n       *\n       * @param {Node} node\n       * @return {Node} node\n       */\n\n\n      function remove(node) {\n        var next = node.nextSibling || node.parentNode;\n        node.parentNode.removeChild(node);\n        return next;\n      }\n      /**\n       * next(prev, current) returns the next node in the sequence, given the\n       * current and previous nodes.\n       *\n       * @param {Node} prev\n       * @param {Node} current\n       * @return {Node}\n       */\n\n\n      function next(prev, current) {\n        if (prev && prev.parentNode === current || current.nodeName === 'PRE') {\n          return current.nextSibling || current.parentNode;\n        }\n\n        return current.firstChild || current.nextSibling || current.parentNode;\n      }\n\n      module.exports = collapseWhitespace;\n    }, {\n      \"block-elements\": 5,\n      \"void-elements\": 8\n    }],\n    8: [function (require, module, exports) {\n      /**\n       * This file automatically generated from `pre-publish.js`.\n       * Do not manually edit.\n       */\n      module.exports = {\n        \"area\": true,\n        \"base\": true,\n        \"br\": true,\n        \"col\": true,\n        \"embed\": true,\n        \"hr\": true,\n        \"img\": true,\n        \"input\": true,\n        \"keygen\": true,\n        \"link\": true,\n        \"menuitem\": true,\n        \"meta\": true,\n        \"param\": true,\n        \"source\": true,\n        \"track\": true,\n        \"wbr\": true\n      };\n    }, {}]\n  }, {}, [1])(1);\n});","map":null,"metadata":{},"sourceType":"script"}