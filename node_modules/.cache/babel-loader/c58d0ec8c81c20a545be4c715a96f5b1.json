{"ast":null,"code":"/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n\n/*\nCurrent bits of jankiness:\n- Uses two private APIs:\n    1. Dygraph.optionsViewForAxis_\n    2. dygraph.plotter_.area\n- Registers for a \"predraw\" event, which should be renamed.\n- I call calculateEmWidthInDiv more often than needed.\n*/\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nvar _dygraphUtils = require('../dygraph-utils');\n\nvar utils = _interopRequireWildcard(_dygraphUtils);\n/**\n * Creates the legend, which appears when the user hovers over the chart.\n * The legend can be either a user-specified or generated div.\n *\n * @constructor\n */\n\n\nvar Legend = function Legend() {\n  this.legend_div_ = null;\n  this.is_generated_div_ = false; // do we own this div, or was it user-specified?\n};\n\nLegend.prototype.toString = function () {\n  return \"Legend Plugin\";\n};\n/**\n * This is called during the dygraph constructor, after options have been set\n * but before the data is available.\n *\n * Proper tasks to do here include:\n * - Reading your own options\n * - DOM manipulation\n * - Registering event listeners\n *\n * @param {Dygraph} g Graph instance.\n * @return {object.<string, function(ev)>} Mapping of event names to callbacks.\n */\n\n\nLegend.prototype.activate = function (g) {\n  var div;\n  var userLabelsDiv = g.getOption('labelsDiv');\n\n  if (userLabelsDiv && null !== userLabelsDiv) {\n    if (typeof userLabelsDiv == \"string\" || userLabelsDiv instanceof String) {\n      div = document.getElementById(userLabelsDiv);\n    } else {\n      div = userLabelsDiv;\n    }\n  } else {\n    div = document.createElement(\"div\");\n    div.className = \"dygraph-legend\"; // TODO(danvk): come up with a cleaner way to expose this.\n\n    g.graphDiv.appendChild(div);\n    this.is_generated_div_ = true;\n  }\n\n  this.legend_div_ = div;\n  this.one_em_width_ = 10; // just a guess, will be updated.\n\n  return {\n    select: this.select,\n    deselect: this.deselect,\n    // TODO(danvk): rethink the name \"predraw\" before we commit to it in any API.\n    predraw: this.predraw,\n    didDrawChart: this.didDrawChart\n  };\n}; // Needed for dashed lines.\n\n\nvar calculateEmWidthInDiv = function calculateEmWidthInDiv(div) {\n  var sizeSpan = document.createElement('span');\n  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');\n  div.appendChild(sizeSpan);\n  var oneEmWidth = sizeSpan.offsetWidth;\n  div.removeChild(sizeSpan);\n  return oneEmWidth;\n};\n\nvar escapeHTML = function escapeHTML(str) {\n  return str.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n};\n\nLegend.prototype.select = function (e) {\n  var xValue = e.selectedX;\n  var points = e.selectedPoints;\n  var row = e.selectedRow;\n  var legendMode = e.dygraph.getOption('legend');\n\n  if (legendMode === 'never') {\n    this.legend_div_.style.display = 'none';\n    return;\n  }\n\n  if (legendMode === 'follow') {\n    // create floating legend div\n    var area = e.dygraph.plotter_.area;\n    var labelsDivWidth = this.legend_div_.offsetWidth;\n    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y'); // determine floating [left, top] coordinates of the legend div\n    // within the plotter_ area\n    // offset 50 px to the right and down from the first selection point\n    // 50 px is guess based on mouse cursor size\n\n    var leftLegend = points[0].x * area.w + 50;\n    var topLegend = points[0].y * area.h - 50; // if legend floats to end of the chart area, it flips to the other\n    // side of the selection point\n\n    if (leftLegend + labelsDivWidth + 1 > area.w) {\n      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);\n    }\n\n    e.dygraph.graphDiv.appendChild(this.legend_div_);\n    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + \"px\";\n    this.legend_div_.style.top = topLegend + \"px\";\n  }\n\n  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);\n  this.legend_div_.innerHTML = html;\n  this.legend_div_.style.display = '';\n};\n\nLegend.prototype.deselect = function (e) {\n  var legendMode = e.dygraph.getOption('legend');\n\n  if (legendMode !== 'always') {\n    this.legend_div_.style.display = \"none\";\n  } // Have to do this every time, since styles might have changed.\n\n\n  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);\n  this.one_em_width_ = oneEmWidth;\n  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);\n  this.legend_div_.innerHTML = html;\n};\n\nLegend.prototype.didDrawChart = function (e) {\n  this.deselect(e);\n}; // Right edge should be flush with the right edge of the charting area (which\n// may not be the same as the right edge of the div, if we have two y-axes.\n// TODO(danvk): is any of this really necessary? Could just set \"right\" in \"activate\".\n\n/**\n * Position the labels div so that:\n * - its right edge is flush with the right edge of the charting area\n * - its top edge is flush with the top edge of the charting area\n * @private\n */\n\n\nLegend.prototype.predraw = function (e) {\n  // Don't touch a user-specified labelsDiv.\n  if (!this.is_generated_div_) return; // TODO(danvk): only use real APIs for this.\n\n  e.dygraph.graphDiv.appendChild(this.legend_div_);\n  var area = e.dygraph.getArea();\n  var labelsDivWidth = this.legend_div_.offsetWidth;\n  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + \"px\";\n  this.legend_div_.style.top = area.y + \"px\";\n};\n/**\n * Called when dygraph.destroy() is called.\n * You should null out any references and detach any DOM elements.\n */\n\n\nLegend.prototype.destroy = function () {\n  this.legend_div_ = null;\n};\n/**\n * Generates HTML for the legend which is displayed when hovering over the\n * chart. If no selected points are specified, a default legend is returned\n * (this may just be the empty string).\n * @param {number} x The x-value of the selected points.\n * @param {Object} sel_points List of selected points for the given\n *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.\n * @param {number} oneEmWidth The pixel width for 1em in the legend. Only\n *   relevant when displaying a legend with no selection (i.e. {legend:\n *   'always'}) and with dashed lines.\n * @param {number} row The selected row index.\n * @private\n */\n\n\nLegend.generateLegendHTML = function (g, x, sel_points, oneEmWidth, row) {\n  // Data about the selection to pass to legendFormatter\n  var data = {\n    dygraph: g,\n    x: x,\n    series: []\n  };\n  var labelToSeries = {};\n  var labels = g.getLabels();\n\n  if (labels) {\n    for (var i = 1; i < labels.length; i++) {\n      var series = g.getPropertiesForSeries(labels[i]);\n      var strokePattern = g.getOption('strokePattern', labels[i]);\n      var seriesData = {\n        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),\n        label: labels[i],\n        labelHTML: escapeHTML(labels[i]),\n        isVisible: series.visible,\n        color: series.color\n      };\n      data.series.push(seriesData);\n      labelToSeries[labels[i]] = seriesData;\n    }\n  }\n\n  if (typeof x !== 'undefined') {\n    var xOptView = g.optionsViewForAxis_('x');\n    var xvf = xOptView('valueFormatter');\n    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);\n    var yOptViews = [];\n    var num_axes = g.numAxes();\n\n    for (var i = 0; i < num_axes; i++) {\n      // TODO(danvk): remove this use of a private API\n      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));\n    }\n\n    var showZeros = g.getOption('labelsShowZeroValues');\n    var highlightSeries = g.getHighlightSeries();\n\n    for (i = 0; i < sel_points.length; i++) {\n      var pt = sel_points[i];\n      var seriesData = labelToSeries[pt.name];\n      seriesData.y = pt.yval;\n\n      if (pt.yval === 0 && !showZeros || isNaN(pt.canvasy)) {\n        seriesData.isVisible = false;\n        continue;\n      }\n\n      var series = g.getPropertiesForSeries(pt.name);\n      var yOptView = yOptViews[series.axis - 1];\n      var fmtFunc = yOptView('valueFormatter');\n      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));\n      utils.update(seriesData, {\n        yHTML: yHTML\n      });\n\n      if (pt.name == highlightSeries) {\n        seriesData.isHighlighted = true;\n      }\n    }\n  }\n\n  var formatter = g.getOption('legendFormatter') || Legend.defaultFormatter;\n  return formatter.call(g, data);\n};\n\nLegend.defaultFormatter = function (data) {\n  var g = data.dygraph; // TODO(danvk): deprecate this option in place of {legend: 'never'}\n  // XXX should this logic be in the formatter?\n\n  if (g.getOption('showLabelsOnHighlight') !== true) return '';\n  var sepLines = g.getOption('labelsSeparateLines');\n  var html;\n\n  if (typeof data.x === 'undefined') {\n    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.\n    if (g.getOption('legend') != 'always') {\n      return '';\n    }\n\n    html = '';\n\n    for (var i = 0; i < data.series.length; i++) {\n      var series = data.series[i];\n      if (!series.isVisible) continue;\n      if (html !== '') html += sepLines ? '<br/>' : ' ';\n      html += \"<span style='font-weight: bold; color: \" + series.color + \";'>\" + series.dashHTML + \" \" + series.labelHTML + \"</span>\";\n    }\n\n    return html;\n  }\n\n  html = data.xHTML + ':';\n\n  for (var i = 0; i < data.series.length; i++) {\n    var series = data.series[i];\n    if (!series.isVisible) continue;\n    if (sepLines) html += '<br>';\n    var cls = series.isHighlighted ? ' class=\"highlight\"' : '';\n    html += \"<span\" + cls + \"> <b><span style='color: \" + series.color + \";'>\" + series.labelHTML + \"</span></b>:&#160;\" + series.yHTML + \"</span>\";\n  }\n\n  return html;\n};\n/**\n * Generates html for the \"dash\" displayed on the legend when using \"legend: always\".\n * In particular, this works for dashed lines with any stroke pattern. It will\n * try to scale the pattern to fit in 1em width. Or if small enough repeat the\n * pattern for 1em width.\n *\n * @param strokePattern The pattern\n * @param color The color of the series.\n * @param oneEmWidth The width in pixels of 1em in the legend.\n * @private\n */\n// TODO(danvk): cache the results of this\n\n\nfunction generateLegendDashHTML(strokePattern, color, oneEmWidth) {\n  // Easy, common case: a solid line\n  if (!strokePattern || strokePattern.length <= 1) {\n    return \"<div class=\\\"dygraph-legend-line\\\" style=\\\"border-bottom-color: \" + color + \";\\\"></div>\";\n  }\n\n  var i, j, paddingLeft, marginRight;\n  var strokePixelLength = 0,\n      segmentLoop = 0;\n  var normalizedPattern = [];\n  var loop; // Compute the length of the pixels including the first segment twice,\n  // since we repeat it.\n\n  for (i = 0; i <= strokePattern.length; i++) {\n    strokePixelLength += strokePattern[i % strokePattern.length];\n  } // See if we can loop the pattern by itself at least twice.\n\n\n  loop = Math.floor(oneEmWidth / (strokePixelLength - strokePattern[0]));\n\n  if (loop > 1) {\n    // This pattern fits at least two times, no scaling just convert to em;\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / oneEmWidth;\n    } // Since we are repeating the pattern, we don't worry about repeating the\n    // first segment in one draw.\n\n\n    segmentLoop = normalizedPattern.length;\n  } else {\n    // If the pattern doesn't fit in the legend we scale it to fit.\n    loop = 1;\n\n    for (i = 0; i < strokePattern.length; i++) {\n      normalizedPattern[i] = strokePattern[i] / strokePixelLength;\n    } // For the scaled patterns we do redraw the first segment.\n\n\n    segmentLoop = normalizedPattern.length + 1;\n  } // Now make the pattern.\n\n\n  var dash = \"\";\n\n  for (j = 0; j < loop; j++) {\n    for (i = 0; i < segmentLoop; i += 2) {\n      // The padding is the drawn segment.\n      paddingLeft = normalizedPattern[i % normalizedPattern.length];\n\n      if (i < strokePattern.length) {\n        // The margin is the space segment.\n        marginRight = normalizedPattern[(i + 1) % normalizedPattern.length];\n      } else {\n        // The repeated first segment has no right margin.\n        marginRight = 0;\n      }\n\n      dash += \"<div class=\\\"dygraph-legend-dash\\\" style=\\\"margin-right: \" + marginRight + \"em; padding-left: \" + paddingLeft + \"em;\\\"></div>\";\n    }\n  }\n\n  return dash;\n}\n\n;\nexports[\"default\"] = Legend;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}