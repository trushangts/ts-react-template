{"ast":null,"code":"/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the fractions option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _datahandler = require('./datahandler');\n\nvar _datahandler2 = _interopRequireDefault(_datahandler);\n\nvar _default = require('./default');\n\nvar _default2 = _interopRequireDefault(_default);\n/**\n * @extends DefaultHandler\n * @constructor\n */\n\n\nvar DefaultFractionHandler = function DefaultFractionHandler() {};\n\nDefaultFractionHandler.prototype = new _default2['default']();\n\nDefaultFractionHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value;\n  var mult = 100.0;\n  var logScale = options.get('logscale');\n\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    } // Extract to the unified data format.\n\n\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        y = mult * value; // preserve original values in extras for further filtering\n\n        series.push([x, y, [num, den]]);\n      } else {\n        series.push([x, num, [num, den]]);\n      }\n    } else {\n      series.push([x, null, [null, null]]);\n    }\n  }\n\n  return series;\n};\n\nDefaultFractionHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var i;\n  var num = 0;\n  var den = 0; // numerator/denominator\n\n  var mult = 100.0;\n\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][0];\n    den += originalData[i][2][1];\n\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][0];\n      den -= originalData[i - rollPeriod][2][1];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n    rollingData[i] = [date, mult * value];\n  }\n\n  return rollingData;\n};\n\nexports['default'] = DefaultFractionHandler;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}