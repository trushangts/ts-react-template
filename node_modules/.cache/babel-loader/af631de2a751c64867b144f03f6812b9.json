{"ast":null,"code":"/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the error bars option.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar _bars = require('./bars');\n\nvar _bars2 = _interopRequireDefault(_bars);\n/**\n * @constructor\n * @extends BarsHandler\n */\n\n\nvar ErrorBarsHandler = function ErrorBarsHandler() {};\n\nErrorBarsHandler.prototype = new _bars2[\"default\"]();\n/** @inheritDoc */\n\nErrorBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, variance, point;\n  var sigma = options.get(\"sigma\");\n  var logScale = options.get('logscale');\n\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {\n        point = null;\n      }\n    } // Extract to the unified data format.\n\n\n    if (point !== null) {\n      y = point[0];\n\n      if (y !== null && !isNaN(y)) {\n        variance = sigma * point[1]; // preserve original error value in extras for further\n        // filtering\n\n        series.push([x, y, [y - variance, y + variance, point[1]]]);\n      } else {\n        series.push([x, y, [y, y, y]]);\n      }\n    } else {\n      series.push([x, null, [null, null, null]]);\n    }\n  }\n\n  return series;\n};\n/** @inheritDoc */\n\n\nErrorBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get(\"sigma\");\n  var i, j, y, v, sum, num_ok, stddev, variance, value; // Calculate the rolling average for the first rollPeriod - 1 points\n  // where there is not enough data to roll over the full number of points\n\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    variance = 0;\n    num_ok = 0;\n\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y)) continue;\n      num_ok++;\n      sum += y;\n      variance += Math.pow(originalData[j][2][2], 2);\n    }\n\n    if (num_ok) {\n      stddev = Math.sqrt(variance) / num_ok;\n      value = sum / num_ok;\n      rollingData[i] = [originalData[i][0], value, [value - sigma * stddev, value + sigma * stddev]];\n    } else {\n      // This explicitly preserves NaNs to aid with \"independent\n      // series\".\n      // See testRollingAveragePreservesNaNs.\n      v = rollPeriod == 1 ? originalData[i][1] : null;\n      rollingData[i] = [originalData[i][0], v, [v, v]];\n    }\n  }\n\n  return rollingData;\n};\n\nexports[\"default\"] = ErrorBarsHandler;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}