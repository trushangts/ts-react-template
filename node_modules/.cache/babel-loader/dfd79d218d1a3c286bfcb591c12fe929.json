{"ast":null,"code":"/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler default implementation used for simple line charts.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _datahandler = require('./datahandler');\n\nvar _datahandler2 = _interopRequireDefault(_datahandler);\n/**\n * @constructor\n * @extends Dygraph.DataHandler\n */\n\n\nvar DefaultHandler = function DefaultHandler() {};\n\nDefaultHandler.prototype = new _datahandler2['default']();\n/** @inheritDoc */\n\nDefaultHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var logScale = options.get('logscale');\n\n  for (var j = 0; j < rawData.length; j++) {\n    var x = rawData[j][0];\n    var point = rawData[j][i];\n\n    if (logScale) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point <= 0) {\n        point = null;\n      }\n    }\n\n    series.push([x, point]);\n  }\n\n  return series;\n};\n/** @inheritDoc */\n\n\nDefaultHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var i, j, y, sum, num_ok; // Calculate the rolling average for the first rollPeriod - 1 points\n  // where\n  // there is not enough data to roll over the full number of points\n\n  if (rollPeriod == 1) {\n    return originalData;\n  }\n\n  for (i = 0; i < originalData.length; i++) {\n    sum = 0;\n    num_ok = 0;\n\n    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {\n      y = originalData[j][1];\n      if (y === null || isNaN(y)) continue;\n      num_ok++;\n      sum += originalData[j][1];\n    }\n\n    if (num_ok) {\n      rollingData[i] = [originalData[i][0], sum / num_ok];\n    } else {\n      rollingData[i] = [originalData[i][0], null];\n    }\n  }\n\n  return rollingData;\n};\n/** @inheritDoc */\n\n\nDefaultHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {\n  var minY = null,\n      maxY = null,\n      y;\n  var firstIdx = 0,\n      lastIdx = series.length - 1;\n\n  for (var j = firstIdx; j <= lastIdx; j++) {\n    y = series[j][1];\n    if (y === null || isNaN(y)) continue;\n\n    if (maxY === null || y > maxY) {\n      maxY = y;\n    }\n\n    if (minY === null || y < minY) {\n      minY = y;\n    }\n  }\n\n  return [minY, maxY];\n};\n\nexports['default'] = DefaultHandler;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}