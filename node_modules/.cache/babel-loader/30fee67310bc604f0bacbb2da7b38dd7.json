{"ast":null,"code":"/**\n * @license\n * Copyright 2011 Robert Konigsberg (konigsberg@google.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview The default interaction model for Dygraphs. This is kept out\n * of dygraph.js for better navigability.\n * @author Robert Konigsberg (konigsberg@google.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nvar _dygraphUtils = require('./dygraph-utils');\n\nvar utils = _interopRequireWildcard(_dygraphUtils);\n/**\n * You can drag this many pixels past the edge of the chart and still have it\n * be considered a zoom. This makes it easier to zoom to the exact edge of the\n * chart, a fairly common operation.\n */\n\n\nvar DRAG_EDGE_MARGIN = 100;\n/**\n * A collection of functions to facilitate build custom interaction models.\n * @class\n */\n\nvar DygraphInteraction = {};\n/**\n * Checks whether the beginning & ending of an event were close enough that it\n * should be considered a click. If it should, dispatch appropriate events.\n * Returns true if the event was treated as a click.\n *\n * @param {Event} event\n * @param {Dygraph} g\n * @param {Object} context\n */\n\nDygraphInteraction.maybeTreatMouseOpAsClick = function (event, g, context) {\n  context.dragEndX = utils.dragGetX_(event, context);\n  context.dragEndY = utils.dragGetY_(event, context);\n  var regionWidth = Math.abs(context.dragEndX - context.dragStartX);\n  var regionHeight = Math.abs(context.dragEndY - context.dragStartY);\n\n  if (regionWidth < 2 && regionHeight < 2 && g.lastx_ !== undefined && g.lastx_ != -1) {\n    DygraphInteraction.treatMouseOpAsClick(g, event, context);\n  }\n\n  context.regionWidth = regionWidth;\n  context.regionHeight = regionHeight;\n};\n/**\n * Called in response to an interaction model operation that\n * should start the default panning behavior.\n *\n * It's used in the default callback for \"mousedown\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the startPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\n\n\nDygraphInteraction.startPan = function (event, g, context) {\n  var i, axis;\n  context.isPanning = true;\n  var xRange = g.xAxisRange();\n\n  if (g.getOptionForAxis(\"logscale\", \"x\")) {\n    context.initialLeftmostDate = utils.log10(xRange[0]);\n    context.dateRange = utils.log10(xRange[1]) - utils.log10(xRange[0]);\n  } else {\n    context.initialLeftmostDate = xRange[0];\n    context.dateRange = xRange[1] - xRange[0];\n  }\n\n  context.xUnitsPerPixel = context.dateRange / (g.plotter_.area.w - 1);\n\n  if (g.getNumericOption(\"panEdgeFraction\")) {\n    var maxXPixelsToDraw = g.width_ * g.getNumericOption(\"panEdgeFraction\");\n    var xExtremes = g.xAxisExtremes(); // I REALLY WANT TO CALL THIS xTremes!\n\n    var boundedLeftX = g.toDomXCoord(xExtremes[0]) - maxXPixelsToDraw;\n    var boundedRightX = g.toDomXCoord(xExtremes[1]) + maxXPixelsToDraw;\n    var boundedLeftDate = g.toDataXCoord(boundedLeftX);\n    var boundedRightDate = g.toDataXCoord(boundedRightX);\n    context.boundedDates = [boundedLeftDate, boundedRightDate];\n    var boundedValues = [];\n    var maxYPixelsToDraw = g.height_ * g.getNumericOption(\"panEdgeFraction\");\n\n    for (i = 0; i < g.axes_.length; i++) {\n      axis = g.axes_[i];\n      var yExtremes = axis.extremeRange;\n      var boundedTopY = g.toDomYCoord(yExtremes[0], i) + maxYPixelsToDraw;\n      var boundedBottomY = g.toDomYCoord(yExtremes[1], i) - maxYPixelsToDraw;\n      var boundedTopValue = g.toDataYCoord(boundedTopY, i);\n      var boundedBottomValue = g.toDataYCoord(boundedBottomY, i);\n      boundedValues[i] = [boundedTopValue, boundedBottomValue];\n    }\n\n    context.boundedValues = boundedValues;\n  } // Record the range of each y-axis at the start of the drag.\n  // If any axis has a valueRange, then we want a 2D pan.\n  // We can't store data directly in g.axes_, because it does not belong to us\n  // and could change out from under us during a pan (say if there's a data\n  // update).\n\n\n  context.is2DPan = false;\n  context.axes = [];\n\n  for (i = 0; i < g.axes_.length; i++) {\n    axis = g.axes_[i];\n    var axis_data = {};\n    var yRange = g.yAxisRange(i); // TODO(konigsberg): These values should be in |context|.\n    // In log scale, initialTopValue, dragValueRange and unitsPerPixel are log scale.\n\n    var logscale = g.attributes_.getForAxis(\"logscale\", i);\n\n    if (logscale) {\n      axis_data.initialTopValue = utils.log10(yRange[1]);\n      axis_data.dragValueRange = utils.log10(yRange[1]) - utils.log10(yRange[0]);\n    } else {\n      axis_data.initialTopValue = yRange[1];\n      axis_data.dragValueRange = yRange[1] - yRange[0];\n    }\n\n    axis_data.unitsPerPixel = axis_data.dragValueRange / (g.plotter_.area.h - 1);\n    context.axes.push(axis_data); // While calculating axes, set 2dpan.\n\n    if (axis.valueRange) context.is2DPan = true;\n  }\n};\n/**\n * Called in response to an interaction model operation that\n * responds to an event that pans the view.\n *\n * It's used in the default callback for \"mousemove\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the movePan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\n\n\nDygraphInteraction.movePan = function (event, g, context) {\n  context.dragEndX = utils.dragGetX_(event, context);\n  context.dragEndY = utils.dragGetY_(event, context);\n  var minDate = context.initialLeftmostDate - (context.dragEndX - context.dragStartX) * context.xUnitsPerPixel;\n\n  if (context.boundedDates) {\n    minDate = Math.max(minDate, context.boundedDates[0]);\n  }\n\n  var maxDate = minDate + context.dateRange;\n\n  if (context.boundedDates) {\n    if (maxDate > context.boundedDates[1]) {\n      // Adjust minDate, and recompute maxDate.\n      minDate = minDate - (maxDate - context.boundedDates[1]);\n      maxDate = minDate + context.dateRange;\n    }\n  }\n\n  if (g.getOptionForAxis(\"logscale\", \"x\")) {\n    g.dateWindow_ = [Math.pow(utils.LOG_SCALE, minDate), Math.pow(utils.LOG_SCALE, maxDate)];\n  } else {\n    g.dateWindow_ = [minDate, maxDate];\n  } // y-axis scaling is automatic unless this is a full 2D pan.\n\n\n  if (context.is2DPan) {\n    var pixelsDragged = context.dragEndY - context.dragStartY; // Adjust each axis appropriately.\n\n    for (var i = 0; i < g.axes_.length; i++) {\n      var axis = g.axes_[i];\n      var axis_data = context.axes[i];\n      var unitsDragged = pixelsDragged * axis_data.unitsPerPixel;\n      var boundedValue = context.boundedValues ? context.boundedValues[i] : null; // In log scale, maxValue and minValue are the logs of those values.\n\n      var maxValue = axis_data.initialTopValue + unitsDragged;\n\n      if (boundedValue) {\n        maxValue = Math.min(maxValue, boundedValue[1]);\n      }\n\n      var minValue = maxValue - axis_data.dragValueRange;\n\n      if (boundedValue) {\n        if (minValue < boundedValue[0]) {\n          // Adjust maxValue, and recompute minValue.\n          maxValue = maxValue - (minValue - boundedValue[0]);\n          minValue = maxValue - axis_data.dragValueRange;\n        }\n      }\n\n      if (g.attributes_.getForAxis(\"logscale\", i)) {\n        axis.valueRange = [Math.pow(utils.LOG_SCALE, minValue), Math.pow(utils.LOG_SCALE, maxValue)];\n      } else {\n        axis.valueRange = [minValue, maxValue];\n      }\n    }\n  }\n\n  g.drawGraph_(false);\n};\n/**\n * Called in response to an interaction model operation that\n * responds to an event that ends panning.\n *\n * It's used in the default callback for \"mouseup\" operations.\n * Custom interaction model builders can use it to provide the default\n * panning behavior.\n *\n * @param {Event} event the event object which led to the endPan call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\n\n\nDygraphInteraction.endPan = DygraphInteraction.maybeTreatMouseOpAsClick;\n/**\n * Called in response to an interaction model operation that\n * responds to an event that starts zooming.\n *\n * It's used in the default callback for \"mousedown\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the startZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\n\nDygraphInteraction.startZoom = function (event, g, context) {\n  context.isZooming = true;\n  context.zoomMoved = false;\n};\n/**\n * Called in response to an interaction model operation that\n * responds to an event that defines zoom boundaries.\n *\n * It's used in the default callback for \"mousemove\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the moveZoom call.\n * @param {Dygraph} g The dygraph on which to act.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\n\n\nDygraphInteraction.moveZoom = function (event, g, context) {\n  context.zoomMoved = true;\n  context.dragEndX = utils.dragGetX_(event, context);\n  context.dragEndY = utils.dragGetY_(event, context);\n  var xDelta = Math.abs(context.dragStartX - context.dragEndX);\n  var yDelta = Math.abs(context.dragStartY - context.dragEndY); // drag direction threshold for y axis is twice as large as x axis\n\n  context.dragDirection = xDelta < yDelta / 2 ? utils.VERTICAL : utils.HORIZONTAL;\n  g.drawZoomRect_(context.dragDirection, context.dragStartX, context.dragEndX, context.dragStartY, context.dragEndY, context.prevDragDirection, context.prevEndX, context.prevEndY);\n  context.prevEndX = context.dragEndX;\n  context.prevEndY = context.dragEndY;\n  context.prevDragDirection = context.dragDirection;\n};\n/**\n * TODO(danvk): move this logic into dygraph.js\n * @param {Dygraph} g\n * @param {Event} event\n * @param {Object} context\n */\n\n\nDygraphInteraction.treatMouseOpAsClick = function (g, event, context) {\n  var clickCallback = g.getFunctionOption('clickCallback');\n  var pointClickCallback = g.getFunctionOption('pointClickCallback');\n  var selectedPoint = null; // Find out if the click occurs on a point.\n\n  var closestIdx = -1;\n  var closestDistance = Number.MAX_VALUE; // check if the click was on a particular point.\n\n  for (var i = 0; i < g.selPoints_.length; i++) {\n    var p = g.selPoints_[i];\n    var distance = Math.pow(p.canvasx - context.dragEndX, 2) + Math.pow(p.canvasy - context.dragEndY, 2);\n\n    if (!isNaN(distance) && (closestIdx == -1 || distance < closestDistance)) {\n      closestDistance = distance;\n      closestIdx = i;\n    }\n  } // Allow any click within two pixels of the dot.\n\n\n  var radius = g.getNumericOption('highlightCircleSize') + 2;\n\n  if (closestDistance <= radius * radius) {\n    selectedPoint = g.selPoints_[closestIdx];\n  }\n\n  if (selectedPoint) {\n    var e = {\n      cancelable: true,\n      point: selectedPoint,\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY\n    };\n    var defaultPrevented = g.cascadeEvents_('pointClick', e);\n\n    if (defaultPrevented) {\n      // Note: this also prevents click / clickCallback from firing.\n      return;\n    }\n\n    if (pointClickCallback) {\n      pointClickCallback.call(g, event, selectedPoint);\n    }\n  }\n\n  var e = {\n    cancelable: true,\n    xval: g.lastx_,\n    // closest point by x value\n    pts: g.selPoints_,\n    canvasx: context.dragEndX,\n    canvasy: context.dragEndY\n  };\n\n  if (!g.cascadeEvents_('click', e)) {\n    if (clickCallback) {\n      // TODO(danvk): pass along more info about the points, e.g. 'x'\n      clickCallback.call(g, event, g.lastx_, g.selPoints_);\n    }\n  }\n};\n/**\n * Called in response to an interaction model operation that\n * responds to an event that performs a zoom based on previously defined\n * bounds..\n *\n * It's used in the default callback for \"mouseup\" operations.\n * Custom interaction model builders can use it to provide the default\n * zooming behavior.\n *\n * @param {Event} event the event object which led to the endZoom call.\n * @param {Dygraph} g The dygraph on which to end the zoom.\n * @param {Object} context The dragging context object (with\n *     dragStartX/dragStartY/etc. properties). This function modifies the\n *     context.\n */\n\n\nDygraphInteraction.endZoom = function (event, g, context) {\n  g.clearZoomRect_();\n  context.isZooming = false;\n  DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context); // The zoom rectangle is visibly clipped to the plot area, so its behavior\n  // should be as well.\n  // See http://code.google.com/p/dygraphs/issues/detail?id=280\n\n  var plotArea = g.getArea();\n\n  if (context.regionWidth >= 10 && context.dragDirection == utils.HORIZONTAL) {\n    var left = Math.min(context.dragStartX, context.dragEndX),\n        right = Math.max(context.dragStartX, context.dragEndX);\n    left = Math.max(left, plotArea.x);\n    right = Math.min(right, plotArea.x + plotArea.w);\n\n    if (left < right) {\n      g.doZoomX_(left, right);\n    }\n\n    context.cancelNextDblclick = true;\n  } else if (context.regionHeight >= 10 && context.dragDirection == utils.VERTICAL) {\n    var top = Math.min(context.dragStartY, context.dragEndY),\n        bottom = Math.max(context.dragStartY, context.dragEndY);\n    top = Math.max(top, plotArea.y);\n    bottom = Math.min(bottom, plotArea.y + plotArea.h);\n\n    if (top < bottom) {\n      g.doZoomY_(top, bottom);\n    }\n\n    context.cancelNextDblclick = true;\n  }\n\n  context.dragStartX = null;\n  context.dragStartY = null;\n};\n/**\n * @private\n */\n\n\nDygraphInteraction.startTouch = function (event, g, context) {\n  event.preventDefault(); // touch browsers are all nice.\n\n  if (event.touches.length > 1) {\n    // If the user ever puts two fingers down, it's not a double tap.\n    context.startTimeForDoubleTapMs = null;\n  }\n\n  var touches = [];\n\n  for (var i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i]; // we dispense with 'dragGetX_' because all touchBrowsers support pageX\n\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY,\n      dataX: g.toDataXCoord(t.pageX),\n      dataY: g.toDataYCoord(t.pageY) // identifier: t.identifier\n\n    });\n  }\n\n  context.initialTouches = touches;\n\n  if (touches.length == 1) {\n    // This is just a swipe.\n    context.initialPinchCenter = touches[0];\n    context.touchDirections = {\n      x: true,\n      y: true\n    };\n  } else if (touches.length >= 2) {\n    // It's become a pinch!\n    // In case there are 3+ touches, we ignore all but the \"first\" two.\n    // only screen coordinates can be averaged (data coords could be log scale).\n    context.initialPinchCenter = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY),\n      // TODO(danvk): remove\n      dataX: 0.5 * (touches[0].dataX + touches[1].dataX),\n      dataY: 0.5 * (touches[0].dataY + touches[1].dataY)\n    }; // Make pinches in a 45-degree swath around either axis 1-dimensional zooms.\n\n    var initialAngle = 180 / Math.PI * Math.atan2(context.initialPinchCenter.pageY - touches[0].pageY, touches[0].pageX - context.initialPinchCenter.pageX); // use symmetry to get it into the first quadrant.\n\n    initialAngle = Math.abs(initialAngle);\n    if (initialAngle > 90) initialAngle = 90 - initialAngle;\n    context.touchDirections = {\n      x: initialAngle < 90 - 45 / 2,\n      y: initialAngle > 45 / 2\n    };\n  } // save the full x & y ranges.\n\n\n  context.initialRange = {\n    x: g.xAxisRange(),\n    y: g.yAxisRange()\n  };\n};\n/**\n * @private\n */\n\n\nDygraphInteraction.moveTouch = function (event, g, context) {\n  // If the tap moves, then it's definitely not part of a double-tap.\n  context.startTimeForDoubleTapMs = null;\n  var i,\n      touches = [];\n\n  for (i = 0; i < event.touches.length; i++) {\n    var t = event.touches[i];\n    touches.push({\n      pageX: t.pageX,\n      pageY: t.pageY\n    });\n  }\n\n  var initialTouches = context.initialTouches;\n  var c_now; // old and new centers.\n\n  var c_init = context.initialPinchCenter;\n\n  if (touches.length == 1) {\n    c_now = touches[0];\n  } else {\n    c_now = {\n      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),\n      pageY: 0.5 * (touches[0].pageY + touches[1].pageY)\n    };\n  } // this is the \"swipe\" component\n  // we toss it out for now, but could use it in the future.\n\n\n  var swipe = {\n    pageX: c_now.pageX - c_init.pageX,\n    pageY: c_now.pageY - c_init.pageY\n  };\n  var dataWidth = context.initialRange.x[1] - context.initialRange.x[0];\n  var dataHeight = context.initialRange.y[0] - context.initialRange.y[1];\n  swipe.dataX = swipe.pageX / g.plotter_.area.w * dataWidth;\n  swipe.dataY = swipe.pageY / g.plotter_.area.h * dataHeight;\n  var xScale, yScale; // The residual bits are usually split into scale & rotate bits, but we split\n  // them into x-scale and y-scale bits.\n\n  if (touches.length == 1) {\n    xScale = 1.0;\n    yScale = 1.0;\n  } else if (touches.length >= 2) {\n    var initHalfWidth = initialTouches[1].pageX - c_init.pageX;\n    xScale = (touches[1].pageX - c_now.pageX) / initHalfWidth;\n    var initHalfHeight = initialTouches[1].pageY - c_init.pageY;\n    yScale = (touches[1].pageY - c_now.pageY) / initHalfHeight;\n  } // Clip scaling to [1/8, 8] to prevent too much blowup.\n\n\n  xScale = Math.min(8, Math.max(0.125, xScale));\n  yScale = Math.min(8, Math.max(0.125, yScale));\n  var didZoom = false;\n\n  if (context.touchDirections.x) {\n    g.dateWindow_ = [c_init.dataX - swipe.dataX + (context.initialRange.x[0] - c_init.dataX) / xScale, c_init.dataX - swipe.dataX + (context.initialRange.x[1] - c_init.dataX) / xScale];\n    didZoom = true;\n  }\n\n  if (context.touchDirections.y) {\n    for (i = 0; i < 1\n    /*g.axes_.length*/\n    ; i++) {\n      var axis = g.axes_[i];\n      var logscale = g.attributes_.getForAxis(\"logscale\", i);\n\n      if (logscale) {// TODO(danvk): implement\n      } else {\n        axis.valueRange = [c_init.dataY - swipe.dataY + (context.initialRange.y[0] - c_init.dataY) / yScale, c_init.dataY - swipe.dataY + (context.initialRange.y[1] - c_init.dataY) / yScale];\n        didZoom = true;\n      }\n    }\n  }\n\n  g.drawGraph_(false); // We only call zoomCallback on zooms, not pans, to mirror desktop behavior.\n\n  if (didZoom && touches.length > 1 && g.getFunctionOption('zoomCallback')) {\n    var viewWindow = g.xAxisRange();\n    g.getFunctionOption(\"zoomCallback\").call(g, viewWindow[0], viewWindow[1], g.yAxisRanges());\n  }\n};\n/**\n * @private\n */\n\n\nDygraphInteraction.endTouch = function (event, g, context) {\n  if (event.touches.length !== 0) {\n    // this is effectively a \"reset\"\n    DygraphInteraction.startTouch(event, g, context);\n  } else if (event.changedTouches.length == 1) {\n    // Could be part of a \"double tap\"\n    // The heuristic here is that it's a double-tap if the two touchend events\n    // occur within 500ms and within a 50x50 pixel box.\n    var now = new Date().getTime();\n    var t = event.changedTouches[0];\n\n    if (context.startTimeForDoubleTapMs && now - context.startTimeForDoubleTapMs < 500 && context.doubleTapX && Math.abs(context.doubleTapX - t.screenX) < 50 && context.doubleTapY && Math.abs(context.doubleTapY - t.screenY) < 50) {\n      g.resetZoom();\n    } else {\n      context.startTimeForDoubleTapMs = now;\n      context.doubleTapX = t.screenX;\n      context.doubleTapY = t.screenY;\n    }\n  }\n}; // Determine the distance from x to [left, right].\n\n\nvar distanceFromInterval = function distanceFromInterval(x, left, right) {\n  if (x < left) {\n    return left - x;\n  } else if (x > right) {\n    return x - right;\n  } else {\n    return 0;\n  }\n};\n/**\n * Returns the number of pixels by which the event happens from the nearest\n * edge of the chart. For events in the interior of the chart, this returns zero.\n */\n\n\nvar distanceFromChart = function distanceFromChart(event, g) {\n  var chartPos = utils.findPos(g.canvas_);\n  var box = {\n    left: chartPos.x,\n    right: chartPos.x + g.canvas_.offsetWidth,\n    top: chartPos.y,\n    bottom: chartPos.y + g.canvas_.offsetHeight\n  };\n  var pt = {\n    x: utils.pageX(event),\n    y: utils.pageY(event)\n  };\n  var dx = distanceFromInterval(pt.x, box.left, box.right),\n      dy = distanceFromInterval(pt.y, box.top, box.bottom);\n  return Math.max(dx, dy);\n};\n/**\n * Default interation model for dygraphs. You can refer to specific elements of\n * this when constructing your own interaction model, e.g.:\n * g.updateOptions( {\n *   interactionModel: {\n *     mousedown: DygraphInteraction.defaultInteractionModel.mousedown\n *   }\n * } );\n */\n\n\nDygraphInteraction.defaultModel = {\n  // Track the beginning of drag events\n  mousedown: function mousedown(event, g, context) {\n    // Right-click should not initiate a zoom.\n    if (event.button && event.button == 2) return;\n    context.initializeMouseDown(event, g, context);\n\n    if (event.altKey || event.shiftKey) {\n      DygraphInteraction.startPan(event, g, context);\n    } else {\n      DygraphInteraction.startZoom(event, g, context);\n    } // Note: we register mousemove/mouseup on document to allow some leeway for\n    // events to move outside of the chart. Interaction model events get\n    // registered on the canvas, which is too small to allow this.\n\n\n    var mousemove = function mousemove(event) {\n      if (context.isZooming) {\n        // When the mouse moves >200px from the chart edge, cancel the zoom.\n        var d = distanceFromChart(event, g);\n\n        if (d < DRAG_EDGE_MARGIN) {\n          DygraphInteraction.moveZoom(event, g, context);\n        } else {\n          if (context.dragEndX !== null) {\n            context.dragEndX = null;\n            context.dragEndY = null;\n            g.clearZoomRect_();\n          }\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.movePan(event, g, context);\n      }\n    };\n\n    var mouseup = function mouseup(event) {\n      if (context.isZooming) {\n        if (context.dragEndX !== null) {\n          DygraphInteraction.endZoom(event, g, context);\n        } else {\n          DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);\n        }\n      } else if (context.isPanning) {\n        DygraphInteraction.endPan(event, g, context);\n      }\n\n      utils.removeEvent(document, 'mousemove', mousemove);\n      utils.removeEvent(document, 'mouseup', mouseup);\n      context.destroy();\n    };\n\n    g.addAndTrackEvent(document, 'mousemove', mousemove);\n    g.addAndTrackEvent(document, 'mouseup', mouseup);\n  },\n  willDestroyContextMyself: true,\n  touchstart: function touchstart(event, g, context) {\n    DygraphInteraction.startTouch(event, g, context);\n  },\n  touchmove: function touchmove(event, g, context) {\n    DygraphInteraction.moveTouch(event, g, context);\n  },\n  touchend: function touchend(event, g, context) {\n    DygraphInteraction.endTouch(event, g, context);\n  },\n  // Disable zooming out if panning.\n  dblclick: function dblclick(event, g, context) {\n    if (context.cancelNextDblclick) {\n      context.cancelNextDblclick = false;\n      return;\n    } // Give plugins a chance to grab this event.\n\n\n    var e = {\n      canvasx: context.dragEndX,\n      canvasy: context.dragEndY,\n      cancelable: true\n    };\n\n    if (g.cascadeEvents_('dblclick', e)) {\n      return;\n    }\n\n    if (event.altKey || event.shiftKey) {\n      return;\n    }\n\n    g.resetZoom();\n  }\n};\n/*\nDygraph.DEFAULT_ATTRS.interactionModel = DygraphInteraction.defaultModel;\n\n// old ways of accessing these methods/properties\nDygraph.defaultInteractionModel = DygraphInteraction.defaultModel;\nDygraph.endZoom = DygraphInteraction.endZoom;\nDygraph.moveZoom = DygraphInteraction.moveZoom;\nDygraph.startZoom = DygraphInteraction.startZoom;\nDygraph.endPan = DygraphInteraction.endPan;\nDygraph.movePan = DygraphInteraction.movePan;\nDygraph.startPan = DygraphInteraction.startPan;\n*/\n\nDygraphInteraction.nonInteractiveModel_ = {\n  mousedown: function mousedown(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n  },\n  mouseup: DygraphInteraction.maybeTreatMouseOpAsClick\n}; // Default interaction model when using the range selector.\n\nDygraphInteraction.dragIsPanInteractionModel = {\n  mousedown: function mousedown(event, g, context) {\n    context.initializeMouseDown(event, g, context);\n    DygraphInteraction.startPan(event, g, context);\n  },\n  mousemove: function mousemove(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.movePan(event, g, context);\n    }\n  },\n  mouseup: function mouseup(event, g, context) {\n    if (context.isPanning) {\n      DygraphInteraction.endPan(event, g, context);\n    }\n  }\n};\nexports[\"default\"] = DygraphInteraction;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}