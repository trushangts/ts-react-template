{"ast":null,"code":"/*!\n * FullCalendar v2.9.0\n * Docs & License: http://fullcalendar.io/\n * (c) 2016 Adam Shaw\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery', 'moment'], factory);\n  } else if (typeof exports === 'object') {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'), require('moment'));\n  } else {\n    factory(jQuery, moment);\n  }\n})(function ($, moment) {\n  ;\n  ;\n  var FC = $.fullCalendar = {\n    version: \"2.9.0\",\n    internalApiVersion: 4\n  };\n  var fcViews = FC.views = {};\n\n  $.fn.fullCalendar = function (options) {\n    var args = Array.prototype.slice.call(arguments, 1); // for a possible method call\n\n    var res = this; // what this function will return (this jQuery object by default)\n\n    this.each(function (i, _element) {\n      // loop each DOM element involved\n      var element = $(_element);\n      var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\n\n      var singleRes; // the returned value of this single method call\n      // a method call\n\n      if (typeof options === 'string') {\n        if (calendar && $.isFunction(calendar[options])) {\n          singleRes = calendar[options].apply(calendar, args);\n\n          if (!i) {\n            res = singleRes; // record the first method call result\n          }\n\n          if (options === 'destroy') {\n            // for the destroy method, must remove Calendar object data\n            element.removeData('fullCalendar');\n          }\n        }\n      } // a new calendar initialization\n      else if (!calendar) {\n          // don't initialize twice\n          calendar = new Calendar(element, options);\n          element.data('fullCalendar', calendar);\n          calendar.render();\n        }\n    });\n    return res;\n  };\n\n  var complexOptions = [// names of options that are objects whose properties should be combined\n  'header', 'buttonText', 'buttonIcons', 'themeButtonIcons']; // Merges an array of option objects into a single object\n\n  function mergeOptions(optionObjs) {\n    return mergeProps(optionObjs, complexOptions);\n  } // Given options specified for the calendar's constructor, massages any legacy options into a non-legacy form.\n  // Converts View-Option-Hashes into the View-Specific-Options format.\n\n\n  function massageOverrides(input) {\n    var overrides = {\n      views: input.views || {}\n    }; // the output. ensure a `views` hash\n\n    var subObj; // iterate through all option override properties (except `views`)\n\n    $.each(input, function (name, val) {\n      if (name != 'views') {\n        // could the value be a legacy View-Option-Hash?\n        if ($.isPlainObject(val) && !/(time|duration|interval)$/i.test(name) && // exclude duration options. might be given as objects\n        $.inArray(name, complexOptions) == -1 // complex options aren't allowed to be View-Option-Hashes\n        ) {\n            subObj = null; // iterate through the properties of this possible View-Option-Hash value\n\n            $.each(val, function (subName, subVal) {\n              // is the property targeting a view?\n              if (/^(month|week|day|default|basic(Week|Day)?|agenda(Week|Day)?)$/.test(subName)) {\n                if (!overrides.views[subName]) {\n                  // ensure the view-target entry exists\n                  overrides.views[subName] = {};\n                }\n\n                overrides.views[subName][name] = subVal; // record the value in the `views` object\n              } else {\n                // a non-View-Option-Hash property\n                if (!subObj) {\n                  subObj = {};\n                }\n\n                subObj[subName] = subVal; // accumulate these unrelated values for later\n              }\n            });\n\n            if (subObj) {\n              // non-View-Option-Hash properties? transfer them as-is\n              overrides[name] = subObj;\n            }\n          } else {\n          overrides[name] = val; // transfer normal options as-is\n        }\n      }\n    });\n    return overrides;\n  }\n\n  ;\n  ; // exports\n\n  FC.intersectRanges = intersectRanges;\n  FC.applyAll = applyAll;\n  FC.debounce = debounce;\n  FC.isInt = isInt;\n  FC.htmlEscape = htmlEscape;\n  FC.cssToStr = cssToStr;\n  FC.proxy = proxy;\n  FC.capitaliseFirstLetter = capitaliseFirstLetter;\n  /* FullCalendar-specific DOM Utilities\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\n  // and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\n\n  function compensateScroll(rowEls, scrollbarWidths) {\n    if (scrollbarWidths.left) {\n      rowEls.css({\n        'border-left-width': 1,\n        'margin-left': scrollbarWidths.left - 1\n      });\n    }\n\n    if (scrollbarWidths.right) {\n      rowEls.css({\n        'border-right-width': 1,\n        'margin-right': scrollbarWidths.right - 1\n      });\n    }\n  } // Undoes compensateScroll and restores all borders/margins\n\n\n  function uncompensateScroll(rowEls) {\n    rowEls.css({\n      'margin-left': '',\n      'margin-right': '',\n      'border-left-width': '',\n      'border-right-width': ''\n    });\n  } // Make the mouse cursor express that an event is not allowed in the current area\n\n\n  function disableCursor() {\n    $('body').addClass('fc-not-allowed');\n  } // Returns the mouse cursor to its original look\n\n\n  function enableCursor() {\n    $('body').removeClass('fc-not-allowed');\n  } // Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\n  // By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\n  // any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and \n  // reduces the available height.\n\n\n  function distributeHeight(els, availableHeight, shouldRedistribute) {\n    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\n    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\n    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\n\n    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\n\n    var flexEls = []; // elements that are allowed to expand. array of DOM nodes\n\n    var flexOffsets = []; // amount of vertical space it takes up\n\n    var flexHeights = []; // actual css height\n\n    var usedHeight = 0;\n    undistributeHeight(els); // give all elements their natural height\n    // find elements that are below the recommended height (expandable).\n    // important to query for heights in a single first pass (to avoid reflow oscillation).\n\n    els.each(function (i, el) {\n      var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\n      var naturalOffset = $(el).outerHeight(true);\n\n      if (naturalOffset < minOffset) {\n        flexEls.push(el);\n        flexOffsets.push(naturalOffset);\n        flexHeights.push($(el).height());\n      } else {\n        // this element stretches past recommended height (non-expandable). mark the space as occupied.\n        usedHeight += naturalOffset;\n      }\n    }); // readjust the recommended height to only consider the height available to non-maxed-out rows.\n\n    if (shouldRedistribute) {\n      availableHeight -= usedHeight;\n      minOffset1 = Math.floor(availableHeight / flexEls.length);\n      minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\n    } // assign heights to all expandable elements\n\n\n    $(flexEls).each(function (i, el) {\n      var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\n      var naturalOffset = flexOffsets[i];\n      var naturalHeight = flexHeights[i];\n      var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\n\n      if (naturalOffset < minOffset) {\n        // we check this again because redistribution might have changed things\n        $(el).height(newHeight);\n      }\n    });\n  } // Undoes distrubuteHeight, restoring all els to their natural height\n\n\n  function undistributeHeight(els) {\n    els.height('');\n  } // Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\n  // cells to be that width.\n  // PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\n\n\n  function matchCellWidths(els) {\n    var maxInnerWidth = 0;\n    els.find('> span').each(function (i, innerEl) {\n      var innerWidth = $(innerEl).outerWidth();\n\n      if (innerWidth > maxInnerWidth) {\n        maxInnerWidth = innerWidth;\n      }\n    });\n    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\n\n    els.width(maxInnerWidth);\n    return maxInnerWidth;\n  } // Given one element that resides inside another,\n  // Subtracts the height of the inner element from the outer element.\n\n\n  function subtractInnerElHeight(outerEl, innerEl) {\n    var both = outerEl.add(innerEl);\n    var diff; // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\n\n    both.css({\n      position: 'relative',\n      // cause a reflow, which will force fresh dimension recalculation\n      left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\n\n    });\n    diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\n\n    both.css({\n      position: '',\n      left: ''\n    }); // undo hack\n\n    return diff;\n  }\n  /* Element Geom Utilities\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n\n  FC.getOuterRect = getOuterRect;\n  FC.getClientRect = getClientRect;\n  FC.getContentRect = getContentRect;\n  FC.getScrollbarWidths = _getScrollbarWidths; // borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\n\n  function getScrollParent(el) {\n    var position = el.css('position'),\n        scrollParent = el.parents().filter(function () {\n      var parent = $(this);\n      return /(auto|scroll)/.test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));\n    }).eq(0);\n    return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\n  } // Queries the outer bounding area of a jQuery element.\n  // Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n  // Origin is optional.\n\n\n  function getOuterRect(el, origin) {\n    var offset = el.offset();\n    var left = offset.left - (origin ? origin.left : 0);\n    var top = offset.top - (origin ? origin.top : 0);\n    return {\n      left: left,\n      right: left + el.outerWidth(),\n      top: top,\n      bottom: top + el.outerHeight()\n    };\n  } // Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\n  // Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n  // Origin is optional.\n  // NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\n\n\n  function getClientRect(el, origin) {\n    var offset = el.offset();\n\n    var scrollbarWidths = _getScrollbarWidths(el);\n\n    var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\n    var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\n    return {\n      left: left,\n      right: left + el[0].clientWidth,\n      // clientWidth includes padding but NOT scrollbars\n      top: top,\n      bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\n\n    };\n  } // Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\n  // Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n  // Origin is optional.\n\n\n  function getContentRect(el, origin) {\n    var offset = el.offset(); // just outside of border, margin not included\n\n    var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') - (origin ? origin.left : 0);\n    var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') - (origin ? origin.top : 0);\n    return {\n      left: left,\n      right: left + el.width(),\n      top: top,\n      bottom: top + el.height()\n    };\n  } // Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\n  // NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\n\n\n  function _getScrollbarWidths(el) {\n    var leftRightWidth = el.innerWidth() - el[0].clientWidth; // the paddings cancel out, leaving the scrollbars\n\n    var widths = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: el.innerHeight() - el[0].clientHeight // the paddings cancel out, leaving the bottom scrollbar\n\n    };\n\n    if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') {\n      // is the scrollbar on the left side?\n      widths.left = leftRightWidth;\n    } else {\n      widths.right = leftRightWidth;\n    }\n\n    return widths;\n  } // Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\n\n\n  var _isLeftRtlScrollbars = null;\n\n  function getIsLeftRtlScrollbars() {\n    // responsible for caching the computation\n    if (_isLeftRtlScrollbars === null) {\n      _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\n    }\n\n    return _isLeftRtlScrollbars;\n  }\n\n  function computeIsLeftRtlScrollbars() {\n    // creates an offscreen test element, then removes it\n    var el = $('<div><div/></div>').css({\n      position: 'absolute',\n      top: -1000,\n      left: 0,\n      border: 0,\n      padding: 0,\n      overflow: 'scroll',\n      direction: 'rtl'\n    }).appendTo('body');\n    var innerEl = el.children();\n    var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\n\n    el.remove();\n    return res;\n  } // Retrieves a jQuery element's computed CSS value as a floating-point number.\n  // If the queried value is non-numeric (ex: IE can return \"medium\" for border width), will just return zero.\n\n\n  function getCssFloat(el, prop) {\n    return parseFloat(el.css(prop)) || 0;\n  }\n  /* Mouse / Touch Utilities\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n\n  FC.preventDefault = preventDefault; // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n\n  function isPrimaryMouseButton(ev) {\n    return ev.which == 1 && !ev.ctrlKey;\n  }\n\n  function getEvX(ev) {\n    if (ev.pageX !== undefined) {\n      return ev.pageX;\n    }\n\n    var touches = ev.originalEvent.touches;\n\n    if (touches) {\n      return touches[0].pageX;\n    }\n  }\n\n  function getEvY(ev) {\n    if (ev.pageY !== undefined) {\n      return ev.pageY;\n    }\n\n    var touches = ev.originalEvent.touches;\n\n    if (touches) {\n      return touches[0].pageY;\n    }\n  }\n\n  function getEvIsTouch(ev) {\n    return /^touch/.test(ev.type);\n  }\n\n  function preventSelection(el) {\n    el.addClass('fc-unselectable').on('selectstart', preventDefault);\n  } // Stops a mouse/touch event from doing it's native browser action\n\n\n  function preventDefault(ev) {\n    ev.preventDefault();\n  } // attach a handler to get called when ANY scroll action happens on the page.\n  // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n  // http://stackoverflow.com/a/32954565/96342\n  // returns `true` on success.\n\n\n  function bindAnyScroll(handler) {\n    if (window.addEventListener) {\n      window.addEventListener('scroll', handler, true); // useCapture=true\n\n      return true;\n    }\n\n    return false;\n  } // undoes bindAnyScroll. must pass in the original function.\n  // returns `true` on success.\n\n\n  function unbindAnyScroll(handler) {\n    if (window.removeEventListener) {\n      window.removeEventListener('scroll', handler, true); // useCapture=true\n\n      return true;\n    }\n\n    return false;\n  }\n  /* General Geometry Utils\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n\n  FC.intersectRects = intersectRects; // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n\n  function intersectRects(rect1, rect2) {\n    var res = {\n      left: Math.max(rect1.left, rect2.left),\n      right: Math.min(rect1.right, rect2.right),\n      top: Math.max(rect1.top, rect2.top),\n      bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n\n    if (res.left < res.right && res.top < res.bottom) {\n      return res;\n    }\n\n    return false;\n  } // Returns a new point that will have been moved to reside within the given rectangle\n\n\n  function constrainPoint(point, rect) {\n    return {\n      left: Math.min(Math.max(point.left, rect.left), rect.right),\n      top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n    };\n  } // Returns a point that is the center of the given rectangle\n\n\n  function getRectCenter(rect) {\n    return {\n      left: (rect.left + rect.right) / 2,\n      top: (rect.top + rect.bottom) / 2\n    };\n  } // Subtracts point2's coordinates from point1's coordinates, returning a delta\n\n\n  function diffPoints(point1, point2) {\n    return {\n      left: point1.left - point2.left,\n      top: point1.top - point2.top\n    };\n  }\n  /* Object Ordering by Field\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n\n  FC.parseFieldSpecs = parseFieldSpecs;\n  FC.compareByFieldSpecs = compareByFieldSpecs;\n  FC.compareByFieldSpec = compareByFieldSpec;\n  FC.flexibleCompare = flexibleCompare;\n\n  function parseFieldSpecs(input) {\n    var specs = [];\n    var tokens = [];\n    var i, token;\n\n    if (typeof input === 'string') {\n      tokens = input.split(/\\s*,\\s*/);\n    } else if (typeof input === 'function') {\n      tokens = [input];\n    } else if ($.isArray(input)) {\n      tokens = input;\n    }\n\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n\n      if (typeof token === 'string') {\n        specs.push(token.charAt(0) == '-' ? {\n          field: token.substring(1),\n          order: -1\n        } : {\n          field: token,\n          order: 1\n        });\n      } else if (typeof token === 'function') {\n        specs.push({\n          func: token\n        });\n      }\n    }\n\n    return specs;\n  }\n\n  function compareByFieldSpecs(obj1, obj2, fieldSpecs) {\n    var i;\n    var cmp;\n\n    for (i = 0; i < fieldSpecs.length; i++) {\n      cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);\n\n      if (cmp) {\n        return cmp;\n      }\n    }\n\n    return 0;\n  }\n\n  function compareByFieldSpec(obj1, obj2, fieldSpec) {\n    if (fieldSpec.func) {\n      return fieldSpec.func(obj1, obj2);\n    }\n\n    return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) * (fieldSpec.order || 1);\n  }\n\n  function flexibleCompare(a, b) {\n    if (!a && !b) {\n      return 0;\n    }\n\n    if (b == null) {\n      return -1;\n    }\n\n    if (a == null) {\n      return 1;\n    }\n\n    if ($.type(a) === 'string' || $.type(b) === 'string') {\n      return String(a).localeCompare(String(b));\n    }\n\n    return a - b;\n  }\n  /* FullCalendar-specific Misc Utilities\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // Computes the intersection of the two ranges. Returns undefined if no intersection.\n  // Expects all dates to be normalized to the same timezone beforehand.\n  // TODO: move to date section?\n\n\n  function intersectRanges(subjectRange, constraintRange) {\n    var subjectStart = subjectRange.start;\n    var subjectEnd = subjectRange.end;\n    var constraintStart = constraintRange.start;\n    var constraintEnd = constraintRange.end;\n    var segStart, segEnd;\n    var isStart, isEnd;\n\n    if (subjectEnd > constraintStart && subjectStart < constraintEnd) {\n      // in bounds at all?\n      if (subjectStart >= constraintStart) {\n        segStart = subjectStart.clone();\n        isStart = true;\n      } else {\n        segStart = constraintStart.clone();\n        isStart = false;\n      }\n\n      if (subjectEnd <= constraintEnd) {\n        segEnd = subjectEnd.clone();\n        isEnd = true;\n      } else {\n        segEnd = constraintEnd.clone();\n        isEnd = false;\n      }\n\n      return {\n        start: segStart,\n        end: segEnd,\n        isStart: isStart,\n        isEnd: isEnd\n      };\n    }\n  }\n  /* Date Utilities\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n\n  FC.computeIntervalUnit = computeIntervalUnit;\n  FC.divideRangeByDuration = divideRangeByDuration;\n  FC.divideDurationByDuration = divideDurationByDuration;\n  FC.multiplyDuration = multiplyDuration;\n  FC.durationHasTime = durationHasTime;\n  var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\n  var intervalUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\n  // Moments will have their timezones normalized.\n\n  function diffDayTime(a, b) {\n    return moment.duration({\n      days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\n      ms: a.time() - b.time() // time-of-day from day start. disregards timezone\n\n    });\n  } // Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\n\n\n  function diffDay(a, b) {\n    return moment.duration({\n      days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\n    });\n  } // Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\n\n\n  function diffByUnit(a, b, unit) {\n    return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true\n    unit);\n  } // Computes the unit name of the largest whole-unit period of time.\n  // For example, 48 hours will be \"days\" whereas 49 hours will be \"hours\".\n  // Accepts start/end, a range object, or an original duration object.\n\n\n  function computeIntervalUnit(start, end) {\n    var i, unit;\n    var val;\n\n    for (i = 0; i < intervalUnits.length; i++) {\n      unit = intervalUnits[i];\n      val = computeRangeAs(unit, start, end);\n\n      if (val >= 1 && isInt(val)) {\n        break;\n      }\n    }\n\n    return unit; // will be \"milliseconds\" if nothing else matches\n  } // Computes the number of units (like \"hours\") in the given range.\n  // Range can be a {start,end} object, separate start/end args, or a Duration.\n  // Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\n  // of month-diffing logic (which tends to vary from version to version).\n\n\n  function computeRangeAs(unit, start, end) {\n    if (end != null) {\n      // given start, end\n      return end.diff(start, unit, true);\n    } else if (moment.isDuration(start)) {\n      // given duration\n      return start.as(unit);\n    } else {\n      // given { start, end } range object\n      return start.end.diff(start.start, unit, true);\n    }\n  } // Intelligently divides a range (specified by a start/end params) by a duration\n\n\n  function divideRangeByDuration(start, end, dur) {\n    var months;\n\n    if (durationHasTime(dur)) {\n      return (end - start) / dur;\n    }\n\n    months = dur.asMonths();\n\n    if (Math.abs(months) >= 1 && isInt(months)) {\n      return end.diff(start, 'months', true) / months;\n    }\n\n    return end.diff(start, 'days', true) / dur.asDays();\n  } // Intelligently divides one duration by another\n\n\n  function divideDurationByDuration(dur1, dur2) {\n    var months1, months2;\n\n    if (durationHasTime(dur1) || durationHasTime(dur2)) {\n      return dur1 / dur2;\n    }\n\n    months1 = dur1.asMonths();\n    months2 = dur2.asMonths();\n\n    if (Math.abs(months1) >= 1 && isInt(months1) && Math.abs(months2) >= 1 && isInt(months2)) {\n      return months1 / months2;\n    }\n\n    return dur1.asDays() / dur2.asDays();\n  } // Intelligently multiplies a duration by a number\n\n\n  function multiplyDuration(dur, n) {\n    var months;\n\n    if (durationHasTime(dur)) {\n      return moment.duration(dur * n);\n    }\n\n    months = dur.asMonths();\n\n    if (Math.abs(months) >= 1 && isInt(months)) {\n      return moment.duration({\n        months: months * n\n      });\n    }\n\n    return moment.duration({\n      days: dur.asDays() * n\n    });\n  } // Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\n\n\n  function durationHasTime(dur) {\n    return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\n  }\n\n  function isNativeDate(input) {\n    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\n  } // Returns a boolean about whether the given input is a time string, like \"06:40:00\" or \"06:00\"\n\n\n  function isTimeString(str) {\n    return /^\\d+\\:\\d+(?:\\:\\d+\\.?(?:\\d{3})?)?$/.test(str);\n  }\n  /* Logging and Debug\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n\n  FC.log = function () {\n    var console = window.console;\n\n    if (console && console.log) {\n      return console.log.apply(console, arguments);\n    }\n  };\n\n  FC.warn = function () {\n    var console = window.console;\n\n    if (console && console.warn) {\n      return console.warn.apply(console, arguments);\n    } else {\n      return FC.log.apply(FC, arguments);\n    }\n  };\n  /* General Utilities\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n\n  var hasOwnPropMethod = {}.hasOwnProperty; // Merges an array of objects into a single object.\n  // The second argument allows for an array of property names who's object values will be merged together.\n\n  function mergeProps(propObjs, complexProps) {\n    var dest = {};\n    var i, name;\n    var complexObjs;\n    var j, val;\n    var props;\n\n    if (complexProps) {\n      for (i = 0; i < complexProps.length; i++) {\n        name = complexProps[i];\n        complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered\n\n        for (j = propObjs.length - 1; j >= 0; j--) {\n          val = propObjs[j][name];\n\n          if (typeof val === 'object') {\n            complexObjs.unshift(val);\n          } else if (val !== undefined) {\n            dest[name] = val; // if there were no objects, this value will be used\n\n            break;\n          }\n        } // if the trailing values were objects, use the merged value\n\n\n        if (complexObjs.length) {\n          dest[name] = mergeProps(complexObjs);\n        }\n      }\n    } // copy values into the destination, going from last to first\n\n\n    for (i = propObjs.length - 1; i >= 0; i--) {\n      props = propObjs[i];\n\n      for (name in props) {\n        if (!(name in dest)) {\n          // if already assigned by previous props or complex props, don't reassign\n          dest[name] = props[name];\n        }\n      }\n    }\n\n    return dest;\n  } // Create an object that has the given prototype. Just like Object.create\n\n\n  function createObject(proto) {\n    var f = function f() {};\n\n    f.prototype = proto;\n    return new f();\n  }\n\n  function copyOwnProps(src, dest) {\n    for (var name in src) {\n      if (hasOwnProp(src, name)) {\n        dest[name] = src[name];\n      }\n    }\n  } // Copies over certain methods with the same names as Object.prototype methods. Overcomes an IE<=8 bug:\n  // https://developer.mozilla.org/en-US/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\n\n\n  function copyNativeMethods(src, dest) {\n    var names = ['constructor', 'toString', 'valueOf'];\n    var i, name;\n\n    for (i = 0; i < names.length; i++) {\n      name = names[i];\n\n      if (src[name] !== Object.prototype[name]) {\n        dest[name] = src[name];\n      }\n    }\n  }\n\n  function hasOwnProp(obj, name) {\n    return hasOwnPropMethod.call(obj, name);\n  } // Is the given value a non-object non-function value?\n\n\n  function isAtomic(val) {\n    return /undefined|null|boolean|number|string/.test($.type(val));\n  }\n\n  function applyAll(functions, thisObj, args) {\n    if ($.isFunction(functions)) {\n      functions = [functions];\n    }\n\n    if (functions) {\n      var i;\n      var ret;\n\n      for (i = 0; i < functions.length; i++) {\n        ret = functions[i].apply(thisObj, args) || ret;\n      }\n\n      return ret;\n    }\n  }\n\n  function firstDefined() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (arguments[i] !== undefined) {\n        return arguments[i];\n      }\n    }\n  }\n\n  function htmlEscape(s) {\n    return (s + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&#039;').replace(/\"/g, '&quot;').replace(/\\n/g, '<br />');\n  }\n\n  function stripHtmlEntities(text) {\n    return text.replace(/&.*?;/g, '');\n  } // Given a hash of CSS properties, returns a string of CSS.\n  // Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\n\n\n  function cssToStr(cssProps) {\n    var statements = [];\n    $.each(cssProps, function (name, val) {\n      if (val != null) {\n        statements.push(name + ':' + val);\n      }\n    });\n    return statements.join(';');\n  }\n\n  function capitaliseFirstLetter(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function compareNumbers(a, b) {\n    // for .sort()\n    return a - b;\n  }\n\n  function isInt(n) {\n    return n % 1 === 0;\n  } // Returns a method bound to the given object context.\n  // Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\n  // different contexts as identical when binding/unbinding events.\n\n\n  function proxy(obj, methodName) {\n    var method = obj[methodName];\n    return function () {\n      return method.apply(obj, arguments);\n    };\n  } // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  // https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\n\n\n  function debounce(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function later() {\n      var last = +new Date() - timestamp;\n\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function () {\n      context = this;\n      args = arguments;\n      timestamp = +new Date();\n      var callNow = immediate && !timeout;\n\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  } // HACK around jQuery's now A+ promises: execute callback synchronously if already resolved.\n  // thenFunc shouldn't accept args.\n  // similar to whenResources in Scheduler plugin.\n\n\n  function syncThen(promise, thenFunc) {\n    // not a promise, or an already-resolved promise?\n    if (!promise || !promise.then || promise.state() === 'resolved') {\n      return $.when(thenFunc()); // resolve immediately\n    } else if (thenFunc) {\n      return promise.then(thenFunc);\n    }\n  }\n\n  ;\n  ;\n  var ambigDateOfMonthRegex = /^\\s*\\d{4}-\\d\\d$/;\n  var ambigTimeOrZoneRegex = /^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?)?$/;\n  var newMomentProto = moment.fn; // where we will attach our new methods\n\n  var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\n\n  var allowValueOptimization;\n  var setUTCValues; // function defined below\n\n  var setLocalValues; // function defined below\n  // Creating\n  // -------------------------------------------------------------------------------------------------\n  // Creates a new moment, similar to the vanilla moment(...) constructor, but with\n  // extra features (ambiguous time, enhanced formatting). When given an existing moment,\n  // it will function as a clone (and retain the zone of the moment). Anything else will\n  // result in a moment in the local zone.\n\n  FC.moment = function () {\n    return makeMoment(arguments);\n  }; // Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.\n\n\n  FC.moment.utc = function () {\n    var mom = makeMoment(arguments, true); // Force it into UTC because makeMoment doesn't guarantee it\n    // (if given a pre-existing moment for example)\n\n    if (mom.hasTime()) {\n      // don't give ambiguously-timed moments a UTC zone\n      mom.utc();\n    }\n\n    return mom;\n  }; // Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.\n  // ISO8601 strings with no timezone offset will become ambiguously zoned.\n\n\n  FC.moment.parseZone = function () {\n    return makeMoment(arguments, true, true);\n  }; // Builds an enhanced moment from args. When given an existing moment, it clones. When given a\n  // native Date, or called with no arguments (the current time), the resulting moment will be local.\n  // Anything else needs to be \"parsed\" (a string or an array), and will be affected by:\n  //    parseAsUTC - if there is no zone information, should we parse the input in UTC?\n  //    parseZone - if there is zone information, should we force the zone of the moment?\n\n\n  function makeMoment(args, parseAsUTC, parseZone) {\n    var input = args[0];\n    var isSingleString = args.length == 1 && typeof input === 'string';\n    var isAmbigTime;\n    var isAmbigZone;\n    var ambigMatch;\n    var mom;\n\n    if (moment.isMoment(input)) {\n      mom = moment.apply(null, args); // clone it\n\n      transferAmbigs(input, mom); // the ambig flags weren't transfered with the clone\n    } else if (isNativeDate(input) || input === undefined) {\n      mom = moment.apply(null, args); // will be local\n    } else {\n      // \"parsing\" is required\n      isAmbigTime = false;\n      isAmbigZone = false;\n\n      if (isSingleString) {\n        if (ambigDateOfMonthRegex.test(input)) {\n          // accept strings like '2014-05', but convert to the first of the month\n          input += '-01';\n          args = [input]; // for when we pass it on to moment's constructor\n\n          isAmbigTime = true;\n          isAmbigZone = true;\n        } else if (ambigMatch = ambigTimeOrZoneRegex.exec(input)) {\n          isAmbigTime = !ambigMatch[5]; // no time part?\n\n          isAmbigZone = true;\n        }\n      } else if ($.isArray(input)) {\n        // arrays have no timezone information, so assume ambiguous zone\n        isAmbigZone = true;\n      } // otherwise, probably a string with a format\n\n\n      if (parseAsUTC || isAmbigTime) {\n        mom = moment.utc.apply(moment, args);\n      } else {\n        mom = moment.apply(null, args);\n      }\n\n      if (isAmbigTime) {\n        mom._ambigTime = true;\n        mom._ambigZone = true; // ambiguous time always means ambiguous zone\n      } else if (parseZone) {\n        // let's record the inputted zone somehow\n        if (isAmbigZone) {\n          mom._ambigZone = true;\n        } else if (isSingleString) {\n          if (mom.utcOffset) {\n            mom.utcOffset(input); // if not a valid zone, will assign UTC\n          } else {\n            mom.zone(input); // for moment-pre-2.9\n          }\n        }\n      }\n    }\n\n    mom._fullCalendar = true; // flag for extended functionality\n\n    return mom;\n  } // A clone method that works with the flags related to our enhanced functionality.\n  // In the future, use moment.momentProperties\n\n\n  newMomentProto.clone = function () {\n    var mom = oldMomentProto.clone.apply(this, arguments); // these flags weren't transfered with the clone\n\n    transferAmbigs(this, mom);\n\n    if (this._fullCalendar) {\n      mom._fullCalendar = true;\n    }\n\n    return mom;\n  }; // Week Number\n  // -------------------------------------------------------------------------------------------------\n  // Returns the week number, considering the locale's custom week number calcuation\n  // `weeks` is an alias for `week`\n\n\n  newMomentProto.week = newMomentProto.weeks = function (input) {\n    var weekCalc = (this._locale || this._lang). // works pre-moment-2.8\n    _fullCalendar_weekCalc;\n\n    if (input == null && typeof weekCalc === 'function') {\n      // custom function only works for getter\n      return weekCalc(this);\n    } else if (weekCalc === 'ISO') {\n      return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\n    }\n\n    return oldMomentProto.week.apply(this, arguments); // local getter/setter\n  }; // Time-of-day\n  // -------------------------------------------------------------------------------------------------\n  // GETTER\n  // Returns a Duration with the hours/minutes/seconds/ms values of the moment.\n  // If the moment has an ambiguous time, a duration of 00:00 will be returned.\n  //\n  // SETTER\n  // You can supply a Duration, a Moment, or a Duration-like argument.\n  // When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\n\n\n  newMomentProto.time = function (time) {\n    // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\n    // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\n    if (!this._fullCalendar) {\n      return oldMomentProto.time.apply(this, arguments);\n    }\n\n    if (time == null) {\n      // getter\n      return moment.duration({\n        hours: this.hours(),\n        minutes: this.minutes(),\n        seconds: this.seconds(),\n        milliseconds: this.milliseconds()\n      });\n    } else {\n      // setter\n      this._ambigTime = false; // mark that the moment now has a time\n\n      if (!moment.isDuration(time) && !moment.isMoment(time)) {\n        time = moment.duration(time);\n      } // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\n      // Only for Duration times, not Moment times.\n\n\n      var dayHours = 0;\n\n      if (moment.isDuration(time)) {\n        dayHours = Math.floor(time.asDays()) * 24;\n      } // We need to set the individual fields.\n      // Can't use startOf('day') then add duration. In case of DST at start of day.\n\n\n      return this.hours(dayHours + time.hours()).minutes(time.minutes()).seconds(time.seconds()).milliseconds(time.milliseconds());\n    }\n  }; // Converts the moment to UTC, stripping out its time-of-day and timezone offset,\n  // but preserving its YMD. A moment with a stripped time will display no time\n  // nor timezone offset when .format() is called.\n\n\n  newMomentProto.stripTime = function () {\n    var a;\n\n    if (!this._ambigTime) {\n      // get the values before any conversion happens\n      a = this.toArray(); // array of y/m/d/h/m/s/ms\n      // TODO: use keepLocalTime in the future\n\n      this.utc(); // set the internal UTC flag (will clear the ambig flags)\n\n      setUTCValues(this, a.slice(0, 3)); // set the year/month/date. time will be zero\n      // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n      // which clears all ambig flags. Same with setUTCValues with moment-timezone.\n\n      this._ambigTime = true;\n      this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\n    }\n\n    return this; // for chaining\n  }; // Returns if the moment has a non-ambiguous time (boolean)\n\n\n  newMomentProto.hasTime = function () {\n    return !this._ambigTime;\n  }; // Timezone\n  // -------------------------------------------------------------------------------------------------\n  // Converts the moment to UTC, stripping out its timezone offset, but preserving its\n  // YMD and time-of-day. A moment with a stripped timezone offset will display no\n  // timezone offset when .format() is called.\n  // TODO: look into Moment's keepLocalTime functionality\n\n\n  newMomentProto.stripZone = function () {\n    var a, wasAmbigTime;\n\n    if (!this._ambigZone) {\n      // get the values before any conversion happens\n      a = this.toArray(); // array of y/m/d/h/m/s/ms\n\n      wasAmbigTime = this._ambigTime;\n      this.utc(); // set the internal UTC flag (might clear the ambig flags, depending on Moment internals)\n\n      setUTCValues(this, a); // will set the year/month/date/hours/minutes/seconds/ms\n      // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\n\n      this._ambigTime = wasAmbigTime || false; // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n      // which clears the ambig flags. Same with setUTCValues with moment-timezone.\n\n      this._ambigZone = true;\n    }\n\n    return this; // for chaining\n  }; // Returns of the moment has a non-ambiguous timezone offset (boolean)\n\n\n  newMomentProto.hasZone = function () {\n    return !this._ambigZone;\n  }; // this method implicitly marks a zone\n\n\n  newMomentProto.local = function () {\n    var a = this.toArray(); // year,month,date,hours,minutes,seconds,ms as an array\n\n    var wasAmbigZone = this._ambigZone;\n    oldMomentProto.local.apply(this, arguments); // ensure non-ambiguous\n    // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\n\n    this._ambigTime = false;\n    this._ambigZone = false;\n\n    if (wasAmbigZone) {\n      // If the moment was ambiguously zoned, the date fields were stored as UTC.\n      // We want to preserve these, but in local time.\n      // TODO: look into Moment's keepLocalTime functionality\n      setLocalValues(this, a);\n    }\n\n    return this; // for chaining\n  }; // implicitly marks a zone\n\n\n  newMomentProto.utc = function () {\n    oldMomentProto.utc.apply(this, arguments); // ensure non-ambiguous\n    // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\n\n    this._ambigTime = false;\n    this._ambigZone = false;\n    return this;\n  }; // methods for arbitrarily manipulating timezone offset.\n  // should clear time/zone ambiguity when called.\n\n\n  $.each(['zone', // only in moment-pre-2.9. deprecated afterwards\n  'utcOffset'], function (i, name) {\n    if (oldMomentProto[name]) {\n      // original method exists?\n      // this method implicitly marks a zone (will probably get called upon .utc() and .local())\n      newMomentProto[name] = function (tzo) {\n        if (tzo != null) {\n          // setter\n          // these assignments needs to happen before the original zone method is called.\n          // I forget why, something to do with a browser crash.\n          this._ambigTime = false;\n          this._ambigZone = false;\n        }\n\n        return oldMomentProto[name].apply(this, arguments);\n      };\n    }\n  }); // Formatting\n  // -------------------------------------------------------------------------------------------------\n\n  newMomentProto.format = function () {\n    if (this._fullCalendar && arguments[0]) {\n      // an enhanced moment? and a format string provided?\n      return formatDate(this, arguments[0]); // our extended formatting\n    }\n\n    if (this._ambigTime) {\n      return oldMomentFormat(this, 'YYYY-MM-DD');\n    }\n\n    if (this._ambigZone) {\n      return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');\n    }\n\n    return oldMomentProto.format.apply(this, arguments);\n  };\n\n  newMomentProto.toISOString = function () {\n    if (this._ambigTime) {\n      return oldMomentFormat(this, 'YYYY-MM-DD');\n    }\n\n    if (this._ambigZone) {\n      return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');\n    }\n\n    return oldMomentProto.toISOString.apply(this, arguments);\n  }; // Querying\n  // -------------------------------------------------------------------------------------------------\n  // Is the moment within the specified range? `end` is exclusive.\n  // FYI, this method is not a standard Moment method, so always do our enhanced logic.\n\n\n  newMomentProto.isWithin = function (start, end) {\n    var a = commonlyAmbiguate([this, start, end]);\n    return a[0] >= a[1] && a[0] < a[2];\n  }; // When isSame is called with units, timezone ambiguity is normalized before the comparison happens.\n  // If no units specified, the two moments must be identically the same, with matching ambig flags.\n\n\n  newMomentProto.isSame = function (input, units) {\n    var a; // only do custom logic if this is an enhanced moment\n\n    if (!this._fullCalendar) {\n      return oldMomentProto.isSame.apply(this, arguments);\n    }\n\n    if (units) {\n      a = commonlyAmbiguate([this, input], true); // normalize timezones but don't erase times\n\n      return oldMomentProto.isSame.call(a[0], a[1], units);\n    } else {\n      input = FC.moment.parseZone(input); // normalize input\n\n      return oldMomentProto.isSame.call(this, input) && Boolean(this._ambigTime) === Boolean(input._ambigTime) && Boolean(this._ambigZone) === Boolean(input._ambigZone);\n    }\n  }; // Make these query methods work with ambiguous moments\n\n\n  $.each(['isBefore', 'isAfter'], function (i, methodName) {\n    newMomentProto[methodName] = function (input, units) {\n      var a; // only do custom logic if this is an enhanced moment\n\n      if (!this._fullCalendar) {\n        return oldMomentProto[methodName].apply(this, arguments);\n      }\n\n      a = commonlyAmbiguate([this, input]);\n      return oldMomentProto[methodName].call(a[0], a[1], units);\n    };\n  }); // Misc Internals\n  // -------------------------------------------------------------------------------------------------\n  // given an array of moment-like inputs, return a parallel array w/ moments similarly ambiguated.\n  // for example, of one moment has ambig time, but not others, all moments will have their time stripped.\n  // set `preserveTime` to `true` to keep times, but only normalize zone ambiguity.\n  // returns the original moments if no modifications are necessary.\n\n  function commonlyAmbiguate(inputs, preserveTime) {\n    var anyAmbigTime = false;\n    var anyAmbigZone = false;\n    var len = inputs.length;\n    var moms = [];\n    var i, mom; // parse inputs into real moments and query their ambig flags\n\n    for (i = 0; i < len; i++) {\n      mom = inputs[i];\n\n      if (!moment.isMoment(mom)) {\n        mom = FC.moment.parseZone(mom);\n      }\n\n      anyAmbigTime = anyAmbigTime || mom._ambigTime;\n      anyAmbigZone = anyAmbigZone || mom._ambigZone;\n      moms.push(mom);\n    } // strip each moment down to lowest common ambiguity\n    // use clones to avoid modifying the original moments\n\n\n    for (i = 0; i < len; i++) {\n      mom = moms[i];\n\n      if (!preserveTime && anyAmbigTime && !mom._ambigTime) {\n        moms[i] = mom.clone().stripTime();\n      } else if (anyAmbigZone && !mom._ambigZone) {\n        moms[i] = mom.clone().stripZone();\n      }\n    }\n\n    return moms;\n  } // Transfers all the flags related to ambiguous time/zone from the `src` moment to the `dest` moment\n  // TODO: look into moment.momentProperties for this.\n\n\n  function transferAmbigs(src, dest) {\n    if (src._ambigTime) {\n      dest._ambigTime = true;\n    } else if (dest._ambigTime) {\n      dest._ambigTime = false;\n    }\n\n    if (src._ambigZone) {\n      dest._ambigZone = true;\n    } else if (dest._ambigZone) {\n      dest._ambigZone = false;\n    }\n  } // Sets the year/month/date/etc values of the moment from the given array.\n  // Inefficient because it calls each individual setter.\n\n\n  function setMomentValues(mom, a) {\n    mom.year(a[0] || 0).month(a[1] || 0).date(a[2] || 0).hours(a[3] || 0).minutes(a[4] || 0).seconds(a[5] || 0).milliseconds(a[6] || 0);\n  } // Can we set the moment's internal date directly?\n\n\n  allowValueOptimization = '_d' in moment() && 'updateOffset' in moment; // Utility function. Accepts a moment and an array of the UTC year/month/date/etc values to set.\n  // Assumes the given moment is already in UTC mode.\n\n  setUTCValues = allowValueOptimization ? function (mom, a) {\n    // simlate what moment's accessors do\n    mom._d.setTime(Date.UTC.apply(Date, a));\n\n    moment.updateOffset(mom, false); // keepTime=false\n  } : setMomentValues; // Utility function. Accepts a moment and an array of the local year/month/date/etc values to set.\n  // Assumes the given moment is already in local mode.\n\n  setLocalValues = allowValueOptimization ? function (mom, a) {\n    // simlate what moment's accessors do\n    mom._d.setTime(+new Date( // FYI, there is now way to apply an array of args to a constructor\n    a[0] || 0, a[1] || 0, a[2] || 0, a[3] || 0, a[4] || 0, a[5] || 0, a[6] || 0));\n\n    moment.updateOffset(mom, false); // keepTime=false\n  } : setMomentValues;\n  ;\n  ; // Single Date Formatting\n  // -------------------------------------------------------------------------------------------------\n  // call this if you want Moment's original format method to be used\n\n  function oldMomentFormat(mom, formatStr) {\n    return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\n  } // Formats `date` with a Moment formatting string, but allow our non-zero areas and\n  // additional token.\n\n\n  function formatDate(date, formatStr) {\n    return formatDateWithChunks(date, getFormatStringChunks(formatStr));\n  }\n\n  function formatDateWithChunks(date, chunks) {\n    var s = '';\n    var i;\n\n    for (i = 0; i < chunks.length; i++) {\n      s += formatDateWithChunk(date, chunks[i]);\n    }\n\n    return s;\n  } // addition formatting tokens we want recognized\n\n\n  var tokenOverrides = {\n    t: function t(date) {\n      // \"a\" or \"p\"\n      return oldMomentFormat(date, 'a').charAt(0);\n    },\n    T: function T(date) {\n      // \"A\" or \"P\"\n      return oldMomentFormat(date, 'A').charAt(0);\n    }\n  };\n\n  function formatDateWithChunk(date, chunk) {\n    var token;\n    var maybeStr;\n\n    if (typeof chunk === 'string') {\n      // a literal string\n      return chunk;\n    } else if (token = chunk.token) {\n      // a token, like \"YYYY\"\n      if (tokenOverrides[token]) {\n        return tokenOverrides[token](date); // use our custom token\n      }\n\n      return oldMomentFormat(date, token);\n    } else if (chunk.maybe) {\n      // a grouping of other chunks that must be non-zero\n      maybeStr = formatDateWithChunks(date, chunk.maybe);\n\n      if (maybeStr.match(/[1-9]/)) {\n        return maybeStr;\n      }\n    }\n\n    return '';\n  } // Date Range Formatting\n  // -------------------------------------------------------------------------------------------------\n  // TODO: make it work with timezone offset\n  // Using a formatting string meant for a single date, generate a range string, like\n  // \"Sep 2 - 9 2013\", that intelligently inserts a separator where the dates differ.\n  // If the dates are the same as far as the format string is concerned, just return a single\n  // rendering of one date, without any separator.\n\n\n  function _formatRange(date1, date2, formatStr, separator, isRTL) {\n    var localeData;\n    date1 = FC.moment.parseZone(date1);\n    date2 = FC.moment.parseZone(date2);\n    localeData = (date1.localeData || date1.lang).call(date1); // works with moment-pre-2.8\n    // Expand localized format strings, like \"LL\" -> \"MMMM D YYYY\"\n\n    formatStr = localeData.longDateFormat(formatStr) || formatStr; // BTW, this is not important for `formatDate` because it is impossible to put custom tokens\n    // or non-zero areas in Moment's localized format strings.\n\n    separator = separator || ' - ';\n    return formatRangeWithChunks(date1, date2, getFormatStringChunks(formatStr), separator, isRTL);\n  }\n\n  FC.formatRange = _formatRange; // expose\n\n  function formatRangeWithChunks(date1, date2, chunks, separator, isRTL) {\n    var unzonedDate1 = date1.clone().stripZone(); // for formatSimilarChunk\n\n    var unzonedDate2 = date2.clone().stripZone(); // \"\n\n    var chunkStr; // the rendering of the chunk\n\n    var leftI;\n    var leftStr = '';\n    var rightI;\n    var rightStr = '';\n    var middleI;\n    var middleStr1 = '';\n    var middleStr2 = '';\n    var middleStr = ''; // Start at the leftmost side of the formatting string and continue until you hit a token\n    // that is not the same between dates.\n\n    for (leftI = 0; leftI < chunks.length; leftI++) {\n      chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[leftI]);\n\n      if (chunkStr === false) {\n        break;\n      }\n\n      leftStr += chunkStr;\n    } // Similarly, start at the rightmost side of the formatting string and move left\n\n\n    for (rightI = chunks.length - 1; rightI > leftI; rightI--) {\n      chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[rightI]);\n\n      if (chunkStr === false) {\n        break;\n      }\n\n      rightStr = chunkStr + rightStr;\n    } // The area in the middle is different for both of the dates.\n    // Collect them distinctly so we can jam them together later.\n\n\n    for (middleI = leftI; middleI <= rightI; middleI++) {\n      middleStr1 += formatDateWithChunk(date1, chunks[middleI]);\n      middleStr2 += formatDateWithChunk(date2, chunks[middleI]);\n    }\n\n    if (middleStr1 || middleStr2) {\n      if (isRTL) {\n        middleStr = middleStr2 + separator + middleStr1;\n      } else {\n        middleStr = middleStr1 + separator + middleStr2;\n      }\n    }\n\n    return leftStr + middleStr + rightStr;\n  }\n\n  var similarUnitMap = {\n    Y: 'year',\n    M: 'month',\n    D: 'day',\n    // day of month\n    d: 'day',\n    // day of week\n    // prevents a separator between anything time-related...\n    A: 'second',\n    // AM/PM\n    a: 'second',\n    // am/pm\n    T: 'second',\n    // A/P\n    t: 'second',\n    // a/p\n    H: 'second',\n    // hour (24)\n    h: 'second',\n    // hour (12)\n    m: 'second',\n    // minute\n    s: 'second' // second\n\n  }; // TODO: week maybe?\n  // Given a formatting chunk, and given that both dates are similar in the regard the\n  // formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.\n\n  function formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunk) {\n    var token;\n    var unit;\n\n    if (typeof chunk === 'string') {\n      // a literal string\n      return chunk;\n    } else if (token = chunk.token) {\n      unit = similarUnitMap[token.charAt(0)]; // are the dates the same for this unit of measurement?\n      // use the unzoned dates for this calculation because unreliable when near DST (bug #2396)\n\n      if (unit && unzonedDate1.isSame(unzonedDate2, unit)) {\n        return oldMomentFormat(date1, token); // would be the same if we used `date2`\n        // BTW, don't support custom tokens\n      }\n    }\n\n    return false; // the chunk is NOT the same for the two dates\n    // BTW, don't support splitting on non-zero areas\n  } // Chunking Utils\n  // -------------------------------------------------------------------------------------------------\n\n\n  var formatStringChunkCache = {};\n\n  function getFormatStringChunks(formatStr) {\n    if (formatStr in formatStringChunkCache) {\n      return formatStringChunkCache[formatStr];\n    }\n\n    return formatStringChunkCache[formatStr] = chunkFormatString(formatStr);\n  } // Break the formatting string into an array of chunks\n\n\n  function chunkFormatString(formatStr) {\n    var chunks = [];\n    var chunker = /\\[([^\\]]*)\\]|\\(([^\\)]*)\\)|(LTS|LT|(\\w)\\4*o?)|([^\\w\\[\\(]+)/g; // TODO: more descrimination\n\n    var match;\n\n    while (match = chunker.exec(formatStr)) {\n      if (match[1]) {\n        // a literal string inside [ ... ]\n        chunks.push(match[1]);\n      } else if (match[2]) {\n        // non-zero formatting inside ( ... )\n        chunks.push({\n          maybe: chunkFormatString(match[2])\n        });\n      } else if (match[3]) {\n        // a formatting token\n        chunks.push({\n          token: match[3]\n        });\n      } else if (match[5]) {\n        // an unenclosed literal string\n        chunks.push(match[5]);\n      }\n    }\n\n    return chunks;\n  }\n\n  ;\n  ;\n  FC.Class = Class; // export\n  // Class that all other classes will inherit from\n\n  function Class() {} // Called on a class to create a subclass.\n  // Last argument contains instance methods. Any argument before the last are considered mixins.\n\n\n  Class.extend = function () {\n    var len = arguments.length;\n    var i;\n    var members;\n\n    for (i = 0; i < len; i++) {\n      members = arguments[i];\n\n      if (i < len - 1) {\n        // not the last argument?\n        mixIntoClass(this, members);\n      }\n    }\n\n    return extendClass(this, members || {}); // members will be undefined if no arguments\n  }; // Adds new member variables/methods to the class's prototype.\n  // Can be called with another class, or a plain object hash containing new members.\n\n\n  Class.mixin = function (members) {\n    mixIntoClass(this, members);\n  };\n\n  function extendClass(superClass, members) {\n    var subClass; // ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist\n\n    if (hasOwnProp(members, 'constructor')) {\n      subClass = members.constructor;\n    }\n\n    if (typeof subClass !== 'function') {\n      subClass = members.constructor = function () {\n        superClass.apply(this, arguments);\n      };\n    } // build the base prototype for the subclass, which is an new object chained to the superclass's prototype\n\n\n    subClass.prototype = createObject(superClass.prototype); // copy each member variable/method onto the the subclass's prototype\n\n    copyOwnProps(members, subClass.prototype);\n    copyNativeMethods(members, subClass.prototype); // hack for IE8\n    // copy over all class variables/methods to the subclass, such as `extend` and `mixin`\n\n    copyOwnProps(superClass, subClass);\n    return subClass;\n  }\n\n  function mixIntoClass(theClass, members) {\n    copyOwnProps(members, theClass.prototype); // TODO: copyNativeMethods?\n  }\n\n  ;\n  ;\n  var EmitterMixin = FC.EmitterMixin = {\n    // jQuery-ification via $(this) allows a non-DOM object to have\n    // the same event handling capabilities (including namespaces).\n    on: function on(types, handler) {\n      // handlers are always called with an \"event\" object as their first param.\n      // sneak the `this` context and arguments into the extra parameter object\n      // and forward them on to the original handler.\n      var intercept = function intercept(ev, extra) {\n        return handler.apply(extra.context || this, extra.args || []);\n      }; // mimick jQuery's internal \"proxy\" system (risky, I know)\n      // causing all functions with the same .guid to appear to be the same.\n      // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\n      // this is needed for calling .off with the original non-intercept handler.\n\n\n      if (!handler.guid) {\n        handler.guid = $.guid++;\n      }\n\n      intercept.guid = handler.guid;\n      $(this).on(types, intercept);\n      return this; // for chaining\n    },\n    off: function off(types, handler) {\n      $(this).off(types, handler);\n      return this; // for chaining\n    },\n    trigger: function trigger(types) {\n      var args = Array.prototype.slice.call(arguments, 1); // arguments after the first\n      // pass in \"extra\" info to the intercept\n\n      $(this).triggerHandler(types, {\n        args: args\n      });\n      return this; // for chaining\n    },\n    triggerWith: function triggerWith(types, context, args) {\n      // `triggerHandler` is less reliant on the DOM compared to `trigger`.\n      // pass in \"extra\" info to the intercept.\n      $(this).triggerHandler(types, {\n        context: context,\n        args: args\n      });\n      return this; // for chaining\n    }\n  };\n  ;\n  ;\n  /*\n  Utility methods for easily listening to events on another object,\n  and more importantly, easily unlistening from them.\n  */\n\n  var ListenerMixin = FC.ListenerMixin = function () {\n    var guid = 0;\n    var ListenerMixin = {\n      listenerId: null,\n\n      /*\n      Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\n      The `callback` will be called with the `this` context of the object that .listenTo is being called on.\n      Can be called:\n      \t.listenTo(other, eventName, callback)\n      OR\n      \t.listenTo(other, {\n      \t\teventName1: callback1,\n      \t\teventName2: callback2\n      \t})\n      */\n      listenTo: function listenTo(other, arg, callback) {\n        if (typeof arg === 'object') {\n          // given dictionary of callbacks\n          for (var eventName in arg) {\n            if (arg.hasOwnProperty(eventName)) {\n              this.listenTo(other, eventName, arg[eventName]);\n            }\n          }\n        } else if (typeof arg === 'string') {\n          other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\n          $.proxy(callback, this) // always use `this` context\n          // the usually-undesired jQuery guid behavior doesn't matter,\n          // because we always unbind via namespace\n          );\n        }\n      },\n\n      /*\n      Causes the current object to stop listening to events on the `other` object.\n      `eventName` is optional. If omitted, will stop listening to ALL events on `other`.\n      */\n      stopListeningTo: function stopListeningTo(other, eventName) {\n        other.off((eventName || '') + '.' + this.getListenerNamespace());\n      },\n\n      /*\n      Returns a string, unique to this object, to be used for event namespacing\n      */\n      getListenerNamespace: function getListenerNamespace() {\n        if (this.listenerId == null) {\n          this.listenerId = guid++;\n        }\n\n        return '_listener' + this.listenerId;\n      }\n    };\n    return ListenerMixin;\n  }();\n\n  ;\n  ; // simple class for toggle a `isIgnoringMouse` flag on delay\n  // initMouseIgnoring must first be called, with a millisecond delay setting.\n\n  var MouseIgnorerMixin = {\n    isIgnoringMouse: false,\n    // bool\n    delayUnignoreMouse: null,\n    // method\n    initMouseIgnoring: function initMouseIgnoring(delay) {\n      this.delayUnignoreMouse = debounce(proxy(this, 'unignoreMouse'), delay || 1000);\n    },\n    // temporarily ignore mouse actions on segments\n    tempIgnoreMouse: function tempIgnoreMouse() {\n      this.isIgnoringMouse = true;\n      this.delayUnignoreMouse();\n    },\n    // delayUnignoreMouse eventually calls this\n    unignoreMouse: function unignoreMouse() {\n      this.isIgnoringMouse = false;\n    }\n  };\n  ;\n  ;\n  /* A rectangular panel that is absolutely positioned over other content\n  ------------------------------------------------------------------------------------------------------------------------\n  Options:\n  \t- className (string)\n  \t- content (HTML string or jQuery element set)\n  \t- parentEl\n  \t- top\n  \t- left\n  \t- right (the x coord of where the right edge should be. not a \"CSS\" right)\n  \t- autoHide (boolean)\n  \t- show (callback)\n  \t- hide (callback)\n  */\n\n  var Popover = Class.extend(ListenerMixin, {\n    isHidden: true,\n    options: null,\n    el: null,\n    // the container element for the popover. generated by this object\n    margin: 10,\n    // the space required between the popover and the edges of the scroll container\n    constructor: function constructor(options) {\n      this.options = options || {};\n    },\n    // Shows the popover on the specified position. Renders it if not already\n    show: function show() {\n      if (this.isHidden) {\n        if (!this.el) {\n          this.render();\n        }\n\n        this.el.show();\n        this.position();\n        this.isHidden = false;\n        this.trigger('show');\n      }\n    },\n    // Hides the popover, through CSS, but does not remove it from the DOM\n    hide: function hide() {\n      if (!this.isHidden) {\n        this.el.hide();\n        this.isHidden = true;\n        this.trigger('hide');\n      }\n    },\n    // Creates `this.el` and renders content inside of it\n    render: function render() {\n      var _this = this;\n\n      var options = this.options;\n      this.el = $('<div class=\"fc-popover\"/>').addClass(options.className || '').css({\n        // position initially to the top left to avoid creating scrollbars\n        top: 0,\n        left: 0\n      }).append(options.content).appendTo(options.parentEl); // when a click happens on anything inside with a 'fc-close' className, hide the popover\n\n      this.el.on('click', '.fc-close', function () {\n        _this.hide();\n      });\n\n      if (options.autoHide) {\n        this.listenTo($(document), 'mousedown', this.documentMousedown);\n      }\n    },\n    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n    documentMousedown: function documentMousedown(ev) {\n      // only hide the popover if the click happened outside the popover\n      if (this.el && !$(ev.target).closest(this.el).length) {\n        this.hide();\n      }\n    },\n    // Hides and unregisters any handlers\n    removeElement: function removeElement() {\n      this.hide();\n\n      if (this.el) {\n        this.el.remove();\n        this.el = null;\n      }\n\n      this.stopListeningTo($(document), 'mousedown');\n    },\n    // Positions the popover optimally, using the top/left/right options\n    position: function position() {\n      var options = this.options;\n      var origin = this.el.offsetParent().offset();\n      var width = this.el.outerWidth();\n      var height = this.el.outerHeight();\n      var windowEl = $(window);\n      var viewportEl = getScrollParent(this.el);\n      var viewportTop;\n      var viewportLeft;\n      var viewportOffset;\n      var top; // the \"position\" (not \"offset\") values for the popover\n\n      var left; //\n      // compute top and left\n\n      top = options.top || 0;\n\n      if (options.left !== undefined) {\n        left = options.left;\n      } else if (options.right !== undefined) {\n        left = options.right - width; // derive the left value from the right value\n      } else {\n        left = 0;\n      }\n\n      if (viewportEl.is(window) || viewportEl.is(document)) {\n        // normalize getScrollParent's result\n        viewportEl = windowEl;\n        viewportTop = 0; // the window is always at the top left\n\n        viewportLeft = 0; // (and .offset() won't work if called here)\n      } else {\n        viewportOffset = viewportEl.offset();\n        viewportTop = viewportOffset.top;\n        viewportLeft = viewportOffset.left;\n      } // if the window is scrolled, it causes the visible area to be further down\n\n\n      viewportTop += windowEl.scrollTop();\n      viewportLeft += windowEl.scrollLeft(); // constrain to the view port. if constrained by two edges, give precedence to top/left\n\n      if (options.viewportConstrain !== false) {\n        top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\n        top = Math.max(top, viewportTop + this.margin);\n        left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\n        left = Math.max(left, viewportLeft + this.margin);\n      }\n\n      this.el.css({\n        top: top - origin.top,\n        left: left - origin.left\n      });\n    },\n    // Triggers a callback. Calls a function in the option hash of the same name.\n    // Arguments beyond the first `name` are forwarded on.\n    // TODO: better code reuse for this. Repeat code\n    trigger: function trigger(name) {\n      if (this.options[name]) {\n        this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n    }\n  });\n  ;\n  ;\n  /*\n  A cache for the left/right/top/bottom/width/height values for one or more elements.\n  Works with both offset (from topleft document) and position (from offsetParent).\n  \n  options:\n  - els\n  - isHorizontal\n  - isVertical\n  */\n\n  var CoordCache = FC.CoordCache = Class.extend({\n    els: null,\n    // jQuery set (assumed to be siblings)\n    forcedOffsetParentEl: null,\n    // options can override the natural offsetParent\n    origin: null,\n    // {left,top} position of offsetParent of els\n    boundingRect: null,\n    // constrain cordinates to this rectangle. {left,right,top,bottom} or null\n    isHorizontal: false,\n    // whether to query for left/right/width\n    isVertical: false,\n    // whether to query for top/bottom/height\n    // arrays of coordinates (offsets from topleft of document)\n    lefts: null,\n    rights: null,\n    tops: null,\n    bottoms: null,\n    constructor: function constructor(options) {\n      this.els = $(options.els);\n      this.isHorizontal = options.isHorizontal;\n      this.isVertical = options.isVertical;\n      this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\n    },\n    // Queries the els for coordinates and stores them.\n    // Call this method before using and of the get* methods below.\n    build: function build() {\n      var offsetParentEl = this.forcedOffsetParentEl || this.els.eq(0).offsetParent();\n      this.origin = offsetParentEl.offset();\n      this.boundingRect = this.queryBoundingRect();\n\n      if (this.isHorizontal) {\n        this.buildElHorizontals();\n      }\n\n      if (this.isVertical) {\n        this.buildElVerticals();\n      }\n    },\n    // Destroys all internal data about coordinates, freeing memory\n    clear: function clear() {\n      this.origin = null;\n      this.boundingRect = null;\n      this.lefts = null;\n      this.rights = null;\n      this.tops = null;\n      this.bottoms = null;\n    },\n    // When called, if coord caches aren't built, builds them\n    ensureBuilt: function ensureBuilt() {\n      if (!this.origin) {\n        this.build();\n      }\n    },\n    // Compute and return what the elements' bounding rectangle is, from the user's perspective.\n    // Right now, only returns a rectangle if constrained by an overflow:scroll element.\n    queryBoundingRect: function queryBoundingRect() {\n      var scrollParentEl = getScrollParent(this.els.eq(0));\n\n      if (!scrollParentEl.is(document)) {\n        return getClientRect(scrollParentEl);\n      }\n    },\n    // Populates the left/right internal coordinate arrays\n    buildElHorizontals: function buildElHorizontals() {\n      var lefts = [];\n      var rights = [];\n      this.els.each(function (i, node) {\n        var el = $(node);\n        var left = el.offset().left;\n        var width = el.outerWidth();\n        lefts.push(left);\n        rights.push(left + width);\n      });\n      this.lefts = lefts;\n      this.rights = rights;\n    },\n    // Populates the top/bottom internal coordinate arrays\n    buildElVerticals: function buildElVerticals() {\n      var tops = [];\n      var bottoms = [];\n      this.els.each(function (i, node) {\n        var el = $(node);\n        var top = el.offset().top;\n        var height = el.outerHeight();\n        tops.push(top);\n        bottoms.push(top + height);\n      });\n      this.tops = tops;\n      this.bottoms = bottoms;\n    },\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, or outside of the boundingRect, returns undefined.\n    getHorizontalIndex: function getHorizontalIndex(leftOffset) {\n      this.ensureBuilt();\n      var boundingRect = this.boundingRect;\n      var lefts = this.lefts;\n      var rights = this.rights;\n      var len = lefts.length;\n      var i;\n\n      if (!boundingRect || leftOffset >= boundingRect.left && leftOffset < boundingRect.right) {\n        for (i = 0; i < len; i++) {\n          if (leftOffset >= lefts[i] && leftOffset < rights[i]) {\n            return i;\n          }\n        }\n      }\n    },\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, or outside of the boundingRect, returns undefined.\n    getVerticalIndex: function getVerticalIndex(topOffset) {\n      this.ensureBuilt();\n      var boundingRect = this.boundingRect;\n      var tops = this.tops;\n      var bottoms = this.bottoms;\n      var len = tops.length;\n      var i;\n\n      if (!boundingRect || topOffset >= boundingRect.top && topOffset < boundingRect.bottom) {\n        for (i = 0; i < len; i++) {\n          if (topOffset >= tops[i] && topOffset < bottoms[i]) {\n            return i;\n          }\n        }\n      }\n    },\n    // Gets the left offset (from document left) of the element at the given index\n    getLeftOffset: function getLeftOffset(leftIndex) {\n      this.ensureBuilt();\n      return this.lefts[leftIndex];\n    },\n    // Gets the left position (from offsetParent left) of the element at the given index\n    getLeftPosition: function getLeftPosition(leftIndex) {\n      this.ensureBuilt();\n      return this.lefts[leftIndex] - this.origin.left;\n    },\n    // Gets the right offset (from document left) of the element at the given index.\n    // This value is NOT relative to the document's right edge, like the CSS concept of \"right\" would be.\n    getRightOffset: function getRightOffset(leftIndex) {\n      this.ensureBuilt();\n      return this.rights[leftIndex];\n    },\n    // Gets the right position (from offsetParent left) of the element at the given index.\n    // This value is NOT relative to the offsetParent's right edge, like the CSS concept of \"right\" would be.\n    getRightPosition: function getRightPosition(leftIndex) {\n      this.ensureBuilt();\n      return this.rights[leftIndex] - this.origin.left;\n    },\n    // Gets the width of the element at the given index\n    getWidth: function getWidth(leftIndex) {\n      this.ensureBuilt();\n      return this.rights[leftIndex] - this.lefts[leftIndex];\n    },\n    // Gets the top offset (from document top) of the element at the given index\n    getTopOffset: function getTopOffset(topIndex) {\n      this.ensureBuilt();\n      return this.tops[topIndex];\n    },\n    // Gets the top position (from offsetParent top) of the element at the given position\n    getTopPosition: function getTopPosition(topIndex) {\n      this.ensureBuilt();\n      return this.tops[topIndex] - this.origin.top;\n    },\n    // Gets the bottom offset (from the document top) of the element at the given index.\n    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n    getBottomOffset: function getBottomOffset(topIndex) {\n      this.ensureBuilt();\n      return this.bottoms[topIndex];\n    },\n    // Gets the bottom position (from the offsetParent top) of the element at the given index.\n    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n    getBottomPosition: function getBottomPosition(topIndex) {\n      this.ensureBuilt();\n      return this.bottoms[topIndex] - this.origin.top;\n    },\n    // Gets the height of the element at the given index\n    getHeight: function getHeight(topIndex) {\n      this.ensureBuilt();\n      return this.bottoms[topIndex] - this.tops[topIndex];\n    }\n  });\n  ;\n  ;\n  /* Tracks a drag's mouse movement, firing various handlers\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // TODO: use Emitter\n\n  var DragListener = FC.DragListener = Class.extend(ListenerMixin, MouseIgnorerMixin, {\n    options: null,\n    // for IE8 bug-fighting behavior\n    subjectEl: null,\n    subjectHref: null,\n    // coordinates of the initial mousedown\n    originX: null,\n    originY: null,\n    // the wrapping element that scrolls, or MIGHT scroll if there's overflow.\n    // TODO: do this for wrappers that have overflow:hidden as well.\n    scrollEl: null,\n    isInteracting: false,\n    isDistanceSurpassed: false,\n    isDelayEnded: false,\n    isDragging: false,\n    isTouch: false,\n    delay: null,\n    delayTimeoutId: null,\n    minDistance: null,\n    handleTouchScrollProxy: null,\n    // calls handleTouchScroll, always bound to `this`\n    constructor: function constructor(options) {\n      this.options = options || {};\n      this.handleTouchScrollProxy = proxy(this, 'handleTouchScroll');\n      this.initMouseIgnoring(500);\n    },\n    // Interaction (high-level)\n    // -----------------------------------------------------------------------------------------------------------------\n    startInteraction: function startInteraction(ev, extraOptions) {\n      var isTouch = getEvIsTouch(ev);\n\n      if (ev.type === 'mousedown') {\n        if (this.isIgnoringMouse) {\n          return;\n        } else if (!isPrimaryMouseButton(ev)) {\n          return;\n        } else {\n          ev.preventDefault(); // prevents native selection in most browsers\n        }\n      }\n\n      if (!this.isInteracting) {\n        // process options\n        extraOptions = extraOptions || {};\n        this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);\n        this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);\n        this.subjectEl = this.options.subjectEl;\n        this.isInteracting = true;\n        this.isTouch = isTouch;\n        this.isDelayEnded = false;\n        this.isDistanceSurpassed = false;\n        this.originX = getEvX(ev);\n        this.originY = getEvY(ev);\n        this.scrollEl = getScrollParent($(ev.target));\n        this.bindHandlers();\n        this.initAutoScroll();\n        this.handleInteractionStart(ev);\n        this.startDelay(ev);\n\n        if (!this.minDistance) {\n          this.handleDistanceSurpassed(ev);\n        }\n      }\n    },\n    handleInteractionStart: function handleInteractionStart(ev) {\n      this.trigger('interactionStart', ev);\n    },\n    endInteraction: function endInteraction(ev, isCancelled) {\n      if (this.isInteracting) {\n        this.endDrag(ev);\n\n        if (this.delayTimeoutId) {\n          clearTimeout(this.delayTimeoutId);\n          this.delayTimeoutId = null;\n        }\n\n        this.destroyAutoScroll();\n        this.unbindHandlers();\n        this.isInteracting = false;\n        this.handleInteractionEnd(ev, isCancelled); // a touchstart+touchend on the same element will result in the following addition simulated events:\n        // mouseover + mouseout + click\n        // let's ignore these bogus events\n\n        if (this.isTouch) {\n          this.tempIgnoreMouse();\n        }\n      }\n    },\n    handleInteractionEnd: function handleInteractionEnd(ev, isCancelled) {\n      this.trigger('interactionEnd', ev, isCancelled || false);\n    },\n    // Binding To DOM\n    // -----------------------------------------------------------------------------------------------------------------\n    bindHandlers: function bindHandlers() {\n      var _this = this;\n\n      var touchStartIgnores = 1;\n\n      if (this.isTouch) {\n        this.listenTo($(document), {\n          touchmove: this.handleTouchMove,\n          touchend: this.endInteraction,\n          touchcancel: this.endInteraction,\n          // Sometimes touchend doesn't fire\n          // (can't figure out why. touchcancel doesn't fire either. has to do with scrolling?)\n          // If another touchstart happens, we know it's bogus, so cancel the drag.\n          // touchend will continue to be broken until user does a shorttap/scroll, but this is best we can do.\n          touchstart: function touchstart(ev) {\n            if (touchStartIgnores) {\n              // bindHandlers is called from within a touchstart,\n              touchStartIgnores--; // and we don't want this to fire immediately, so ignore.\n            } else {\n              _this.endInteraction(ev, true); // isCancelled=true\n\n            }\n          }\n        }); // listen to ALL scroll actions on the page\n\n        if (!bindAnyScroll(this.handleTouchScrollProxy) && // hopefully this works and short-circuits the rest\n        this.scrollEl // otherwise, attach a single handler to this\n        ) {\n            this.listenTo(this.scrollEl, 'scroll', this.handleTouchScroll);\n          }\n      } else {\n        this.listenTo($(document), {\n          mousemove: this.handleMouseMove,\n          mouseup: this.endInteraction\n        });\n      }\n\n      this.listenTo($(document), {\n        selectstart: preventDefault,\n        // don't allow selection while dragging\n        contextmenu: preventDefault // long taps would open menu on Chrome dev tools\n\n      });\n    },\n    unbindHandlers: function unbindHandlers() {\n      this.stopListeningTo($(document)); // unbind scroll listening\n\n      unbindAnyScroll(this.handleTouchScrollProxy);\n\n      if (this.scrollEl) {\n        this.stopListeningTo(this.scrollEl, 'scroll');\n      }\n    },\n    // Drag (high-level)\n    // -----------------------------------------------------------------------------------------------------------------\n    // extraOptions ignored if drag already started\n    startDrag: function startDrag(ev, extraOptions) {\n      this.startInteraction(ev, extraOptions); // ensure interaction began\n\n      if (!this.isDragging) {\n        this.isDragging = true;\n        this.handleDragStart(ev);\n      }\n    },\n    handleDragStart: function handleDragStart(ev) {\n      this.trigger('dragStart', ev);\n      this.initHrefHack();\n    },\n    handleMove: function handleMove(ev) {\n      var dx = getEvX(ev) - this.originX;\n      var dy = getEvY(ev) - this.originY;\n      var minDistance = this.minDistance;\n      var distanceSq; // current distance from the origin, squared\n\n      if (!this.isDistanceSurpassed) {\n        distanceSq = dx * dx + dy * dy;\n\n        if (distanceSq >= minDistance * minDistance) {\n          // use pythagorean theorem\n          this.handleDistanceSurpassed(ev);\n        }\n      }\n\n      if (this.isDragging) {\n        this.handleDrag(dx, dy, ev);\n      }\n    },\n    // Called while the mouse is being moved and when we know a legitimate drag is taking place\n    handleDrag: function handleDrag(dx, dy, ev) {\n      this.trigger('drag', dx, dy, ev);\n      this.updateAutoScroll(ev); // will possibly cause scrolling\n    },\n    endDrag: function endDrag(ev) {\n      if (this.isDragging) {\n        this.isDragging = false;\n        this.handleDragEnd(ev);\n      }\n    },\n    handleDragEnd: function handleDragEnd(ev) {\n      this.trigger('dragEnd', ev);\n      this.destroyHrefHack();\n    },\n    // Delay\n    // -----------------------------------------------------------------------------------------------------------------\n    startDelay: function startDelay(initialEv) {\n      var _this = this;\n\n      if (this.delay) {\n        this.delayTimeoutId = setTimeout(function () {\n          _this.handleDelayEnd(initialEv);\n        }, this.delay);\n      } else {\n        this.handleDelayEnd(initialEv);\n      }\n    },\n    handleDelayEnd: function handleDelayEnd(initialEv) {\n      this.isDelayEnded = true;\n\n      if (this.isDistanceSurpassed) {\n        this.startDrag(initialEv);\n      }\n    },\n    // Distance\n    // -----------------------------------------------------------------------------------------------------------------\n    handleDistanceSurpassed: function handleDistanceSurpassed(ev) {\n      this.isDistanceSurpassed = true;\n\n      if (this.isDelayEnded) {\n        this.startDrag(ev);\n      }\n    },\n    // Mouse / Touch\n    // -----------------------------------------------------------------------------------------------------------------\n    handleTouchMove: function handleTouchMove(ev) {\n      // prevent inertia and touchmove-scrolling while dragging\n      if (this.isDragging) {\n        ev.preventDefault();\n      }\n\n      this.handleMove(ev);\n    },\n    handleMouseMove: function handleMouseMove(ev) {\n      this.handleMove(ev);\n    },\n    // Scrolling (unrelated to auto-scroll)\n    // -----------------------------------------------------------------------------------------------------------------\n    handleTouchScroll: function handleTouchScroll(ev) {\n      // if the drag is being initiated by touch, but a scroll happens before\n      // the drag-initiating delay is over, cancel the drag\n      if (!this.isDragging) {\n        this.endInteraction(ev, true); // isCancelled=true\n      }\n    },\n    // <A> HREF Hack\n    // -----------------------------------------------------------------------------------------------------------------\n    initHrefHack: function initHrefHack() {\n      var subjectEl = this.subjectEl; // remove a mousedown'd <a>'s href so it is not visited (IE8 bug)\n\n      if (this.subjectHref = subjectEl ? subjectEl.attr('href') : null) {\n        subjectEl.removeAttr('href');\n      }\n    },\n    destroyHrefHack: function destroyHrefHack() {\n      var subjectEl = this.subjectEl;\n      var subjectHref = this.subjectHref; // restore a mousedown'd <a>'s href (for IE8 bug)\n\n      setTimeout(function () {\n        // must be outside of the click's execution\n        if (subjectHref) {\n          subjectEl.attr('href', subjectHref);\n        }\n      }, 0);\n    },\n    // Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    // Triggers a callback. Calls a function in the option hash of the same name.\n    // Arguments beyond the first `name` are forwarded on.\n    trigger: function trigger(name) {\n      if (this.options[name]) {\n        this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n      } // makes _methods callable by event name. TODO: kill this\n\n\n      if (this['_' + name]) {\n        this['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n    }\n  });\n  ;\n  ;\n  /*\n  this.scrollEl is set in DragListener\n  */\n\n  DragListener.mixin({\n    isAutoScroll: false,\n    scrollBounds: null,\n    // { top, bottom, left, right }\n    scrollTopVel: null,\n    // pixels per second\n    scrollLeftVel: null,\n    // pixels per second\n    scrollIntervalId: null,\n    // ID of setTimeout for scrolling animation loop\n    // defaults\n    scrollSensitivity: 30,\n    // pixels from edge for scrolling to start\n    scrollSpeed: 200,\n    // pixels per second, at maximum speed\n    scrollIntervalMs: 50,\n    // millisecond wait between scroll increment\n    initAutoScroll: function initAutoScroll() {\n      var scrollEl = this.scrollEl;\n      this.isAutoScroll = this.options.scroll && scrollEl && !scrollEl.is(window) && !scrollEl.is(document);\n\n      if (this.isAutoScroll) {\n        // debounce makes sure rapid calls don't happen\n        this.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));\n      }\n    },\n    destroyAutoScroll: function destroyAutoScroll() {\n      this.endAutoScroll(); // kill any animation loop\n      // remove the scroll handler if there is a scrollEl\n\n      if (this.isAutoScroll) {\n        this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\n      }\n    },\n    // Computes and stores the bounding rectangle of scrollEl\n    computeScrollBounds: function computeScrollBounds() {\n      if (this.isAutoScroll) {\n        this.scrollBounds = getOuterRect(this.scrollEl); // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\n      }\n    },\n    // Called when the dragging is in progress and scrolling should be updated\n    updateAutoScroll: function updateAutoScroll(ev) {\n      var sensitivity = this.scrollSensitivity;\n      var bounds = this.scrollBounds;\n      var topCloseness, bottomCloseness;\n      var leftCloseness, rightCloseness;\n      var topVel = 0;\n      var leftVel = 0;\n\n      if (bounds) {\n        // only scroll if scrollEl exists\n        // compute closeness to edges. valid range is from 0.0 - 1.0\n        topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;\n        bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;\n        leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;\n        rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity; // translate vertical closeness into velocity.\n        // mouse must be completely in bounds for velocity to happen.\n\n        if (topCloseness >= 0 && topCloseness <= 1) {\n          topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\n        } else if (bottomCloseness >= 0 && bottomCloseness <= 1) {\n          topVel = bottomCloseness * this.scrollSpeed;\n        } // translate horizontal closeness into velocity\n\n\n        if (leftCloseness >= 0 && leftCloseness <= 1) {\n          leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\n        } else if (rightCloseness >= 0 && rightCloseness <= 1) {\n          leftVel = rightCloseness * this.scrollSpeed;\n        }\n      }\n\n      this.setScrollVel(topVel, leftVel);\n    },\n    // Sets the speed-of-scrolling for the scrollEl\n    setScrollVel: function setScrollVel(topVel, leftVel) {\n      this.scrollTopVel = topVel;\n      this.scrollLeftVel = leftVel;\n      this.constrainScrollVel(); // massages into realistic values\n      // if there is non-zero velocity, and an animation loop hasn't already started, then START\n\n      if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\n        this.scrollIntervalId = setInterval(proxy(this, 'scrollIntervalFunc'), // scope to `this`\n        this.scrollIntervalMs);\n      }\n    },\n    // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\n    constrainScrollVel: function constrainScrollVel() {\n      var el = this.scrollEl;\n\n      if (this.scrollTopVel < 0) {\n        // scrolling up?\n        if (el.scrollTop() <= 0) {\n          // already scrolled all the way up?\n          this.scrollTopVel = 0;\n        }\n      } else if (this.scrollTopVel > 0) {\n        // scrolling down?\n        if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {\n          // already scrolled all the way down?\n          this.scrollTopVel = 0;\n        }\n      }\n\n      if (this.scrollLeftVel < 0) {\n        // scrolling left?\n        if (el.scrollLeft() <= 0) {\n          // already scrolled all the left?\n          this.scrollLeftVel = 0;\n        }\n      } else if (this.scrollLeftVel > 0) {\n        // scrolling right?\n        if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {\n          // already scrolled all the way right?\n          this.scrollLeftVel = 0;\n        }\n      }\n    },\n    // This function gets called during every iteration of the scrolling animation loop\n    scrollIntervalFunc: function scrollIntervalFunc() {\n      var el = this.scrollEl;\n      var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\n      // change the value of scrollEl's scroll\n\n      if (this.scrollTopVel) {\n        el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\n      }\n\n      if (this.scrollLeftVel) {\n        el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\n      }\n\n      this.constrainScrollVel(); // since the scroll values changed, recompute the velocities\n      // if scrolled all the way, which causes the vels to be zero, stop the animation loop\n\n      if (!this.scrollTopVel && !this.scrollLeftVel) {\n        this.endAutoScroll();\n      }\n    },\n    // Kills any existing scrolling animation loop\n    endAutoScroll: function endAutoScroll() {\n      if (this.scrollIntervalId) {\n        clearInterval(this.scrollIntervalId);\n        this.scrollIntervalId = null;\n        this.handleScrollEnd();\n      }\n    },\n    // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\n    handleDebouncedScroll: function handleDebouncedScroll() {\n      // recompute all coordinates, but *only* if this is *not* part of our scrolling animation\n      if (!this.scrollIntervalId) {\n        this.handleScrollEnd();\n      }\n    },\n    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n    handleScrollEnd: function handleScrollEnd() {}\n  });\n  ;\n  ;\n  /* Tracks mouse movements over a component and raises events about which hit the mouse is over.\n  ------------------------------------------------------------------------------------------------------------------------\n  options:\n  - subjectEl\n  - subjectCenter\n  */\n\n  var HitDragListener = DragListener.extend({\n    component: null,\n    // converts coordinates to hits\n    // methods: prepareHits, releaseHits, queryHit\n    origHit: null,\n    // the hit the mouse was over when listening started\n    hit: null,\n    // the hit the mouse is over\n    coordAdjust: null,\n    // delta that will be added to the mouse coordinates when computing collisions\n    constructor: function constructor(component, options) {\n      DragListener.call(this, options); // call the super-constructor\n\n      this.component = component;\n    },\n    // Called when drag listening starts (but a real drag has not necessarily began).\n    // ev might be undefined if dragging was started manually.\n    handleInteractionStart: function handleInteractionStart(ev) {\n      var subjectEl = this.subjectEl;\n      var subjectRect;\n      var origPoint;\n      var point;\n      this.computeCoords();\n\n      if (ev) {\n        origPoint = {\n          left: getEvX(ev),\n          top: getEvY(ev)\n        };\n        point = origPoint; // constrain the point to bounds of the element being dragged\n\n        if (subjectEl) {\n          subjectRect = getOuterRect(subjectEl); // used for centering as well\n\n          point = constrainPoint(point, subjectRect);\n        }\n\n        this.origHit = this.queryHit(point.left, point.top); // treat the center of the subject as the collision point?\n\n        if (subjectEl && this.options.subjectCenter) {\n          // only consider the area the subject overlaps the hit. best for large subjects.\n          // TODO: skip this if hit didn't supply left/right/top/bottom\n          if (this.origHit) {\n            subjectRect = intersectRects(this.origHit, subjectRect) || subjectRect; // in case there is no intersection\n          }\n\n          point = getRectCenter(subjectRect);\n        }\n\n        this.coordAdjust = diffPoints(point, origPoint); // point - origPoint\n      } else {\n        this.origHit = null;\n        this.coordAdjust = null;\n      } // call the super-method. do it after origHit has been computed\n\n\n      DragListener.prototype.handleInteractionStart.apply(this, arguments);\n    },\n    // Recomputes the drag-critical positions of elements\n    computeCoords: function computeCoords() {\n      this.component.prepareHits();\n      this.computeScrollBounds(); // why is this here??????\n    },\n    // Called when the actual drag has started\n    handleDragStart: function handleDragStart(ev) {\n      var hit;\n      DragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method\n      // might be different from this.origHit if the min-distance is large\n\n      hit = this.queryHit(getEvX(ev), getEvY(ev)); // report the initial hit the mouse is over\n      // especially important if no min-distance and drag starts immediately\n\n      if (hit) {\n        this.handleHitOver(hit);\n      }\n    },\n    // Called when the drag moves\n    handleDrag: function handleDrag(dx, dy, ev) {\n      var hit;\n      DragListener.prototype.handleDrag.apply(this, arguments); // call the super-method\n\n      hit = this.queryHit(getEvX(ev), getEvY(ev));\n\n      if (!isHitsEqual(hit, this.hit)) {\n        // a different hit than before?\n        if (this.hit) {\n          this.handleHitOut();\n        }\n\n        if (hit) {\n          this.handleHitOver(hit);\n        }\n      }\n    },\n    // Called when dragging has been stopped\n    handleDragEnd: function handleDragEnd() {\n      this.handleHitDone();\n      DragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method\n    },\n    // Called when a the mouse has just moved over a new hit\n    handleHitOver: function handleHitOver(hit) {\n      var isOrig = isHitsEqual(hit, this.origHit);\n      this.hit = hit;\n      this.trigger('hitOver', this.hit, isOrig, this.origHit);\n    },\n    // Called when the mouse has just moved out of a hit\n    handleHitOut: function handleHitOut() {\n      if (this.hit) {\n        this.trigger('hitOut', this.hit);\n        this.handleHitDone();\n        this.hit = null;\n      }\n    },\n    // Called after a hitOut. Also called before a dragStop\n    handleHitDone: function handleHitDone() {\n      if (this.hit) {\n        this.trigger('hitDone', this.hit);\n      }\n    },\n    // Called when the interaction ends, whether there was a real drag or not\n    handleInteractionEnd: function handleInteractionEnd() {\n      DragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method\n\n      this.origHit = null;\n      this.hit = null;\n      this.component.releaseHits();\n    },\n    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n    handleScrollEnd: function handleScrollEnd() {\n      DragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method\n\n      this.computeCoords(); // hits' absolute positions will be in new places. recompute\n    },\n    // Gets the hit underneath the coordinates for the given mouse event\n    queryHit: function queryHit(left, top) {\n      if (this.coordAdjust) {\n        left += this.coordAdjust.left;\n        top += this.coordAdjust.top;\n      }\n\n      return this.component.queryHit(left, top);\n    }\n  }); // Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\n  // Two null values will be considered equal, as two \"out of the component\" states are the same.\n\n  function isHitsEqual(hit0, hit1) {\n    if (!hit0 && !hit1) {\n      return true;\n    }\n\n    if (hit0 && hit1) {\n      return hit0.component === hit1.component && isHitPropsWithin(hit0, hit1) && isHitPropsWithin(hit1, hit0); // ensures all props are identical\n    }\n\n    return false;\n  } // Returns true if all of subHit's non-standard properties are within superHit\n\n\n  function isHitPropsWithin(subHit, superHit) {\n    for (var propName in subHit) {\n      if (!/^(component|left|right|top|bottom)$/.test(propName)) {\n        if (subHit[propName] !== superHit[propName]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  ;\n  ;\n  /* Creates a clone of an element and lets it track the mouse as it moves\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  var MouseFollower = Class.extend(ListenerMixin, {\n    options: null,\n    sourceEl: null,\n    // the element that will be cloned and made to look like it is dragging\n    el: null,\n    // the clone of `sourceEl` that will track the mouse\n    parentEl: null,\n    // the element that `el` (the clone) will be attached to\n    // the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl\n    top0: null,\n    left0: null,\n    // the absolute coordinates of the initiating touch/mouse action\n    y0: null,\n    x0: null,\n    // the number of pixels the mouse has moved from its initial position\n    topDelta: null,\n    leftDelta: null,\n    isFollowing: false,\n    isHidden: false,\n    isAnimating: false,\n    // doing the revert animation?\n    constructor: function constructor(sourceEl, options) {\n      this.options = options = options || {};\n      this.sourceEl = sourceEl;\n      this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\n    },\n    // Causes the element to start following the mouse\n    start: function start(ev) {\n      if (!this.isFollowing) {\n        this.isFollowing = true;\n        this.y0 = getEvY(ev);\n        this.x0 = getEvX(ev);\n        this.topDelta = 0;\n        this.leftDelta = 0;\n\n        if (!this.isHidden) {\n          this.updatePosition();\n        }\n\n        if (getEvIsTouch(ev)) {\n          this.listenTo($(document), 'touchmove', this.handleMove);\n        } else {\n          this.listenTo($(document), 'mousemove', this.handleMove);\n        }\n      }\n    },\n    // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\n    // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\n    stop: function stop(shouldRevert, callback) {\n      var _this = this;\n\n      var revertDuration = this.options.revertDuration;\n\n      function complete() {\n        this.isAnimating = false;\n\n        _this.removeElement();\n\n        this.top0 = this.left0 = null; // reset state for future updatePosition calls\n\n        if (callback) {\n          callback();\n        }\n      }\n\n      if (this.isFollowing && !this.isAnimating) {\n        // disallow more than one stop animation at a time\n        this.isFollowing = false;\n        this.stopListeningTo($(document));\n\n        if (shouldRevert && revertDuration && !this.isHidden) {\n          // do a revert animation?\n          this.isAnimating = true;\n          this.el.animate({\n            top: this.top0,\n            left: this.left0\n          }, {\n            duration: revertDuration,\n            complete: complete\n          });\n        } else {\n          complete();\n        }\n      }\n    },\n    // Gets the tracking element. Create it if necessary\n    getEl: function getEl() {\n      var el = this.el;\n\n      if (!el) {\n        this.sourceEl.width(); // hack to force IE8 to compute correct bounding box\n\n        el = this.el = this.sourceEl.clone().addClass(this.options.additionalClass || '').css({\n          position: 'absolute',\n          visibility: '',\n          // in case original element was hidden (commonly through hideEvents())\n          display: this.isHidden ? 'none' : '',\n          // for when initially hidden\n          margin: 0,\n          right: 'auto',\n          // erase and set width instead\n          bottom: 'auto',\n          // erase and set height instead\n          width: this.sourceEl.width(),\n          // explicit height in case there was a 'right' value\n          height: this.sourceEl.height(),\n          // explicit width in case there was a 'bottom' value\n          opacity: this.options.opacity || '',\n          zIndex: this.options.zIndex\n        }); // we don't want long taps or any mouse interaction causing selection/menus.\n        // would use preventSelection(), but that prevents selectstart, causing problems.\n\n        el.addClass('fc-unselectable');\n        el.appendTo(this.parentEl);\n      }\n\n      return el;\n    },\n    // Removes the tracking element if it has already been created\n    removeElement: function removeElement() {\n      if (this.el) {\n        this.el.remove();\n        this.el = null;\n      }\n    },\n    // Update the CSS position of the tracking element\n    updatePosition: function updatePosition() {\n      var sourceOffset;\n      var origin;\n      this.getEl(); // ensure this.el\n      // make sure origin info was computed\n\n      if (this.top0 === null) {\n        this.sourceEl.width(); // hack to force IE8 to compute correct bounding box\n\n        sourceOffset = this.sourceEl.offset();\n        origin = this.el.offsetParent().offset();\n        this.top0 = sourceOffset.top - origin.top;\n        this.left0 = sourceOffset.left - origin.left;\n      }\n\n      this.el.css({\n        top: this.top0 + this.topDelta,\n        left: this.left0 + this.leftDelta\n      });\n    },\n    // Gets called when the user moves the mouse\n    handleMove: function handleMove(ev) {\n      this.topDelta = getEvY(ev) - this.y0;\n      this.leftDelta = getEvX(ev) - this.x0;\n\n      if (!this.isHidden) {\n        this.updatePosition();\n      }\n    },\n    // Temporarily makes the tracking element invisible. Can be called before following starts\n    hide: function hide() {\n      if (!this.isHidden) {\n        this.isHidden = true;\n\n        if (this.el) {\n          this.el.hide();\n        }\n      }\n    },\n    // Show the tracking element after it has been temporarily hidden\n    show: function show() {\n      if (this.isHidden) {\n        this.isHidden = false;\n        this.updatePosition();\n        this.getEl().show();\n      }\n    }\n  });\n  ;\n  ;\n  /* An abstract class comprised of a \"grid\" of areas that each represent a specific datetime\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  var Grid = FC.Grid = Class.extend(ListenerMixin, MouseIgnorerMixin, {\n    view: null,\n    // a View object\n    isRTL: null,\n    // shortcut to the view's isRTL option\n    start: null,\n    end: null,\n    el: null,\n    // the containing element\n    elsByFill: null,\n    // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.\n    // derived from options\n    eventTimeFormat: null,\n    displayEventTime: null,\n    displayEventEnd: null,\n    minResizeDuration: null,\n    // TODO: hack. set by subclasses. minumum event resize duration\n    // if defined, holds the unit identified (ex: \"year\" or \"month\") that determines the level of granularity\n    // of the date areas. if not defined, assumes to be day and time granularity.\n    // TODO: port isTimeScale into same system?\n    largeUnit: null,\n    dayDragListener: null,\n    segDragListener: null,\n    segResizeListener: null,\n    externalDragListener: null,\n    constructor: function constructor(view) {\n      this.view = view;\n      this.isRTL = view.opt('isRTL');\n      this.elsByFill = {};\n      this.dayDragListener = this.buildDayDragListener();\n      this.initMouseIgnoring();\n    },\n\n    /* Options\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the format string used for event time text, if not explicitly defined by 'timeFormat'\n    computeEventTimeFormat: function computeEventTimeFormat() {\n      return this.view.opt('smallTimeFormat');\n    },\n    // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.\n    // Only applies to non-all-day events.\n    computeDisplayEventTime: function computeDisplayEventTime() {\n      return true;\n    },\n    // Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'\n    computeDisplayEventEnd: function computeDisplayEventEnd() {\n      return true;\n    },\n\n    /* Dates\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Tells the grid about what period of time to display.\n    // Any date-related internal data should be generated.\n    setRange: function setRange(range) {\n      this.start = range.start.clone();\n      this.end = range.end.clone();\n      this.rangeUpdated();\n      this.processRangeOptions();\n    },\n    // Called when internal variables that rely on the range should be updated\n    rangeUpdated: function rangeUpdated() {},\n    // Updates values that rely on options and also relate to range\n    processRangeOptions: function processRangeOptions() {\n      var view = this.view;\n      var displayEventTime;\n      var displayEventEnd;\n      this.eventTimeFormat = view.opt('eventTimeFormat') || view.opt('timeFormat') || // deprecated\n      this.computeEventTimeFormat();\n      displayEventTime = view.opt('displayEventTime');\n\n      if (displayEventTime == null) {\n        displayEventTime = this.computeDisplayEventTime(); // might be based off of range\n      }\n\n      displayEventEnd = view.opt('displayEventEnd');\n\n      if (displayEventEnd == null) {\n        displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\n      }\n\n      this.displayEventTime = displayEventTime;\n      this.displayEventEnd = displayEventEnd;\n    },\n    // Converts a span (has unzoned start/end and any other grid-specific location information)\n    // into an array of segments (pieces of events whose format is decided by the grid).\n    spanToSegs: function spanToSegs(span) {// subclasses must implement\n    },\n    // Diffs the two dates, returning a duration, based on granularity of the grid\n    // TODO: port isTimeScale into this system?\n    diffDates: function diffDates(a, b) {\n      if (this.largeUnit) {\n        return diffByUnit(a, b, this.largeUnit);\n      } else {\n        return diffDayTime(a, b);\n      }\n    },\n\n    /* Hit Area\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit\n    prepareHits: function prepareHits() {},\n    // Called when queryHit calls have subsided. Good place to clear any coordinate caches.\n    releaseHits: function releaseHits() {},\n    // Given coordinates from the topleft of the document, return data about the date-related area underneath.\n    // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\n    // Must have a `grid` property, a reference to this current grid. TODO: avoid this\n    // The returned object will be processed by getHitSpan and getHitEl.\n    queryHit: function queryHit(leftOffset, topOffset) {},\n    // Given position-level information about a date-related area within the grid,\n    // should return an object with at least a start/end date. Can provide other information as well.\n    getHitSpan: function getHitSpan(hit) {},\n    // Given position-level information about a date-related area within the grid,\n    // should return a jQuery element that best represents it. passed to dayClick callback.\n    getHitEl: function getHitEl(hit) {},\n\n    /* Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Sets the container element that the grid should render inside of.\n    // Does other DOM-related initializations.\n    setElement: function setElement(el) {\n      this.el = el;\n      preventSelection(el);\n      this.bindDayHandler('touchstart', this.dayTouchStart);\n      this.bindDayHandler('mousedown', this.dayMousedown); // attach event-element-related handlers. in Grid.events\n      // same garbage collection note as above.\n\n      this.bindSegHandlers();\n      this.bindGlobalHandlers();\n    },\n    bindDayHandler: function bindDayHandler(name, handler) {\n      var _this = this; // attach a handler to the grid's root element.\n      // jQuery will take care of unregistering them when removeElement gets called.\n\n\n      this.el.on(name, function (ev) {\n        if (!$(ev.target).is('.fc-event-container *, .fc-more') && // not an an event element, or \"more..\" link\n        !$(ev.target).closest('.fc-popover').length // not on a popover (like the \"more..\" events one)\n        ) {\n            return handler.call(_this, ev);\n          }\n      });\n    },\n    // Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.\n    // DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View\n    removeElement: function removeElement() {\n      this.unbindGlobalHandlers();\n      this.clearDragListeners();\n      this.el.remove(); // NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement\n    },\n    // Renders the basic structure of grid view before any content is rendered\n    renderSkeleton: function renderSkeleton() {// subclasses should implement\n    },\n    // Renders the grid's date-related content (like areas that represent days/times).\n    // Assumes setRange has already been called and the skeleton has already been rendered.\n    renderDates: function renderDates() {// subclasses should implement\n    },\n    // Unrenders the grid's date-related content\n    unrenderDates: function unrenderDates() {// subclasses should implement\n    },\n\n    /* Handlers\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Binds DOM handlers to elements that reside outside the grid, such as the document\n    bindGlobalHandlers: function bindGlobalHandlers() {\n      this.listenTo($(document), {\n        dragstart: this.externalDragStart,\n        // jqui\n        sortstart: this.externalDragStart // jqui\n\n      });\n    },\n    // Unbinds DOM handlers from elements that reside outside the grid\n    unbindGlobalHandlers: function unbindGlobalHandlers() {\n      this.stopListeningTo($(document));\n    },\n    // Process a mousedown on an element that represents a day. For day clicking and selecting.\n    dayMousedown: function dayMousedown(ev) {\n      if (!this.isIgnoringMouse) {\n        this.dayDragListener.startInteraction(ev, {//distance: 5, // needs more work if we want dayClick to fire correctly\n        });\n      }\n    },\n    dayTouchStart: function dayTouchStart(ev) {\n      var view = this.view; // HACK to prevent a user's clickaway for unselecting a range or an event\n      // from causing a dayClick.\n\n      if (view.isSelected || view.selectedEvent) {\n        this.tempIgnoreMouse();\n      }\n\n      this.dayDragListener.startInteraction(ev, {\n        delay: this.view.opt('longPressDelay')\n      });\n    },\n    // Creates a listener that tracks the user's drag across day elements.\n    // For day clicking and selecting.\n    buildDayDragListener: function buildDayDragListener() {\n      var _this = this;\n\n      var view = this.view;\n      var isSelectable = view.opt('selectable');\n      var dayClickHit; // null if invalid dayClick\n\n      var selectionSpan; // null if invalid selection\n      // this listener tracks a mousedown on a day element, and a subsequent drag.\n      // if the drag ends on the same day, it is a 'dayClick'.\n      // if 'selectable' is enabled, this listener also detects selections.\n\n      var dragListener = new HitDragListener(this, {\n        scroll: view.opt('dragScroll'),\n        interactionStart: function interactionStart() {\n          dayClickHit = dragListener.origHit; // for dayClick, where no dragging happens\n        },\n        dragStart: function dragStart() {\n          view.unselect(); // since we could be rendering a new selection, we want to clear any old one\n        },\n        hitOver: function hitOver(hit, isOrig, origHit) {\n          if (origHit) {\n            // click needs to have started on a hit\n            // if user dragged to another cell at any point, it can no longer be a dayClick\n            if (!isOrig) {\n              dayClickHit = null;\n            }\n\n            if (isSelectable) {\n              selectionSpan = _this.computeSelection(_this.getHitSpan(origHit), _this.getHitSpan(hit));\n\n              if (selectionSpan) {\n                _this.renderSelection(selectionSpan);\n              } else if (selectionSpan === false) {\n                disableCursor();\n              }\n            }\n          }\n        },\n        hitOut: function hitOut() {\n          dayClickHit = null;\n          selectionSpan = null;\n\n          _this.unrenderSelection();\n\n          enableCursor();\n        },\n        interactionEnd: function interactionEnd(ev, isCancelled) {\n          if (!isCancelled) {\n            if (dayClickHit && !_this.isIgnoringMouse // see hack in dayTouchStart\n            ) {\n                view.triggerDayClick(_this.getHitSpan(dayClickHit), _this.getHitEl(dayClickHit), ev);\n              }\n\n            if (selectionSpan) {\n              // the selection will already have been rendered. just report it\n              view.reportSelection(selectionSpan, ev);\n            }\n\n            enableCursor();\n          }\n        }\n      });\n      return dragListener;\n    },\n    // Kills all in-progress dragging.\n    // Useful for when public API methods that result in re-rendering are invoked during a drag.\n    // Also useful for when touch devices misbehave and don't fire their touchend.\n    clearDragListeners: function clearDragListeners() {\n      this.dayDragListener.endInteraction();\n\n      if (this.segDragListener) {\n        this.segDragListener.endInteraction(); // will clear this.segDragListener\n      }\n\n      if (this.segResizeListener) {\n        this.segResizeListener.endInteraction(); // will clear this.segResizeListener\n      }\n\n      if (this.externalDragListener) {\n        this.externalDragListener.endInteraction(); // will clear this.externalDragListener\n      }\n    },\n\n    /* Event Helper\n    ------------------------------------------------------------------------------------------------------------------*/\n    // TODO: should probably move this to Grid.events, like we did event dragging / resizing\n    // Renders a mock event at the given event location, which contains zoned start/end properties.\n    // Returns all mock event elements.\n    renderEventLocationHelper: function renderEventLocationHelper(eventLocation, sourceSeg) {\n      var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);\n      return this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering\n    },\n    // Builds a fake event given zoned event date properties and a segment is should be inspired from.\n    // The range's end can be null, in which case the mock event that is rendered will have a null end time.\n    // `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.\n    fabricateHelperEvent: function fabricateHelperEvent(eventLocation, sourceSeg) {\n      var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible\n\n      fakeEvent.start = eventLocation.start.clone();\n      fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;\n      fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates\n\n      this.view.calendar.normalizeEventDates(fakeEvent); // this extra className will be useful for differentiating real events from mock events in CSS\n\n      fakeEvent.className = (fakeEvent.className || []).concat('fc-helper'); // if something external is being dragged in, don't render a resizer\n\n      if (!sourceSeg) {\n        fakeEvent.editable = false;\n      }\n\n      return fakeEvent;\n    },\n    // Renders a mock event. Given zoned event date properties.\n    // Must return all mock event elements.\n    renderHelper: function renderHelper(eventLocation, sourceSeg) {// subclasses must implement\n    },\n    // Unrenders a mock event\n    unrenderHelper: function unrenderHelper() {// subclasses must implement\n    },\n\n    /* Selection\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.\n    // Given a span (unzoned start/end and other misc data)\n    renderSelection: function renderSelection(span) {\n      this.renderHighlight(span);\n    },\n    // Unrenders any visual indications of a selection. Will unrender a highlight by default.\n    unrenderSelection: function unrenderSelection() {\n      this.unrenderHighlight();\n    },\n    // Given the first and last date-spans of a selection, returns another date-span object.\n    // Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().\n    // Will return false if the selection is invalid and this should be indicated to the user.\n    // Will return null/undefined if a selection invalid but no error should be reported.\n    computeSelection: function computeSelection(span0, span1) {\n      var span = this.computeSelectionSpan(span0, span1);\n\n      if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {\n        return false;\n      }\n\n      return span;\n    },\n    // Given two spans, must return the combination of the two.\n    // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\n    computeSelectionSpan: function computeSelectionSpan(span0, span1) {\n      var dates = [span0.start, span0.end, span1.start, span1.end];\n      dates.sort(compareNumbers); // sorts chronologically. works with Moments\n\n      return {\n        start: dates[0].clone(),\n        end: dates[3].clone()\n      };\n    },\n\n    /* Highlight\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\n    renderHighlight: function renderHighlight(span) {\n      this.renderFill('highlight', this.spanToSegs(span));\n    },\n    // Unrenders the emphasis on a date range\n    unrenderHighlight: function unrenderHighlight() {\n      this.unrenderFill('highlight');\n    },\n    // Generates an array of classNames for rendering the highlight. Used by the fill system.\n    highlightSegClasses: function highlightSegClasses() {\n      return ['fc-highlight'];\n    },\n\n    /* Business Hours\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderBusinessHours: function renderBusinessHours() {},\n    unrenderBusinessHours: function unrenderBusinessHours() {},\n\n    /* Now Indicator\n    ------------------------------------------------------------------------------------------------------------------*/\n    getNowIndicatorUnit: function getNowIndicatorUnit() {},\n    renderNowIndicator: function renderNowIndicator(date) {},\n    unrenderNowIndicator: function unrenderNowIndicator() {},\n\n    /* Fill System (highlight, background events, business hours)\n    --------------------------------------------------------------------------------------------------------------------\n    TODO: remove this system. like we did in TimeGrid\n    */\n    // Renders a set of rectangles over the given segments of time.\n    // MUST RETURN a subset of segs, the segs that were actually rendered.\n    // Responsible for populating this.elsByFill. TODO: better API for expressing this requirement\n    renderFill: function renderFill(type, segs) {// subclasses must implement\n    },\n    // Unrenders a specific type of fill that is currently rendered on the grid\n    unrenderFill: function unrenderFill(type) {\n      var el = this.elsByFill[type];\n\n      if (el) {\n        el.remove();\n        delete this.elsByFill[type];\n      }\n    },\n    // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\n    // Only returns segments that successfully rendered.\n    // To be harnessed by renderFill (implemented by subclasses).\n    // Analagous to renderFgSegEls.\n    renderFillSegEls: function renderFillSegEls(type, segs) {\n      var _this = this;\n\n      var segElMethod = this[type + 'SegEl'];\n      var html = '';\n      var renderedSegs = [];\n      var i;\n\n      if (segs.length) {\n        // build a large concatenation of segment HTML\n        for (i = 0; i < segs.length; i++) {\n          html += this.fillSegHtml(type, segs[i]);\n        } // Grab individual elements from the combined HTML string. Use each as the default rendering.\n        // Then, compute the 'el' for each segment.\n\n\n        $(html).each(function (i, node) {\n          var seg = segs[i];\n          var el = $(node); // allow custom filter methods per-type\n\n          if (segElMethod) {\n            el = segElMethod.call(_this, seg, el);\n          }\n\n          if (el) {\n            // custom filters did not cancel the render\n            el = $(el); // allow custom filter to return raw DOM node\n            // correct element type? (would be bad if a non-TD were inserted into a table for example)\n\n            if (el.is(_this.fillSegTag)) {\n              seg.el = el;\n              renderedSegs.push(seg);\n            }\n          }\n        });\n      }\n\n      return renderedSegs;\n    },\n    fillSegTag: 'div',\n    // subclasses can override\n    // Builds the HTML needed for one fill segment. Generic enough to work with different types.\n    fillSegHtml: function fillSegHtml(type, seg) {\n      // custom hooks per-type\n      var classesMethod = this[type + 'SegClasses'];\n      var cssMethod = this[type + 'SegCss'];\n      var classes = classesMethod ? classesMethod.call(this, seg) : [];\n      var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});\n      return '<' + this.fillSegTag + (classes.length ? ' class=\"' + classes.join(' ') + '\"' : '') + (css ? ' style=\"' + css + '\"' : '') + ' />';\n    },\n\n    /* Generic rendering utilities for subclasses\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Computes HTML classNames for a single-day element\n    getDayClasses: function getDayClasses(date) {\n      var view = this.view;\n      var today = view.calendar.getNow();\n      var classes = ['fc-' + dayIDs[date.day()]];\n\n      if (view.intervalDuration.as('months') == 1 && date.month() != view.intervalStart.month()) {\n        classes.push('fc-other-month');\n      }\n\n      if (date.isSame(today, 'day')) {\n        classes.push('fc-today', view.highlightStateClass);\n      } else if (date < today) {\n        classes.push('fc-past');\n      } else {\n        classes.push('fc-future');\n      }\n\n      return classes;\n    }\n  });\n  ;\n  ;\n  /* Event-rendering and event-interaction methods for the abstract Grid class\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  Grid.mixin({\n    mousedOverSeg: null,\n    // the segment object the user's mouse is over. null if over nothing\n    isDraggingSeg: false,\n    // is a segment being dragged? boolean\n    isResizingSeg: false,\n    // is a segment being resized? boolean\n    isDraggingExternal: false,\n    // jqui-dragging an external element? boolean\n    segs: null,\n    // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`\n    // Renders the given events onto the grid\n    renderEvents: function renderEvents(events) {\n      var bgEvents = [];\n      var fgEvents = [];\n      var i;\n\n      for (i = 0; i < events.length; i++) {\n        (isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);\n      }\n\n      this.segs = [].concat( // record all segs\n      this.renderBgEvents(bgEvents), this.renderFgEvents(fgEvents));\n    },\n    renderBgEvents: function renderBgEvents(events) {\n      var segs = this.eventsToSegs(events); // renderBgSegs might return a subset of segs, segs that were actually rendered\n\n      return this.renderBgSegs(segs) || segs;\n    },\n    renderFgEvents: function renderFgEvents(events) {\n      var segs = this.eventsToSegs(events); // renderFgSegs might return a subset of segs, segs that were actually rendered\n\n      return this.renderFgSegs(segs) || segs;\n    },\n    // Unrenders all events currently rendered on the grid\n    unrenderEvents: function unrenderEvents() {\n      this.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event\n\n      this.clearDragListeners();\n      this.unrenderFgSegs();\n      this.unrenderBgSegs();\n      this.segs = null;\n    },\n    // Retrieves all rendered segment objects currently rendered on the grid\n    getEventSegs: function getEventSegs() {\n      return this.segs || [];\n    },\n\n    /* Foreground Segment Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders foreground event segments onto the grid. May return a subset of segs that were rendered.\n    renderFgSegs: function renderFgSegs(segs) {// subclasses must implement\n    },\n    // Unrenders all currently rendered foreground segments\n    unrenderFgSegs: function unrenderFgSegs() {// subclasses must implement\n    },\n    // Renders and assigns an `el` property for each foreground event segment.\n    // Only returns segments that successfully rendered.\n    // A utility that subclasses may use.\n    renderFgSegEls: function renderFgSegEls(segs, disableResizing) {\n      var view = this.view;\n      var html = '';\n      var renderedSegs = [];\n      var i;\n\n      if (segs.length) {\n        // don't build an empty html string\n        // build a large concatenation of event segment HTML\n        for (i = 0; i < segs.length; i++) {\n          html += this.fgSegHtml(segs[i], disableResizing);\n        } // Grab individual elements from the combined HTML string. Use each as the default rendering.\n        // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\n\n\n        $(html).each(function (i, node) {\n          var seg = segs[i];\n          var el = view.resolveEventEl(seg.event, $(node));\n\n          if (el) {\n            el.data('fc-seg', seg); // used by handlers\n\n            seg.el = el;\n            renderedSegs.push(seg);\n          }\n        });\n      }\n\n      return renderedSegs;\n    },\n    // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\n    fgSegHtml: function fgSegHtml(seg, disableResizing) {// subclasses should implement\n    },\n\n    /* Background Segment Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders the given background event segments onto the grid.\n    // Returns a subset of the segs that were actually rendered.\n    renderBgSegs: function renderBgSegs(segs) {\n      return this.renderFill('bgEvent', segs);\n    },\n    // Unrenders all the currently rendered background event segments\n    unrenderBgSegs: function unrenderBgSegs() {\n      this.unrenderFill('bgEvent');\n    },\n    // Renders a background event element, given the default rendering. Called by the fill system.\n    bgEventSegEl: function bgEventSegEl(seg, el) {\n      return this.view.resolveEventEl(seg.event, el); // will filter through eventRender\n    },\n    // Generates an array of classNames to be used for the default rendering of a background event.\n    // Called by the fill system.\n    bgEventSegClasses: function bgEventSegClasses(seg) {\n      var event = seg.event;\n      var source = event.source || {};\n      return ['fc-bgevent'].concat(event.className, source.className || []);\n    },\n    // Generates a semicolon-separated CSS string to be used for the default rendering of a background event.\n    // Called by the fill system.\n    bgEventSegCss: function bgEventSegCss(seg) {\n      return {\n        'background-color': this.getSegSkinCss(seg)['background-color']\n      };\n    },\n    // Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.\n    businessHoursSegClasses: function businessHoursSegClasses(seg) {\n      return ['fc-nonbusiness', 'fc-bgevent'];\n    },\n\n    /* Handlers\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Attaches event-element-related handlers to the container element and leverage bubbling\n    bindSegHandlers: function bindSegHandlers() {\n      this.bindSegHandler('touchstart', this.handleSegTouchStart);\n      this.bindSegHandler('touchend', this.handleSegTouchEnd);\n      this.bindSegHandler('mouseenter', this.handleSegMouseover);\n      this.bindSegHandler('mouseleave', this.handleSegMouseout);\n      this.bindSegHandler('mousedown', this.handleSegMousedown);\n      this.bindSegHandler('click', this.handleSegClick);\n    },\n    // Executes a handler for any a user-interaction on a segment.\n    // Handler gets called with (seg, ev), and with the `this` context of the Grid\n    bindSegHandler: function bindSegHandler(name, handler) {\n      var _this = this;\n\n      this.el.on(name, '.fc-event-container > *', function (ev) {\n        var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents\n        // only call the handlers if there is not a drag/resize in progress\n\n        if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {\n          return handler.call(_this, seg, ev); // context will be the Grid\n        }\n      });\n    },\n    handleSegClick: function handleSegClick(seg, ev) {\n      return this.view.trigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel\n    },\n    // Updates internal state and triggers handlers for when an event element is moused over\n    handleSegMouseover: function handleSegMouseover(seg, ev) {\n      if (!this.isIgnoringMouse && !this.mousedOverSeg) {\n        this.mousedOverSeg = seg;\n        seg.el.addClass('fc-allow-mouse-resize');\n        this.view.trigger('eventMouseover', seg.el[0], seg.event, ev);\n      }\n    },\n    // Updates internal state and triggers handlers for when an event element is moused out.\n    // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\n    handleSegMouseout: function handleSegMouseout(seg, ev) {\n      ev = ev || {}; // if given no args, make a mock mouse event\n\n      if (this.mousedOverSeg) {\n        seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment\n\n        this.mousedOverSeg = null;\n        seg.el.removeClass('fc-allow-mouse-resize');\n        this.view.trigger('eventMouseout', seg.el[0], seg.event, ev);\n      }\n    },\n    handleSegMousedown: function handleSegMousedown(seg, ev) {\n      var isResizing = this.startSegResize(seg, ev, {\n        distance: 5\n      });\n\n      if (!isResizing && this.view.isEventDraggable(seg.event)) {\n        this.buildSegDragListener(seg).startInteraction(ev, {\n          distance: 5\n        });\n      }\n    },\n    handleSegTouchStart: function handleSegTouchStart(seg, ev) {\n      var view = this.view;\n      var event = seg.event;\n      var isSelected = view.isEventSelected(event);\n      var isDraggable = view.isEventDraggable(event);\n      var isResizable = view.isEventResizable(event);\n      var isResizing = false;\n      var dragListener;\n\n      if (isSelected && isResizable) {\n        // only allow resizing of the event is selected\n        isResizing = this.startSegResize(seg, ev);\n      }\n\n      if (!isResizing && (isDraggable || isResizable)) {\n        // allowed to be selected?\n        dragListener = isDraggable ? this.buildSegDragListener(seg) : this.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected\n\n        dragListener.startInteraction(ev, {\n          // won't start if already started\n          delay: isSelected ? 0 : this.view.opt('longPressDelay') // do delay if not already selected\n\n        });\n      } // a long tap simulates a mouseover. ignore this bogus mouseover.\n\n\n      this.tempIgnoreMouse();\n    },\n    handleSegTouchEnd: function handleSegTouchEnd(seg, ev) {\n      // touchstart+touchend = click, which simulates a mouseover.\n      // ignore this bogus mouseover.\n      this.tempIgnoreMouse();\n    },\n    // returns boolean whether resizing actually started or not.\n    // assumes the seg allows resizing.\n    // `dragOptions` are optional.\n    startSegResize: function startSegResize(seg, ev, dragOptions) {\n      if ($(ev.target).is('.fc-resizer')) {\n        this.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer')).startInteraction(ev, dragOptions);\n        return true;\n      }\n\n      return false;\n    },\n\n    /* Event Dragging\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Builds a listener that will track user-dragging on an event segment.\n    // Generic enough to work with any type of Grid.\n    // Has side effect of setting/unsetting `segDragListener`\n    buildSegDragListener: function buildSegDragListener(seg) {\n      var _this = this;\n\n      var view = this.view;\n      var calendar = view.calendar;\n      var el = seg.el;\n      var event = seg.event;\n      var isDragging;\n      var mouseFollower; // A clone of the original element that will move with the mouse\n\n      var dropLocation; // zoned event date properties\n\n      if (this.segDragListener) {\n        return this.segDragListener;\n      } // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\n      // of the view.\n\n\n      var dragListener = this.segDragListener = new HitDragListener(view, {\n        scroll: view.opt('dragScroll'),\n        subjectEl: el,\n        subjectCenter: true,\n        interactionStart: function interactionStart(ev) {\n          isDragging = false;\n          mouseFollower = new MouseFollower(seg.el, {\n            additionalClass: 'fc-dragging',\n            parentEl: view.el,\n            opacity: dragListener.isTouch ? null : view.opt('dragOpacity'),\n            revertDuration: view.opt('dragRevertDuration'),\n            zIndex: 2 // one above the .fc-view\n\n          });\n          mouseFollower.hide(); // don't show until we know this is a real drag\n\n          mouseFollower.start(ev);\n        },\n        dragStart: function dragStart(ev) {\n          if (dragListener.isTouch && !view.isEventSelected(event)) {\n            // if not previously selected, will fire after a delay. then, select the event\n            view.selectEvent(event);\n          }\n\n          isDragging = true;\n\n          _this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\n\n\n          _this.segDragStart(seg, ev);\n\n          view.hideEvent(event); // hide all event segments. our mouseFollower will take over\n        },\n        hitOver: function hitOver(hit, isOrig, origHit) {\n          var dragHelperEls; // starting hit could be forced (DayGrid.limit)\n\n          if (seg.hit) {\n            origHit = seg.hit;\n          } // since we are querying the parent view, might not belong to this grid\n\n\n          dropLocation = _this.computeEventDrop(origHit.component.getHitSpan(origHit), hit.component.getHitSpan(hit), event);\n\n          if (dropLocation && !calendar.isEventSpanAllowed(_this.eventToSpan(dropLocation), event)) {\n            disableCursor();\n            dropLocation = null;\n          } // if a valid drop location, have the subclass render a visual indication\n\n\n          if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {\n            dragHelperEls.addClass('fc-dragging');\n\n            if (!dragListener.isTouch) {\n              _this.applyDragOpacity(dragHelperEls);\n            }\n\n            mouseFollower.hide(); // if the subclass is already using a mock event \"helper\", hide our own\n          } else {\n            mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\n          }\n\n          if (isOrig) {\n            dropLocation = null; // needs to have moved hits to be a valid drop\n          }\n        },\n        hitOut: function hitOut() {\n          // called before mouse moves to a different hit OR moved out of all hits\n          view.unrenderDrag(); // unrender whatever was done in renderDrag\n\n          mouseFollower.show(); // show in case we are moving out of all hits\n\n          dropLocation = null;\n        },\n        hitDone: function hitDone() {\n          // Called after a hitOut OR before a dragEnd\n          enableCursor();\n        },\n        interactionEnd: function interactionEnd(ev) {\n          // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\n          mouseFollower.stop(!dropLocation, function () {\n            if (isDragging) {\n              view.unrenderDrag();\n              view.showEvent(event);\n\n              _this.segDragStop(seg, ev);\n            }\n\n            if (dropLocation) {\n              view.reportEventDrop(event, dropLocation, this.largeUnit, el, ev);\n            }\n          });\n          _this.segDragListener = null;\n        }\n      });\n      return dragListener;\n    },\n    // seg isn't draggable, but let's use a generic DragListener\n    // simply for the delay, so it can be selected.\n    // Has side effect of setting/unsetting `segDragListener`\n    buildSegSelectListener: function buildSegSelectListener(seg) {\n      var _this = this;\n\n      var view = this.view;\n      var event = seg.event;\n\n      if (this.segDragListener) {\n        return this.segDragListener;\n      }\n\n      var dragListener = this.segDragListener = new DragListener({\n        dragStart: function dragStart(ev) {\n          if (dragListener.isTouch && !view.isEventSelected(event)) {\n            // if not previously selected, will fire after a delay. then, select the event\n            view.selectEvent(event);\n          }\n        },\n        interactionEnd: function interactionEnd(ev) {\n          _this.segDragListener = null;\n        }\n      });\n      return dragListener;\n    },\n    // Called before event segment dragging starts\n    segDragStart: function segDragStart(seg, ev) {\n      this.isDraggingSeg = true;\n      this.view.trigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n    },\n    // Called after event segment dragging stops\n    segDragStop: function segDragStop(seg, ev) {\n      this.isDraggingSeg = false;\n      this.view.trigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n    },\n    // Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay\n    // values for the event. Subclasses may override and set additional properties to be used by renderDrag.\n    // A falsy returned value indicates an invalid drop.\n    // DOES NOT consider overlap/constraint.\n    computeEventDrop: function computeEventDrop(startSpan, endSpan, event) {\n      var calendar = this.view.calendar;\n      var dragStart = startSpan.start;\n      var dragEnd = endSpan.start;\n      var delta;\n      var dropLocation; // zoned event date properties\n\n      if (dragStart.hasTime() === dragEnd.hasTime()) {\n        delta = this.diffDates(dragEnd, dragStart); // if an all-day event was in a timed area and it was dragged to a different time,\n        // guarantee an end and adjust start/end to have times\n\n        if (event.allDay && durationHasTime(delta)) {\n          dropLocation = {\n            start: event.start.clone(),\n            end: calendar.getEventEnd(event),\n            // will be an ambig day\n            allDay: false // for normalizeEventTimes\n\n          };\n          calendar.normalizeEventTimes(dropLocation);\n        } // othewise, work off existing values\n        else {\n            dropLocation = {\n              start: event.start.clone(),\n              end: event.end ? event.end.clone() : null,\n              allDay: event.allDay // keep it the same\n\n            };\n          }\n\n        dropLocation.start.add(delta);\n\n        if (dropLocation.end) {\n          dropLocation.end.add(delta);\n        }\n      } else {\n        // if switching from day <-> timed, start should be reset to the dropped date, and the end cleared\n        dropLocation = {\n          start: dragEnd.clone(),\n          end: null,\n          // end should be cleared\n          allDay: !dragEnd.hasTime()\n        };\n      }\n\n      return dropLocation;\n    },\n    // Utility for apply dragOpacity to a jQuery set\n    applyDragOpacity: function applyDragOpacity(els) {\n      var opacity = this.view.opt('dragOpacity');\n\n      if (opacity != null) {\n        els.each(function (i, node) {\n          // Don't use jQuery (will set an IE filter), do it the old fashioned way.\n          // In IE8, a helper element will disappears if there's a filter.\n          node.style.opacity = opacity;\n        });\n      }\n    },\n\n    /* External Element Dragging\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Called when a jQuery UI drag is initiated anywhere in the DOM\n    externalDragStart: function externalDragStart(ev, ui) {\n      var view = this.view;\n      var el;\n      var accept;\n\n      if (view.opt('droppable')) {\n        // only listen if this setting is on\n        el = $((ui ? ui.item : null) || ev.target); // Test that the dragged element passes the dropAccept selector or filter function.\n        // FYI, the default is \"*\" (matches all)\n\n        accept = view.opt('dropAccept');\n\n        if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\n          if (!this.isDraggingExternal) {\n            // prevent double-listening if fired twice\n            this.listenToExternalDrag(el, ev, ui);\n          }\n        }\n      }\n    },\n    // Called when a jQuery UI drag starts and it needs to be monitored for dropping\n    listenToExternalDrag: function listenToExternalDrag(el, ev, ui) {\n      var _this = this;\n\n      var calendar = this.view.calendar;\n      var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\n\n      var dropLocation; // a null value signals an unsuccessful drag\n      // listener that tracks mouse movement over date-associated pixel regions\n\n      var dragListener = _this.externalDragListener = new HitDragListener(this, {\n        interactionStart: function interactionStart() {\n          _this.isDraggingExternal = true;\n        },\n        hitOver: function hitOver(hit) {\n          dropLocation = _this.computeExternalDrop(hit.component.getHitSpan(hit), // since we are querying the parent view, might not belong to this grid\n          meta);\n\n          if ( // invalid hit?\n          dropLocation && !calendar.isExternalSpanAllowed(_this.eventToSpan(dropLocation), dropLocation, meta.eventProps)) {\n            disableCursor();\n            dropLocation = null;\n          }\n\n          if (dropLocation) {\n            _this.renderDrag(dropLocation); // called without a seg parameter\n\n          }\n        },\n        hitOut: function hitOut() {\n          dropLocation = null; // signal unsuccessful\n        },\n        hitDone: function hitDone() {\n          // Called after a hitOut OR before a dragEnd\n          enableCursor();\n\n          _this.unrenderDrag();\n        },\n        interactionEnd: function interactionEnd(ev) {\n          if (dropLocation) {\n            // element was dropped on a valid hit\n            _this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);\n          }\n\n          _this.isDraggingExternal = false;\n          _this.externalDragListener = null;\n        }\n      });\n      dragListener.startDrag(ev); // start listening immediately\n    },\n    // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\n    // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\n    // Returning a null value signals an invalid drop hit.\n    // DOES NOT consider overlap/constraint.\n    computeExternalDrop: function computeExternalDrop(span, meta) {\n      var calendar = this.view.calendar;\n      var dropLocation = {\n        start: calendar.applyTimezone(span.start),\n        // simulate a zoned event start date\n        end: null\n      }; // if dropped on an all-day span, and element's metadata specified a time, set it\n\n      if (meta.startTime && !dropLocation.start.hasTime()) {\n        dropLocation.start.time(meta.startTime);\n      }\n\n      if (meta.duration) {\n        dropLocation.end = dropLocation.start.clone().add(meta.duration);\n      }\n\n      return dropLocation;\n    },\n\n    /* Drag Rendering (for both events and an external elements)\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of an event or external element being dragged.\n    // `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.\n    // `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.\n    // A truthy returned value indicates this method has rendered a helper element.\n    // Must return elements used for any mock events.\n    renderDrag: function renderDrag(dropLocation, seg) {// subclasses must implement\n    },\n    // Unrenders a visual indication of an event or external element being dragged\n    unrenderDrag: function unrenderDrag() {// subclasses must implement\n    },\n\n    /* Resizing\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Creates a listener that tracks the user as they resize an event segment.\n    // Generic enough to work with any type of Grid.\n    buildSegResizeListener: function buildSegResizeListener(seg, isStart) {\n      var _this = this;\n\n      var view = this.view;\n      var calendar = view.calendar;\n      var el = seg.el;\n      var event = seg.event;\n      var eventEnd = calendar.getEventEnd(event);\n      var isDragging;\n      var resizeLocation; // zoned event date properties. falsy if invalid resize\n      // Tracks mouse movement over the *grid's* coordinate map\n\n      var dragListener = this.segResizeListener = new HitDragListener(this, {\n        scroll: view.opt('dragScroll'),\n        subjectEl: el,\n        interactionStart: function interactionStart() {\n          isDragging = false;\n        },\n        dragStart: function dragStart(ev) {\n          isDragging = true;\n\n          _this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\n\n\n          _this.segResizeStart(seg, ev);\n        },\n        hitOver: function hitOver(hit, isOrig, origHit) {\n          var origHitSpan = _this.getHitSpan(origHit);\n\n          var hitSpan = _this.getHitSpan(hit);\n\n          resizeLocation = isStart ? _this.computeEventStartResize(origHitSpan, hitSpan, event) : _this.computeEventEndResize(origHitSpan, hitSpan, event);\n\n          if (resizeLocation) {\n            if (!calendar.isEventSpanAllowed(_this.eventToSpan(resizeLocation), event)) {\n              disableCursor();\n              resizeLocation = null;\n            } // no change? (TODO: how does this work with timezones?)\n            else if (resizeLocation.start.isSame(event.start) && resizeLocation.end.isSame(eventEnd)) {\n                resizeLocation = null;\n              }\n          }\n\n          if (resizeLocation) {\n            view.hideEvent(event);\n\n            _this.renderEventResize(resizeLocation, seg);\n          }\n        },\n        hitOut: function hitOut() {\n          // called before mouse moves to a different hit OR moved out of all hits\n          resizeLocation = null;\n        },\n        hitDone: function hitDone() {\n          // resets the rendering to show the original event\n          _this.unrenderEventResize();\n\n          view.showEvent(event);\n          enableCursor();\n        },\n        interactionEnd: function interactionEnd(ev) {\n          if (isDragging) {\n            _this.segResizeStop(seg, ev);\n          }\n\n          if (resizeLocation) {\n            // valid date to resize to?\n            view.reportEventResize(event, resizeLocation, this.largeUnit, el, ev);\n          }\n\n          _this.segResizeListener = null;\n        }\n      });\n      return dragListener;\n    },\n    // Called before event segment resizing starts\n    segResizeStart: function segResizeStart(seg, ev) {\n      this.isResizingSeg = true;\n      this.view.trigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n    },\n    // Called after event segment resizing stops\n    segResizeStop: function segResizeStop(seg, ev) {\n      this.isResizingSeg = false;\n      this.view.trigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n    },\n    // Returns new date-information for an event segment being resized from its start\n    computeEventStartResize: function computeEventStartResize(startSpan, endSpan, event) {\n      return this.computeEventResize('start', startSpan, endSpan, event);\n    },\n    // Returns new date-information for an event segment being resized from its end\n    computeEventEndResize: function computeEventEndResize(startSpan, endSpan, event) {\n      return this.computeEventResize('end', startSpan, endSpan, event);\n    },\n    // Returns new zoned date information for an event segment being resized from its start OR end\n    // `type` is either 'start' or 'end'.\n    // DOES NOT consider overlap/constraint.\n    computeEventResize: function computeEventResize(type, startSpan, endSpan, event) {\n      var calendar = this.view.calendar;\n      var delta = this.diffDates(endSpan[type], startSpan[type]);\n      var resizeLocation; // zoned event date properties\n\n      var defaultDuration; // build original values to work from, guaranteeing a start and end\n\n      resizeLocation = {\n        start: event.start.clone(),\n        end: calendar.getEventEnd(event),\n        allDay: event.allDay\n      }; // if an all-day event was in a timed area and was resized to a time, adjust start/end to have times\n\n      if (resizeLocation.allDay && durationHasTime(delta)) {\n        resizeLocation.allDay = false;\n        calendar.normalizeEventTimes(resizeLocation);\n      }\n\n      resizeLocation[type].add(delta); // apply delta to start or end\n      // if the event was compressed too small, find a new reasonable duration for it\n\n      if (!resizeLocation.start.isBefore(resizeLocation.end)) {\n        defaultDuration = this.minResizeDuration || ( // TODO: hack\n        event.allDay ? calendar.defaultAllDayEventDuration : calendar.defaultTimedEventDuration);\n\n        if (type == 'start') {\n          // resizing the start?\n          resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);\n        } else {\n          // resizing the end?\n          resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);\n        }\n      }\n\n      return resizeLocation;\n    },\n    // Renders a visual indication of an event being resized.\n    // `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.\n    // Must return elements used for any mock events.\n    renderEventResize: function renderEventResize(range, seg) {// subclasses must implement\n    },\n    // Unrenders a visual indication of an event being resized.\n    unrenderEventResize: function unrenderEventResize() {// subclasses must implement\n    },\n\n    /* Rendering Utils\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Compute the text that should be displayed on an event's element.\n    // `range` can be the Event object itself, or something range-like, with at least a `start`.\n    // If event times are disabled, or the event has no time, will return a blank string.\n    // If not specified, formatStr will default to the eventTimeFormat setting,\n    // and displayEnd will default to the displayEventEnd setting.\n    getEventTimeText: function getEventTimeText(range, formatStr, displayEnd) {\n      if (formatStr == null) {\n        formatStr = this.eventTimeFormat;\n      }\n\n      if (displayEnd == null) {\n        displayEnd = this.displayEventEnd;\n      }\n\n      if (this.displayEventTime && range.start.hasTime()) {\n        if (displayEnd && range.end) {\n          return this.view.formatRange(range, formatStr);\n        } else {\n          return range.start.format(formatStr);\n        }\n      }\n\n      return '';\n    },\n    // Generic utility for generating the HTML classNames for an event segment's element\n    getSegClasses: function getSegClasses(seg, isDraggable, isResizable) {\n      var view = this.view;\n      var event = seg.event;\n      var classes = ['fc-event', seg.isStart ? 'fc-start' : 'fc-not-start', seg.isEnd ? 'fc-end' : 'fc-not-end'].concat(event.className, event.source ? event.source.className : []);\n\n      if (isDraggable) {\n        classes.push('fc-draggable');\n      }\n\n      if (isResizable) {\n        classes.push('fc-resizable');\n      } // event is currently selected? attach a className.\n\n\n      if (view.isEventSelected(event)) {\n        classes.push('fc-selected');\n      }\n\n      return classes;\n    },\n    // Utility for generating event skin-related CSS properties\n    getSegSkinCss: function getSegSkinCss(seg) {\n      var event = seg.event;\n      var view = this.view;\n      var source = event.source || {};\n      var eventColor = event.color;\n      var sourceColor = source.color;\n      var optionColor = view.opt('eventColor');\n      return {\n        'background-color': event.backgroundColor || eventColor || source.backgroundColor || sourceColor || view.opt('eventBackgroundColor') || optionColor,\n        'border-color': event.borderColor || eventColor || source.borderColor || sourceColor || view.opt('eventBorderColor') || optionColor,\n        color: event.textColor || source.textColor || view.opt('eventTextColor')\n      };\n    },\n\n    /* Converting events -> eventRange -> eventSpan -> eventSegs\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates an array of segments for the given single event\n    // Can accept an event \"location\" as well (which only has start/end and no allDay)\n    eventToSegs: function eventToSegs(event) {\n      return this.eventsToSegs([event]);\n    },\n    eventToSpan: function eventToSpan(event) {\n      return this.eventToSpans(event)[0];\n    },\n    // Generates spans (always unzoned) for the given event.\n    // Does not do any inverting for inverse-background events.\n    // Can accept an event \"location\" as well (which only has start/end and no allDay)\n    eventToSpans: function eventToSpans(event) {\n      var range = this.eventToRange(event);\n      return this.eventRangeToSpans(range, event);\n    },\n    // Converts an array of event objects into an array of event segment objects.\n    // A custom `segSliceFunc` may be given for arbitrarily slicing up events.\n    // Doesn't guarantee an order for the resulting array.\n    eventsToSegs: function eventsToSegs(allEvents, segSliceFunc) {\n      var _this = this;\n\n      var eventsById = groupEventsById(allEvents);\n      var segs = [];\n      $.each(eventsById, function (id, events) {\n        var ranges = [];\n        var i;\n\n        for (i = 0; i < events.length; i++) {\n          ranges.push(_this.eventToRange(events[i]));\n        } // inverse-background events (utilize only the first event in calculations)\n\n\n        if (isInverseBgEvent(events[0])) {\n          ranges = _this.invertRanges(ranges);\n\n          for (i = 0; i < ranges.length; i++) {\n            segs.push.apply(segs, // append to\n            _this.eventRangeToSegs(ranges[i], events[0], segSliceFunc));\n          }\n        } // normal event ranges\n        else {\n            for (i = 0; i < ranges.length; i++) {\n              segs.push.apply(segs, // append to\n              _this.eventRangeToSegs(ranges[i], events[i], segSliceFunc));\n            }\n          }\n      });\n      return segs;\n    },\n    // Generates the unzoned start/end dates an event appears to occupy\n    // Can accept an event \"location\" as well (which only has start/end and no allDay)\n    eventToRange: function eventToRange(event) {\n      return {\n        start: event.start.clone().stripZone(),\n        end: (event.end ? event.end.clone() : // derive the end from the start and allDay. compute allDay if necessary\n        this.view.calendar.getDefaultEventEnd(event.allDay != null ? event.allDay : !event.start.hasTime(), event.start)).stripZone()\n      };\n    },\n    // Given an event's range (unzoned start/end), and the event itself,\n    // slice into segments (using the segSliceFunc function if specified)\n    eventRangeToSegs: function eventRangeToSegs(range, event, segSliceFunc) {\n      var spans = this.eventRangeToSpans(range, event);\n      var segs = [];\n      var i;\n\n      for (i = 0; i < spans.length; i++) {\n        segs.push.apply(segs, // append to\n        this.eventSpanToSegs(spans[i], event, segSliceFunc));\n      }\n\n      return segs;\n    },\n    // Given an event's unzoned date range, return an array of \"span\" objects.\n    // Subclasses can override.\n    eventRangeToSpans: function eventRangeToSpans(range, event) {\n      return [$.extend({}, range)]; // copy into a single-item array\n    },\n    // Given an event's span (unzoned start/end and other misc data), and the event itself,\n    // slices into segments and attaches event-derived properties to them.\n    eventSpanToSegs: function eventSpanToSegs(span, event, segSliceFunc) {\n      var segs = segSliceFunc ? segSliceFunc(span) : this.spanToSegs(span);\n      var i, seg;\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i];\n        seg.event = event;\n        seg.eventStartMS = +span.start; // TODO: not the best name after making spans unzoned\n\n        seg.eventDurationMS = span.end - span.start;\n      }\n\n      return segs;\n    },\n    // Produces a new array of range objects that will cover all the time NOT covered by the given ranges.\n    // SIDE EFFECT: will mutate the given array and will use its date references.\n    invertRanges: function invertRanges(ranges) {\n      var view = this.view;\n      var viewStart = view.start.clone(); // need a copy\n\n      var viewEnd = view.end.clone(); // need a copy\n\n      var inverseRanges = [];\n      var start = viewStart; // the end of the previous range. the start of the new range\n\n      var i, range; // ranges need to be in order. required for our date-walking algorithm\n\n      ranges.sort(compareRanges);\n\n      for (i = 0; i < ranges.length; i++) {\n        range = ranges[i]; // add the span of time before the event (if there is any)\n\n        if (range.start > start) {\n          // compare millisecond time (skip any ambig logic)\n          inverseRanges.push({\n            start: start,\n            end: range.start\n          });\n        }\n\n        start = range.end;\n      } // add the span of time after the last event (if there is any)\n\n\n      if (start < viewEnd) {\n        // compare millisecond time (skip any ambig logic)\n        inverseRanges.push({\n          start: start,\n          end: viewEnd\n        });\n      }\n\n      return inverseRanges;\n    },\n    sortEventSegs: function sortEventSegs(segs) {\n      segs.sort(proxy(this, 'compareEventSegs'));\n    },\n    // A cmp function for determining which segments should take visual priority\n    compareEventSegs: function compareEventSegs(seg1, seg2) {\n      return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first\n      seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first\n      seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)\n      compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);\n    }\n  });\n  /* Utilities\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  function isBgEvent(event) {\n    // returns true if background OR inverse-background\n    var rendering = getEventRendering(event);\n    return rendering === 'background' || rendering === 'inverse-background';\n  }\n\n  FC.isBgEvent = isBgEvent; // export\n\n  function isInverseBgEvent(event) {\n    return getEventRendering(event) === 'inverse-background';\n  }\n\n  function getEventRendering(event) {\n    return firstDefined((event.source || {}).rendering, event.rendering);\n  }\n\n  function groupEventsById(events) {\n    var eventsById = {};\n    var i, event;\n\n    for (i = 0; i < events.length; i++) {\n      event = events[i];\n      (eventsById[event._id] || (eventsById[event._id] = [])).push(event);\n    }\n\n    return eventsById;\n  } // A cmp function for determining which non-inverted \"ranges\" (see above) happen earlier\n\n\n  function compareRanges(range1, range2) {\n    return range1.start - range2.start; // earlier ranges go first\n  }\n  /* External-Dragging-Element Data\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\n  // A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\n\n\n  FC.dataAttrPrefix = ''; // Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\n  // to be used for Event Object creation.\n  // A defined `.eventProps`, even when empty, indicates that an event should be created.\n\n  function getDraggedElMeta(el) {\n    var prefix = FC.dataAttrPrefix;\n    var eventProps; // properties for creating the event, not related to date/time\n\n    var startTime; // a Duration\n\n    var duration;\n    var stick;\n\n    if (prefix) {\n      prefix += '-';\n    }\n\n    eventProps = el.data(prefix + 'event') || null;\n\n    if (eventProps) {\n      if (typeof eventProps === 'object') {\n        eventProps = $.extend({}, eventProps); // make a copy\n      } else {\n        // something like 1 or true. still signal event creation\n        eventProps = {};\n      } // pluck special-cased date/time properties\n\n\n      startTime = eventProps.start;\n\n      if (startTime == null) {\n        startTime = eventProps.time;\n      } // accept 'time' as well\n\n\n      duration = eventProps.duration;\n      stick = eventProps.stick;\n      delete eventProps.start;\n      delete eventProps.time;\n      delete eventProps.duration;\n      delete eventProps.stick;\n    } // fallback to standalone attribute values for each of the date/time properties\n\n\n    if (startTime == null) {\n      startTime = el.data(prefix + 'start');\n    }\n\n    if (startTime == null) {\n      startTime = el.data(prefix + 'time');\n    } // accept 'time' as well\n\n\n    if (duration == null) {\n      duration = el.data(prefix + 'duration');\n    }\n\n    if (stick == null) {\n      stick = el.data(prefix + 'stick');\n    } // massage into correct data types\n\n\n    startTime = startTime != null ? moment.duration(startTime) : null;\n    duration = duration != null ? moment.duration(duration) : null;\n    stick = Boolean(stick);\n    return {\n      eventProps: eventProps,\n      startTime: startTime,\n      duration: duration,\n      stick: stick\n    };\n  }\n\n  ;\n  ;\n  /*\n  A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\n  Prerequisite: the object being mixed into needs to be a *Grid*\n  */\n\n  var DayTableMixin = FC.DayTableMixin = {\n    breakOnWeeks: false,\n    // should create a new row for each week?\n    dayDates: null,\n    // whole-day dates for each column. left to right\n    dayIndices: null,\n    // for each day from start, the offset\n    daysPerRow: null,\n    rowCnt: null,\n    colCnt: null,\n    colHeadFormat: null,\n    // Populates internal variables used for date calculation and rendering\n    updateDayTable: function updateDayTable() {\n      var view = this.view;\n      var date = this.start.clone();\n      var dayIndex = -1;\n      var dayIndices = [];\n      var dayDates = [];\n      var daysPerRow;\n      var firstDay;\n      var rowCnt;\n\n      while (date.isBefore(this.end)) {\n        // loop each day from start to end\n        if (view.isHiddenDay(date)) {\n          dayIndices.push(dayIndex + 0.5); // mark that it's between indices\n        } else {\n          dayIndex++;\n          dayIndices.push(dayIndex);\n          dayDates.push(date.clone());\n        }\n\n        date.add(1, 'days');\n      }\n\n      if (this.breakOnWeeks) {\n        // count columns until the day-of-week repeats\n        firstDay = dayDates[0].day();\n\n        for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\n          if (dayDates[daysPerRow].day() == firstDay) {\n            break;\n          }\n        }\n\n        rowCnt = Math.ceil(dayDates.length / daysPerRow);\n      } else {\n        rowCnt = 1;\n        daysPerRow = dayDates.length;\n      }\n\n      this.dayDates = dayDates;\n      this.dayIndices = dayIndices;\n      this.daysPerRow = daysPerRow;\n      this.rowCnt = rowCnt;\n      this.updateDayTableCols();\n    },\n    // Computes and assigned the colCnt property and updates any options that may be computed from it\n    updateDayTableCols: function updateDayTableCols() {\n      this.colCnt = this.computeColCnt();\n      this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();\n    },\n    // Determines how many columns there should be in the table\n    computeColCnt: function computeColCnt() {\n      return this.daysPerRow;\n    },\n    // Computes the ambiguously-timed moment for the given cell\n    getCellDate: function getCellDate(row, col) {\n      return this.dayDates[this.getCellDayIndex(row, col)].clone();\n    },\n    // Computes the ambiguously-timed date range for the given cell\n    getCellRange: function getCellRange(row, col) {\n      var start = this.getCellDate(row, col);\n      var end = start.clone().add(1, 'days');\n      return {\n        start: start,\n        end: end\n      };\n    },\n    // Returns the number of day cells, chronologically, from the first of the grid (0-based)\n    getCellDayIndex: function getCellDayIndex(row, col) {\n      return row * this.daysPerRow + this.getColDayIndex(col);\n    },\n    // Returns the numner of day cells, chronologically, from the first cell in *any given row*\n    getColDayIndex: function getColDayIndex(col) {\n      if (this.isRTL) {\n        return this.colCnt - 1 - col;\n      } else {\n        return col;\n      }\n    },\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    getDateDayIndex: function getDateDayIndex(date) {\n      var dayIndices = this.dayIndices;\n      var dayOffset = date.diff(this.start, 'days');\n\n      if (dayOffset < 0) {\n        return dayIndices[0] - 1;\n      } else if (dayOffset >= dayIndices.length) {\n        return dayIndices[dayIndices.length - 1] + 1;\n      } else {\n        return dayIndices[dayOffset];\n      }\n    },\n\n    /* Options\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Computes a default column header formatting string if `colFormat` is not explicitly defined\n    computeColHeadFormat: function computeColHeadFormat() {\n      // if more than one week row, or if there are a lot of columns with not much space,\n      // put just the day numbers will be in each cell\n      if (this.rowCnt > 1 || this.colCnt > 10) {\n        return 'ddd'; // \"Sat\"\n      } // multiple days, so full single date string WON'T be in title text\n      else if (this.colCnt > 1) {\n          return this.view.opt('dayOfMonthFormat'); // \"Sat 12/10\"\n        } // single day, so full single date string will probably be in title text\n        else {\n            return 'dddd'; // \"Saturday\"\n          }\n    },\n\n    /* Slicing\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Slices up a date range into a segment for every week-row it intersects with\n    sliceRangeByRow: function sliceRangeByRow(range) {\n      var daysPerRow = this.daysPerRow;\n      var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\n\n      var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n\n      var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n\n      var segs = [];\n      var row;\n      var rowFirst, rowLast; // inclusive day-index range for current row\n\n      var segFirst, segLast; // inclusive day-index range for segment\n\n      for (row = 0; row < this.rowCnt; row++) {\n        rowFirst = row * daysPerRow;\n        rowLast = rowFirst + daysPerRow - 1; // intersect segment's offset range with the row's\n\n        segFirst = Math.max(rangeFirst, rowFirst);\n        segLast = Math.min(rangeLast, rowLast); // deal with in-between indices\n\n        segFirst = Math.ceil(segFirst); // in-between starts round to next cell\n\n        segLast = Math.floor(segLast); // in-between ends round to prev cell\n\n        if (segFirst <= segLast) {\n          // was there any intersection with the current row?\n          segs.push({\n            row: row,\n            // normalize to start of row\n            firstRowDayIndex: segFirst - rowFirst,\n            lastRowDayIndex: segLast - rowFirst,\n            // must be matching integers to be the segment's start/end\n            isStart: segFirst === rangeFirst,\n            isEnd: segLast === rangeLast\n          });\n        }\n      }\n\n      return segs;\n    },\n    // Slices up a date range into a segment for every day-cell it intersects with.\n    // TODO: make more DRY with sliceRangeByRow somehow.\n    sliceRangeByDay: function sliceRangeByDay(range) {\n      var daysPerRow = this.daysPerRow;\n      var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\n\n      var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n\n      var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n\n      var segs = [];\n      var row;\n      var rowFirst, rowLast; // inclusive day-index range for current row\n\n      var i;\n      var segFirst, segLast; // inclusive day-index range for segment\n\n      for (row = 0; row < this.rowCnt; row++) {\n        rowFirst = row * daysPerRow;\n        rowLast = rowFirst + daysPerRow - 1;\n\n        for (i = rowFirst; i <= rowLast; i++) {\n          // intersect segment's offset range with the row's\n          segFirst = Math.max(rangeFirst, i);\n          segLast = Math.min(rangeLast, i); // deal with in-between indices\n\n          segFirst = Math.ceil(segFirst); // in-between starts round to next cell\n\n          segLast = Math.floor(segLast); // in-between ends round to prev cell\n\n          if (segFirst <= segLast) {\n            // was there any intersection with the current row?\n            segs.push({\n              row: row,\n              // normalize to start of row\n              firstRowDayIndex: segFirst - rowFirst,\n              lastRowDayIndex: segLast - rowFirst,\n              // must be matching integers to be the segment's start/end\n              isStart: segFirst === rangeFirst,\n              isEnd: segLast === rangeLast\n            });\n          }\n        }\n      }\n\n      return segs;\n    },\n\n    /* Header Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderHeadHtml: function renderHeadHtml() {\n      var view = this.view;\n      return '' + '<div class=\"fc-row ' + view.widgetHeaderClass + '\">' + '<table>' + '<thead>' + this.renderHeadTrHtml() + '</thead>' + '</table>' + '</div>';\n    },\n    renderHeadIntroHtml: function renderHeadIntroHtml() {\n      return this.renderIntroHtml(); // fall back to generic\n    },\n    renderHeadTrHtml: function renderHeadTrHtml() {\n      return '' + '<tr>' + (this.isRTL ? '' : this.renderHeadIntroHtml()) + this.renderHeadDateCellsHtml() + (this.isRTL ? this.renderHeadIntroHtml() : '') + '</tr>';\n    },\n    renderHeadDateCellsHtml: function renderHeadDateCellsHtml() {\n      var htmls = [];\n      var col, date;\n\n      for (col = 0; col < this.colCnt; col++) {\n        date = this.getCellDate(0, col);\n        htmls.push(this.renderHeadDateCellHtml(date));\n      }\n\n      return htmls.join('');\n    },\n    // TODO: when internalApiVersion, accept an object for HTML attributes\n    // (colspan should be no different)\n    renderHeadDateCellHtml: function renderHeadDateCellHtml(date, colspan, otherAttrs) {\n      var view = this.view;\n      return '' + '<th class=\"fc-day-header ' + view.widgetHeaderClass + ' fc-' + dayIDs[date.day()] + '\"' + (this.rowCnt == 1 ? ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' : '') + (colspan > 1 ? ' colspan=\"' + colspan + '\"' : '') + (otherAttrs ? ' ' + otherAttrs : '') + '>' + htmlEscape(date.format(this.colHeadFormat)) + '</th>';\n    },\n\n    /* Background Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderBgTrHtml: function renderBgTrHtml(row) {\n      return '' + '<tr>' + (this.isRTL ? '' : this.renderBgIntroHtml(row)) + this.renderBgCellsHtml(row) + (this.isRTL ? this.renderBgIntroHtml(row) : '') + '</tr>';\n    },\n    renderBgIntroHtml: function renderBgIntroHtml(row) {\n      return this.renderIntroHtml(); // fall back to generic\n    },\n    renderBgCellsHtml: function renderBgCellsHtml(row) {\n      var htmls = [];\n      var col, date;\n\n      for (col = 0; col < this.colCnt; col++) {\n        date = this.getCellDate(row, col);\n        htmls.push(this.renderBgCellHtml(date));\n      }\n\n      return htmls.join('');\n    },\n    renderBgCellHtml: function renderBgCellHtml(date, otherAttrs) {\n      var view = this.view;\n      var classes = this.getDayClasses(date);\n      classes.unshift('fc-day', view.widgetContentClass);\n      return '<td class=\"' + classes.join(' ') + '\"' + ' data-date=\"' + date.format('YYYY-MM-DD') + '\"' + ( // if date has a time, won't format it\n      otherAttrs ? ' ' + otherAttrs : '') + '></td>';\n    },\n\n    /* Generic\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the default HTML intro for any row. User classes should override\n    renderIntroHtml: function renderIntroHtml() {},\n    // TODO: a generic method for dealing with <tr>, RTL, intro\n    // when increment internalApiVersion\n    // wrapTr (scheduler)\n\n    /* Utils\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Applies the generic \"intro\" and \"outro\" HTML to the given cells.\n    // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\n    bookendCells: function bookendCells(trEl) {\n      var introHtml = this.renderIntroHtml();\n\n      if (introHtml) {\n        if (this.isRTL) {\n          trEl.append(introHtml);\n        } else {\n          trEl.prepend(introHtml);\n        }\n      }\n    }\n  };\n  ;\n  ;\n  /* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {\n    numbersVisible: false,\n    // should render a row for day/week numbers? set by outside view. TODO: make internal\n    bottomCoordPadding: 0,\n    // hack for extending the hit area for the last row of the coordinate grid\n    rowEls: null,\n    // set of fake row elements\n    cellEls: null,\n    // set of whole-day elements comprising the row's background\n    helperEls: null,\n    // set of cell skeleton elements for rendering the mock event \"helper\"\n    rowCoordCache: null,\n    colCoordCache: null,\n    // Renders the rows and columns into the component's `this.el`, which should already be assigned.\n    // isRigid determins whether the individual rows should ignore the contents and be a constant height.\n    // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\n    renderDates: function renderDates(isRigid) {\n      var view = this.view;\n      var rowCnt = this.rowCnt;\n      var colCnt = this.colCnt;\n      var html = '';\n      var row;\n      var col;\n\n      for (row = 0; row < rowCnt; row++) {\n        html += this.renderDayRowHtml(row, isRigid);\n      }\n\n      this.el.html(html);\n      this.rowEls = this.el.find('.fc-row');\n      this.cellEls = this.el.find('.fc-day');\n      this.rowCoordCache = new CoordCache({\n        els: this.rowEls,\n        isVertical: true\n      });\n      this.colCoordCache = new CoordCache({\n        els: this.cellEls.slice(0, this.colCnt),\n        // only the first row\n        isHorizontal: true\n      }); // trigger dayRender with each cell's element\n\n      for (row = 0; row < rowCnt; row++) {\n        for (col = 0; col < colCnt; col++) {\n          view.trigger('dayRender', null, this.getCellDate(row, col), this.getCellEl(row, col));\n        }\n      }\n    },\n    unrenderDates: function unrenderDates() {\n      this.removeSegPopover();\n    },\n    renderBusinessHours: function renderBusinessHours() {\n      var events = this.view.calendar.getBusinessHoursEvents(true); // wholeDay=true\n\n      var segs = this.eventsToSegs(events);\n      this.renderFill('businessHours', segs, 'bgevent');\n    },\n    unrenderBusinessHours: function unrenderBusinessHours() {\n      this.unrenderFill('businessHours');\n    },\n    // Generates the HTML for a single row, which is a div that wraps a table.\n    // `row` is the row number.\n    renderDayRowHtml: function renderDayRowHtml(row, isRigid) {\n      var view = this.view;\n      var classes = ['fc-row', 'fc-week', view.widgetContentClass];\n\n      if (isRigid) {\n        classes.push('fc-rigid');\n      }\n\n      return '' + '<div class=\"' + classes.join(' ') + '\">' + '<div class=\"fc-bg\">' + '<table>' + this.renderBgTrHtml(row) + '</table>' + '</div>' + '<div class=\"fc-content-skeleton\">' + '<table>' + (this.numbersVisible ? '<thead>' + this.renderNumberTrHtml(row) + '</thead>' : '') + '</table>' + '</div>' + '</div>';\n    },\n\n    /* Grid Number Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderNumberTrHtml: function renderNumberTrHtml(row) {\n      return '' + '<tr>' + (this.isRTL ? '' : this.renderNumberIntroHtml(row)) + this.renderNumberCellsHtml(row) + (this.isRTL ? this.renderNumberIntroHtml(row) : '') + '</tr>';\n    },\n    renderNumberIntroHtml: function renderNumberIntroHtml(row) {\n      return this.renderIntroHtml();\n    },\n    renderNumberCellsHtml: function renderNumberCellsHtml(row) {\n      var htmls = [];\n      var col, date;\n\n      for (col = 0; col < this.colCnt; col++) {\n        date = this.getCellDate(row, col);\n        htmls.push(this.renderNumberCellHtml(date));\n      }\n\n      return htmls.join('');\n    },\n    // Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\n    // The number row will only exist if either day numbers or week numbers are turned on.\n    renderNumberCellHtml: function renderNumberCellHtml(date) {\n      var classes;\n\n      if (!this.view.dayNumbersVisible) {\n        // if there are week numbers but not day numbers\n        return '<td/>'; //  will create an empty space above events :(\n      }\n\n      classes = this.getDayClasses(date);\n      classes.unshift('fc-day-number');\n      return '' + '<td class=\"' + classes.join(' ') + '\" data-date=\"' + date.format() + '\">' + date.date() + '</td>';\n    },\n\n    /* Options\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n    computeEventTimeFormat: function computeEventTimeFormat() {\n      return this.view.opt('extraSmallTimeFormat'); // like \"6p\" or \"6:30p\"\n    },\n    // Computes a default `displayEventEnd` value if one is not expliclty defined\n    computeDisplayEventEnd: function computeDisplayEventEnd() {\n      return this.colCnt == 1; // we'll likely have space if there's only one day\n    },\n\n    /* Dates\n    ------------------------------------------------------------------------------------------------------------------*/\n    rangeUpdated: function rangeUpdated() {\n      this.updateDayTable();\n    },\n    // Slices up the given span (unzoned start/end with other misc data) into an array of segments\n    spanToSegs: function spanToSegs(span) {\n      var segs = this.sliceRangeByRow(span);\n      var i, seg;\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i];\n\n        if (this.isRTL) {\n          seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\n          seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\n        } else {\n          seg.leftCol = seg.firstRowDayIndex;\n          seg.rightCol = seg.lastRowDayIndex;\n        }\n      }\n\n      return segs;\n    },\n\n    /* Hit System\n    ------------------------------------------------------------------------------------------------------------------*/\n    prepareHits: function prepareHits() {\n      this.colCoordCache.build();\n      this.rowCoordCache.build();\n      this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\n    },\n    releaseHits: function releaseHits() {\n      this.colCoordCache.clear();\n      this.rowCoordCache.clear();\n    },\n    queryHit: function queryHit(leftOffset, topOffset) {\n      var col = this.colCoordCache.getHorizontalIndex(leftOffset);\n      var row = this.rowCoordCache.getVerticalIndex(topOffset);\n\n      if (row != null && col != null) {\n        return this.getCellHit(row, col);\n      }\n    },\n    getHitSpan: function getHitSpan(hit) {\n      return this.getCellRange(hit.row, hit.col);\n    },\n    getHitEl: function getHitEl(hit) {\n      return this.getCellEl(hit.row, hit.col);\n    },\n\n    /* Cell System\n    ------------------------------------------------------------------------------------------------------------------*/\n    // FYI: the first column is the leftmost column, regardless of date\n    getCellHit: function getCellHit(row, col) {\n      return {\n        row: row,\n        col: col,\n        component: this,\n        // needed unfortunately :(\n        left: this.colCoordCache.getLeftOffset(col),\n        right: this.colCoordCache.getRightOffset(col),\n        top: this.rowCoordCache.getTopOffset(row),\n        bottom: this.rowCoordCache.getBottomOffset(row)\n      };\n    },\n    getCellEl: function getCellEl(row, col) {\n      return this.cellEls.eq(row * this.colCnt + col);\n    },\n\n    /* Event Drag Visualization\n    ------------------------------------------------------------------------------------------------------------------*/\n    // TODO: move to DayGrid.event, similar to what we did with Grid's drag methods\n    // Renders a visual indication of an event or external element being dragged.\n    // `eventLocation` has zoned start and end (optional)\n    renderDrag: function renderDrag(eventLocation, seg) {\n      // always render a highlight underneath\n      this.renderHighlight(this.eventToSpan(eventLocation)); // if a segment from the same calendar but another component is being dragged, render a helper event\n\n      if (seg && !seg.el.closest(this.el).length) {\n        return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n      }\n    },\n    // Unrenders any visual indication of a hovering event\n    unrenderDrag: function unrenderDrag() {\n      this.unrenderHighlight();\n      this.unrenderHelper();\n    },\n\n    /* Event Resize Visualization\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of an event being resized\n    renderEventResize: function renderEventResize(eventLocation, seg) {\n      this.renderHighlight(this.eventToSpan(eventLocation));\n      return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n    },\n    // Unrenders a visual indication of an event being resized\n    unrenderEventResize: function unrenderEventResize() {\n      this.unrenderHighlight();\n      this.unrenderHelper();\n    },\n\n    /* Event Helper\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a mock \"helper\" event. `sourceSeg` is the associated internal segment object. It can be null.\n    renderHelper: function renderHelper(event, sourceSeg) {\n      var helperNodes = [];\n      var segs = this.eventToSegs(event);\n      var rowStructs;\n      segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered\n\n      rowStructs = this.renderSegRows(segs); // inject each new event skeleton into each associated row\n\n      this.rowEls.each(function (row, rowNode) {\n        var rowEl = $(rowNode); // the .fc-row\n\n        var skeletonEl = $('<div class=\"fc-helper-skeleton\"><table/></div>'); // will be absolutely positioned\n\n        var skeletonTop; // If there is an original segment, match the top position. Otherwise, put it at the row's top level\n\n        if (sourceSeg && sourceSeg.row === row) {\n          skeletonTop = sourceSeg.el.position().top;\n        } else {\n          skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;\n        }\n\n        skeletonEl.css('top', skeletonTop).find('table').append(rowStructs[row].tbodyEl);\n        rowEl.append(skeletonEl);\n        helperNodes.push(skeletonEl[0]);\n      });\n      return (// must return the elements rendered\n        this.helperEls = $(helperNodes) // array -> jQuery set\n\n      );\n    },\n    // Unrenders any visual indication of a mock helper event\n    unrenderHelper: function unrenderHelper() {\n      if (this.helperEls) {\n        this.helperEls.remove();\n        this.helperEls = null;\n      }\n    },\n\n    /* Fill System (highlight, background events, business hours)\n    ------------------------------------------------------------------------------------------------------------------*/\n    fillSegTag: 'td',\n    // override the default tag name\n    // Renders a set of rectangles over the given segments of days.\n    // Only returns segments that successfully rendered.\n    renderFill: function renderFill(type, segs, className) {\n      var nodes = [];\n      var i, seg;\n      var skeletonEl;\n      segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i];\n        skeletonEl = this.renderFillRow(type, seg, className);\n        this.rowEls.eq(seg.row).append(skeletonEl);\n        nodes.push(skeletonEl[0]);\n      }\n\n      this.elsByFill[type] = $(nodes);\n      return segs;\n    },\n    // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\n    renderFillRow: function renderFillRow(type, seg, className) {\n      var colCnt = this.colCnt;\n      var startCol = seg.leftCol;\n      var endCol = seg.rightCol + 1;\n      var skeletonEl;\n      var trEl;\n      className = className || type.toLowerCase();\n      skeletonEl = $('<div class=\"fc-' + className + '-skeleton\">' + '<table><tr/></table>' + '</div>');\n      trEl = skeletonEl.find('tr');\n\n      if (startCol > 0) {\n        trEl.append('<td colspan=\"' + startCol + '\"/>');\n      }\n\n      trEl.append(seg.el.attr('colspan', endCol - startCol));\n\n      if (endCol < colCnt) {\n        trEl.append('<td colspan=\"' + (colCnt - endCol) + '\"/>');\n      }\n\n      this.bookendCells(trEl);\n      return skeletonEl;\n    }\n  });\n  ;\n  ;\n  /* Event-rendering methods for the DayGrid class\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  DayGrid.mixin({\n    rowStructs: null,\n    // an array of objects, each holding information about a row's foreground event-rendering\n    // Unrenders all events currently rendered on the grid\n    unrenderEvents: function unrenderEvents() {\n      this.removeSegPopover(); // removes the \"more..\" events popover\n\n      Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method\n    },\n    // Retrieves all rendered segment objects currently rendered on the grid\n    getEventSegs: function getEventSegs() {\n      return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method\n      .concat(this.popoverSegs || []); // append the segments from the \"more...\" popover\n    },\n    // Renders the given background event segments onto the grid\n    renderBgSegs: function renderBgSegs(segs) {\n      // don't render timed background events\n      var allDaySegs = $.grep(segs, function (seg) {\n        return seg.event.allDay;\n      });\n      return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method\n    },\n    // Renders the given foreground event segments onto the grid\n    renderFgSegs: function renderFgSegs(segs) {\n      var rowStructs; // render an `.el` on each seg\n      // returns a subset of the segs. segs that were actually rendered\n\n      segs = this.renderFgSegEls(segs);\n      rowStructs = this.rowStructs = this.renderSegRows(segs); // append to each row's content skeleton\n\n      this.rowEls.each(function (i, rowNode) {\n        $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);\n      });\n      return segs; // return only the segs that were actually rendered\n    },\n    // Unrenders all currently rendered foreground event segments\n    unrenderFgSegs: function unrenderFgSegs() {\n      var rowStructs = this.rowStructs || [];\n      var rowStruct;\n\n      while (rowStruct = rowStructs.pop()) {\n        rowStruct.tbodyEl.remove();\n      }\n\n      this.rowStructs = null;\n    },\n    // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\n    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\n    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`\n    renderSegRows: function renderSegRows(segs) {\n      var rowStructs = [];\n      var segRows;\n      var row;\n      segRows = this.groupSegRows(segs); // group into nested arrays\n      // iterate each row of segment groupings\n\n      for (row = 0; row < segRows.length; row++) {\n        rowStructs.push(this.renderSegRow(row, segRows[row]));\n      }\n\n      return rowStructs;\n    },\n    // Builds the HTML to be used for the default element for an individual segment\n    fgSegHtml: function fgSegHtml(seg, disableResizing) {\n      var view = this.view;\n      var event = seg.event;\n      var isDraggable = view.isEventDraggable(event);\n      var isResizableFromStart = !disableResizing && event.allDay && seg.isStart && view.isEventResizableFromStart(event);\n      var isResizableFromEnd = !disableResizing && event.allDay && seg.isEnd && view.isEventResizableFromEnd(event);\n      var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n      var skinCss = cssToStr(this.getSegSkinCss(seg));\n      var timeHtml = '';\n      var timeText;\n      var titleHtml;\n      classes.unshift('fc-day-grid-event', 'fc-h-event'); // Only display a timed events time if it is the starting segment\n\n      if (seg.isStart) {\n        timeText = this.getEventTimeText(event);\n\n        if (timeText) {\n          timeHtml = '<span class=\"fc-time\">' + htmlEscape(timeText) + '</span>';\n        }\n      }\n\n      titleHtml = '<span class=\"fc-title\">' + (htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height\n      '</span>';\n      return '<a class=\"' + classes.join(' ') + '\"' + (event.url ? ' href=\"' + htmlEscape(event.url) + '\"' : '') + (skinCss ? ' style=\"' + skinCss + '\"' : '') + '>' + '<div class=\"fc-content\">' + (this.isRTL ? titleHtml + ' ' + timeHtml : // put a natural space in between\n      timeHtml + ' ' + titleHtml //\n      ) + '</div>' + (isResizableFromStart ? '<div class=\"fc-resizer fc-start-resizer\" />' : '') + (isResizableFromEnd ? '<div class=\"fc-resizer fc-end-resizer\" />' : '') + '</a>';\n    },\n    // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\n    // the segments. Returns object with a bunch of internal data about how the render was calculated.\n    // NOTE: modifies rowSegs\n    renderSegRow: function renderSegRow(row, rowSegs) {\n      var colCnt = this.colCnt;\n      var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\n\n      var levelCnt = Math.max(1, segLevels.length); // ensure at least one level\n\n      var tbody = $('<tbody/>');\n      var segMatrix = []; // lookup for which segments are rendered into which level+col cells\n\n      var cellMatrix = []; // lookup for all <td> elements of the level+col matrix\n\n      var loneCellMatrix = []; // lookup for <td> elements that only take up a single column\n\n      var i, levelSegs;\n      var col;\n      var tr;\n      var j, seg;\n      var td; // populates empty cells from the current column (`col`) to `endCol`\n\n      function emptyCellsUntil(endCol) {\n        while (col < endCol) {\n          // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\n          td = (loneCellMatrix[i - 1] || [])[col];\n\n          if (td) {\n            td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);\n          } else {\n            td = $('<td/>');\n            tr.append(td);\n          }\n\n          cellMatrix[i][col] = td;\n          loneCellMatrix[i][col] = td;\n          col++;\n        }\n      }\n\n      for (i = 0; i < levelCnt; i++) {\n        // iterate through all levels\n        levelSegs = segLevels[i];\n        col = 0;\n        tr = $('<tr/>');\n        segMatrix.push([]);\n        cellMatrix.push([]);\n        loneCellMatrix.push([]); // levelCnt might be 1 even though there are no actual levels. protect against this.\n        // this single empty row is useful for styling.\n\n        if (levelSegs) {\n          for (j = 0; j < levelSegs.length; j++) {\n            // iterate through segments in level\n            seg = levelSegs[j];\n            emptyCellsUntil(seg.leftCol); // create a container that occupies or more columns. append the event element.\n\n            td = $('<td class=\"fc-event-container\"/>').append(seg.el);\n\n            if (seg.leftCol != seg.rightCol) {\n              td.attr('colspan', seg.rightCol - seg.leftCol + 1);\n            } else {\n              // a single-column segment\n              loneCellMatrix[i][col] = td;\n            }\n\n            while (col <= seg.rightCol) {\n              cellMatrix[i][col] = td;\n              segMatrix[i][col] = seg;\n              col++;\n            }\n\n            tr.append(td);\n          }\n        }\n\n        emptyCellsUntil(colCnt); // finish off the row\n\n        this.bookendCells(tr);\n        tbody.append(tr);\n      }\n\n      return {\n        // a \"rowStruct\"\n        row: row,\n        // the row number\n        tbodyEl: tbody,\n        cellMatrix: cellMatrix,\n        segMatrix: segMatrix,\n        segLevels: segLevels,\n        segs: rowSegs\n      };\n    },\n    // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\n    // NOTE: modifies segs\n    buildSegLevels: function buildSegLevels(segs) {\n      var levels = [];\n      var i, seg;\n      var j; // Give preference to elements with certain criteria, so they have\n      // a chance to be closer to the top.\n\n      this.sortEventSegs(segs);\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i]; // loop through levels, starting with the topmost, until the segment doesn't collide with other segments\n\n        for (j = 0; j < levels.length; j++) {\n          if (!isDaySegCollision(seg, levels[j])) {\n            break;\n          }\n        } // `j` now holds the desired subrow index\n\n\n        seg.level = j; // create new level array if needed and append segment\n\n        (levels[j] || (levels[j] = [])).push(seg);\n      } // order segments left-to-right. very important if calendar is RTL\n\n\n      for (j = 0; j < levels.length; j++) {\n        levels[j].sort(compareDaySegCols);\n      }\n\n      return levels;\n    },\n    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\n    groupSegRows: function groupSegRows(segs) {\n      var segRows = [];\n      var i;\n\n      for (i = 0; i < this.rowCnt; i++) {\n        segRows.push([]);\n      }\n\n      for (i = 0; i < segs.length; i++) {\n        segRows[segs[i].row].push(segs[i]);\n      }\n\n      return segRows;\n    }\n  }); // Computes whether two segments' columns collide. They are assumed to be in the same row.\n\n  function isDaySegCollision(seg, otherSegs) {\n    var i, otherSeg;\n\n    for (i = 0; i < otherSegs.length; i++) {\n      otherSeg = otherSegs[i];\n\n      if (otherSeg.leftCol <= seg.rightCol && otherSeg.rightCol >= seg.leftCol) {\n        return true;\n      }\n    }\n\n    return false;\n  } // A cmp function for determining the leftmost event\n\n\n  function compareDaySegCols(a, b) {\n    return a.leftCol - b.leftCol;\n  }\n\n  ;\n  ;\n  /* Methods relate to limiting the number events for a given day on a DayGrid\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // NOTE: all the segs being passed around in here are foreground segs\n\n  DayGrid.mixin({\n    segPopover: null,\n    // the Popover that holds events that can't fit in a cell. null when not visible\n    popoverSegs: null,\n    // an array of segment objects that the segPopover holds. null when not visible\n    removeSegPopover: function removeSegPopover() {\n      if (this.segPopover) {\n        this.segPopover.hide(); // in handler, will call segPopover's removeElement\n      }\n    },\n    // Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\n    // `levelLimit` can be false (don't limit), a number, or true (should be computed).\n    limitRows: function limitRows(levelLimit) {\n      var rowStructs = this.rowStructs || [];\n      var row; // row #\n\n      var rowLevelLimit;\n\n      for (row = 0; row < rowStructs.length; row++) {\n        this.unlimitRow(row);\n\n        if (!levelLimit) {\n          rowLevelLimit = false;\n        } else if (typeof levelLimit === 'number') {\n          rowLevelLimit = levelLimit;\n        } else {\n          rowLevelLimit = this.computeRowLevelLimit(row);\n        }\n\n        if (rowLevelLimit !== false) {\n          this.limitRow(row, rowLevelLimit);\n        }\n      }\n    },\n    // Computes the number of levels a row will accomodate without going outside its bounds.\n    // Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\n    // `row` is the row number.\n    computeRowLevelLimit: function computeRowLevelLimit(row) {\n      var rowEl = this.rowEls.eq(row); // the containing \"fake\" row div\n\n      var rowHeight = rowEl.height(); // TODO: cache somehow?\n\n      var trEls = this.rowStructs[row].tbodyEl.children();\n      var i, trEl;\n      var trHeight;\n\n      function iterInnerHeights(i, childNode) {\n        trHeight = Math.max(trHeight, $(childNode).outerHeight());\n      } // Reveal one level <tr> at a time and stop when we find one out of bounds\n\n\n      for (i = 0; i < trEls.length; i++) {\n        trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\n        // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\n        // so instead, find the tallest inner content element.\n\n        trHeight = 0;\n        trEl.find('> td > :first-child').each(iterInnerHeights);\n\n        if (trEl.position().top + trHeight > rowHeight) {\n          return i;\n        }\n      }\n\n      return false; // should not limit at all\n    },\n    // Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\n    // `row` is the row number.\n    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\n    limitRow: function limitRow(row, levelLimit) {\n      var _this = this;\n\n      var rowStruct = this.rowStructs[row];\n      var moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\n\n      var col = 0; // col #, left-to-right (not chronologically)\n\n      var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\n\n      var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\n\n      var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\n\n      var i, seg;\n      var segsBelow; // array of segment objects below `seg` in the current `col`\n\n      var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\n\n      var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\n\n      var td, rowspan;\n      var segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\n\n      var j;\n      var moreTd, moreWrap, moreLink; // Iterates through empty level cells and places \"more\" links inside if need be\n\n      function emptyCellsUntil(endCol) {\n        // goes from current `col` to `endCol`\n        while (col < endCol) {\n          segsBelow = _this.getCellSegs(row, col, levelLimit);\n\n          if (segsBelow.length) {\n            td = cellMatrix[levelLimit - 1][col];\n            moreLink = _this.renderMoreLink(row, col, segsBelow);\n            moreWrap = $('<div/>').append(moreLink);\n            td.append(moreWrap);\n            moreNodes.push(moreWrap[0]);\n          }\n\n          col++;\n        }\n      }\n\n      if (levelLimit && levelLimit < rowStruct.segLevels.length) {\n        // is it actually over the limit?\n        levelSegs = rowStruct.segLevels[levelLimit - 1];\n        cellMatrix = rowStruct.cellMatrix;\n        limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\n        .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\n        // iterate though segments in the last allowable level\n\n        for (i = 0; i < levelSegs.length; i++) {\n          seg = levelSegs[i];\n          emptyCellsUntil(seg.leftCol); // process empty cells before the segment\n          // determine *all* segments below `seg` that occupy the same columns\n\n          colSegsBelow = [];\n          totalSegsBelow = 0;\n\n          while (col <= seg.rightCol) {\n            segsBelow = this.getCellSegs(row, col, levelLimit);\n            colSegsBelow.push(segsBelow);\n            totalSegsBelow += segsBelow.length;\n            col++;\n          }\n\n          if (totalSegsBelow) {\n            // do we need to replace this segment with one or many \"more\" links?\n            td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\n\n            rowspan = td.attr('rowspan') || 1;\n            segMoreNodes = []; // make a replacement <td> for each column the segment occupies. will be one for each colspan\n\n            for (j = 0; j < colSegsBelow.length; j++) {\n              moreTd = $('<td class=\"fc-more-cell\"/>').attr('rowspan', rowspan);\n              segsBelow = colSegsBelow[j];\n              moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too\n              );\n              moreWrap = $('<div/>').append(moreLink);\n              moreTd.append(moreWrap);\n              segMoreNodes.push(moreTd[0]);\n              moreNodes.push(moreTd[0]);\n            }\n\n            td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\n\n            limitedNodes.push(td[0]);\n          }\n        }\n\n        emptyCellsUntil(this.colCnt); // finish off the level\n\n        rowStruct.moreEls = $(moreNodes); // for easy undoing later\n\n        rowStruct.limitedEls = $(limitedNodes); // for easy undoing later\n      }\n    },\n    // Reveals all levels and removes all \"more\"-related elements for a grid's row.\n    // `row` is a row number.\n    unlimitRow: function unlimitRow(row) {\n      var rowStruct = this.rowStructs[row];\n\n      if (rowStruct.moreEls) {\n        rowStruct.moreEls.remove();\n        rowStruct.moreEls = null;\n      }\n\n      if (rowStruct.limitedEls) {\n        rowStruct.limitedEls.removeClass('fc-limited');\n        rowStruct.limitedEls = null;\n      }\n    },\n    // Renders an <a> element that represents hidden event element for a cell.\n    // Responsible for attaching click handler as well.\n    renderMoreLink: function renderMoreLink(row, col, hiddenSegs) {\n      var _this = this;\n\n      var view = this.view;\n      return $('<a class=\"fc-more\"/>').text(this.getMoreLinkText(hiddenSegs.length)).on('click', function (ev) {\n        var clickOption = view.opt('eventLimitClick');\n\n        var date = _this.getCellDate(row, col);\n\n        var moreEl = $(this);\n\n        var dayEl = _this.getCellEl(row, col);\n\n        var allSegs = _this.getCellSegs(row, col); // rescope the segments to be within the cell's date\n\n\n        var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\n\n        var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\n\n        if (typeof clickOption === 'function') {\n          // the returned value can be an atomic option\n          clickOption = view.trigger('eventLimitClick', null, {\n            date: date,\n            dayEl: dayEl,\n            moreEl: moreEl,\n            segs: reslicedAllSegs,\n            hiddenSegs: reslicedHiddenSegs\n          }, ev);\n        }\n\n        if (clickOption === 'popover') {\n          _this.showSegPopover(row, col, moreEl, reslicedAllSegs);\n        } else if (typeof clickOption === 'string') {\n          // a view name\n          view.calendar.zoomTo(date, clickOption);\n        }\n      });\n    },\n    // Reveals the popover that displays all events within a cell\n    showSegPopover: function showSegPopover(row, col, moreLink, segs) {\n      var _this = this;\n\n      var view = this.view;\n      var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\n\n      var topEl; // the element we want to match the top coordinate of\n\n      var options;\n\n      if (this.rowCnt == 1) {\n        topEl = view.el; // will cause the popover to cover any sort of header\n      } else {\n        topEl = this.rowEls.eq(row); // will align with top of row\n      }\n\n      options = {\n        className: 'fc-more-popover',\n        content: this.renderSegPopoverContent(row, col, segs),\n        parentEl: this.el,\n        top: topEl.offset().top,\n        autoHide: true,\n        // when the user clicks elsewhere, hide the popover\n        viewportConstrain: view.opt('popoverViewportConstrain'),\n        hide: function hide() {\n          // kill everything when the popover is hidden\n          _this.segPopover.removeElement();\n\n          _this.segPopover = null;\n          _this.popoverSegs = null;\n        }\n      }; // Determine horizontal coordinate.\n      // We use the moreWrap instead of the <td> to avoid border confusion.\n\n      if (this.isRTL) {\n        options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\n      } else {\n        options.left = moreWrap.offset().left - 1; // -1 to be over cell border\n      }\n\n      this.segPopover = new Popover(options);\n      this.segPopover.show();\n    },\n    // Builds the inner DOM contents of the segment popover\n    renderSegPopoverContent: function renderSegPopoverContent(row, col, segs) {\n      var view = this.view;\n      var isTheme = view.opt('theme');\n      var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));\n      var content = $('<div class=\"fc-header ' + view.widgetHeaderClass + '\">' + '<span class=\"fc-close ' + (isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') + '\"></span>' + '<span class=\"fc-title\">' + htmlEscape(title) + '</span>' + '<div class=\"fc-clear\"/>' + '</div>' + '<div class=\"fc-body ' + view.widgetContentClass + '\">' + '<div class=\"fc-event-container\"></div>' + '</div>');\n      var segContainer = content.find('.fc-event-container');\n      var i; // render each seg's `el` and only return the visible segs\n\n      segs = this.renderFgSegEls(segs, true); // disableResizing=true\n\n      this.popoverSegs = segs;\n\n      for (i = 0; i < segs.length; i++) {\n        // because segments in the popover are not part of a grid coordinate system, provide a hint to any\n        // grids that want to do drag-n-drop about which cell it came from\n        this.prepareHits();\n        segs[i].hit = this.getCellHit(row, col);\n        this.releaseHits();\n        segContainer.append(segs[i].el);\n      }\n\n      return content;\n    },\n    // Given the events within an array of segment objects, reslice them to be in a single day\n    resliceDaySegs: function resliceDaySegs(segs, dayDate) {\n      // build an array of the original events\n      var events = $.map(segs, function (seg) {\n        return seg.event;\n      });\n      var dayStart = dayDate.clone();\n      var dayEnd = dayStart.clone().add(1, 'days');\n      var dayRange = {\n        start: dayStart,\n        end: dayEnd\n      }; // slice the events with a custom slicing function\n\n      segs = this.eventsToSegs(events, function (range) {\n        var seg = intersectRanges(range, dayRange); // undefind if no intersection\n\n        return seg ? [seg] : []; // must return an array of segments\n      }); // force an order because eventsToSegs doesn't guarantee one\n\n      this.sortEventSegs(segs);\n      return segs;\n    },\n    // Generates the text that should be inside a \"more\" link, given the number of events it represents\n    getMoreLinkText: function getMoreLinkText(num) {\n      var opt = this.view.opt('eventLimitText');\n\n      if (typeof opt === 'function') {\n        return opt(num);\n      } else {\n        return '+' + num + ' ' + opt;\n      }\n    },\n    // Returns segments within a given cell.\n    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\n    getCellSegs: function getCellSegs(row, col, startLevel) {\n      var segMatrix = this.rowStructs[row].segMatrix;\n      var level = startLevel || 0;\n      var segs = [];\n      var seg;\n\n      while (level < segMatrix.length) {\n        seg = segMatrix[level][col];\n\n        if (seg) {\n          segs.push(seg);\n        }\n\n        level++;\n      }\n\n      return segs;\n    }\n  });\n  ;\n  ;\n  /* A component that renders one or more columns of vertical time slots\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // We mixin DayTable, even though there is only a single row of days\n\n  var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {\n    slotDuration: null,\n    // duration of a \"slot\", a distinct time segment on given day, visualized by lines\n    snapDuration: null,\n    // granularity of time for dragging and selecting\n    snapsPerSlot: null,\n    minTime: null,\n    // Duration object that denotes the first visible time of any given day\n    maxTime: null,\n    // Duration object that denotes the exclusive visible end time of any given day\n    labelFormat: null,\n    // formatting string for times running along vertical axis\n    labelInterval: null,\n    // duration of how often a label should be displayed for a slot\n    colEls: null,\n    // cells elements in the day-row background\n    slatContainerEl: null,\n    // div that wraps all the slat rows\n    slatEls: null,\n    // elements running horizontally across all columns\n    nowIndicatorEls: null,\n    colCoordCache: null,\n    slatCoordCache: null,\n    constructor: function constructor() {\n      Grid.apply(this, arguments); // call the super-constructor\n\n      this.processOptions();\n    },\n    // Renders the time grid into `this.el`, which should already be assigned.\n    // Relies on the view's colCnt. In the future, this component should probably be self-sufficient.\n    renderDates: function renderDates() {\n      this.el.html(this.renderHtml());\n      this.colEls = this.el.find('.fc-day');\n      this.slatContainerEl = this.el.find('.fc-slats');\n      this.slatEls = this.slatContainerEl.find('tr');\n      this.colCoordCache = new CoordCache({\n        els: this.colEls,\n        isHorizontal: true\n      });\n      this.slatCoordCache = new CoordCache({\n        els: this.slatEls,\n        isVertical: true\n      });\n      this.renderContentSkeleton();\n    },\n    // Renders the basic HTML skeleton for the grid\n    renderHtml: function renderHtml() {\n      return '' + '<div class=\"fc-bg\">' + '<table>' + this.renderBgTrHtml(0) + // row=0\n      '</table>' + '</div>' + '<div class=\"fc-slats\">' + '<table>' + this.renderSlatRowHtml() + '</table>' + '</div>';\n    },\n    // Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n    renderSlatRowHtml: function renderSlatRowHtml() {\n      var view = this.view;\n      var isRTL = this.isRTL;\n      var html = '';\n      var slotTime = moment.duration(+this.minTime); // wish there was .clone() for durations\n\n      var slotDate; // will be on the view's first day, but we only care about its time\n\n      var isLabeled;\n      var axisHtml; // Calculate the time for each slot\n\n      while (slotTime < this.maxTime) {\n        slotDate = this.start.clone().time(slotTime);\n        isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));\n        axisHtml = '<td class=\"fc-axis fc-time ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '>' + (isLabeled ? '<span>' + // for matchCellWidths\n        htmlEscape(slotDate.format(this.labelFormat)) + '</span>' : '') + '</td>';\n        html += '<tr data-time=\"' + slotDate.format('HH:mm:ss') + '\"' + (isLabeled ? '' : ' class=\"fc-minor\"') + '>' + (!isRTL ? axisHtml : '') + '<td class=\"' + view.widgetContentClass + '\"/>' + (isRTL ? axisHtml : '') + \"</tr>\";\n        slotTime.add(this.slotDuration);\n      }\n\n      return html;\n    },\n\n    /* Options\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Parses various options into properties of this object\n    processOptions: function processOptions() {\n      var view = this.view;\n      var slotDuration = view.opt('slotDuration');\n      var snapDuration = view.opt('snapDuration');\n      var input;\n      slotDuration = moment.duration(slotDuration);\n      snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\n      this.slotDuration = slotDuration;\n      this.snapDuration = snapDuration;\n      this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\n\n      this.minResizeDuration = snapDuration; // hack\n\n      this.minTime = moment.duration(view.opt('minTime'));\n      this.maxTime = moment.duration(view.opt('maxTime')); // might be an array value (for TimelineView).\n      // if so, getting the most granular entry (the last one probably).\n\n      input = view.opt('slotLabelFormat');\n\n      if ($.isArray(input)) {\n        input = input[input.length - 1];\n      }\n\n      this.labelFormat = input || view.opt('axisFormat') || // deprecated\n      view.opt('smallTimeFormat'); // the computed default\n\n      input = view.opt('slotLabelInterval');\n      this.labelInterval = input ? moment.duration(input) : this.computeLabelInterval(slotDuration);\n    },\n    // Computes an automatic value for slotLabelInterval\n    computeLabelInterval: function computeLabelInterval(slotDuration) {\n      var i;\n      var labelInterval;\n      var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label\n\n      for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n        labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\n        slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);\n\n        if (isInt(slotsPerLabel) && slotsPerLabel > 1) {\n          return labelInterval;\n        }\n      }\n\n      return moment.duration(slotDuration); // fall back. clone\n    },\n    // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n    computeEventTimeFormat: function computeEventTimeFormat() {\n      return this.view.opt('noMeridiemTimeFormat'); // like \"6:30\" (no AM/PM)\n    },\n    // Computes a default `displayEventEnd` value if one is not expliclty defined\n    computeDisplayEventEnd: function computeDisplayEventEnd() {\n      return true;\n    },\n\n    /* Hit System\n    ------------------------------------------------------------------------------------------------------------------*/\n    prepareHits: function prepareHits() {\n      this.colCoordCache.build();\n      this.slatCoordCache.build();\n    },\n    releaseHits: function releaseHits() {\n      this.colCoordCache.clear(); // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\n    },\n    queryHit: function queryHit(leftOffset, topOffset) {\n      var snapsPerSlot = this.snapsPerSlot;\n      var colCoordCache = this.colCoordCache;\n      var slatCoordCache = this.slatCoordCache;\n      var colIndex = colCoordCache.getHorizontalIndex(leftOffset);\n      var slatIndex = slatCoordCache.getVerticalIndex(topOffset);\n\n      if (colIndex != null && slatIndex != null) {\n        var slatTop = slatCoordCache.getTopOffset(slatIndex);\n        var slatHeight = slatCoordCache.getHeight(slatIndex);\n        var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\n\n        var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n\n        var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n        var snapTop = slatTop + localSnapIndex / snapsPerSlot * slatHeight;\n        var snapBottom = slatTop + (localSnapIndex + 1) / snapsPerSlot * slatHeight;\n        return {\n          col: colIndex,\n          snap: snapIndex,\n          component: this,\n          // needed unfortunately :(\n          left: colCoordCache.getLeftOffset(colIndex),\n          right: colCoordCache.getRightOffset(colIndex),\n          top: snapTop,\n          bottom: snapBottom\n        };\n      }\n    },\n    getHitSpan: function getHitSpan(hit) {\n      var start = this.getCellDate(0, hit.col); // row=0\n\n      var time = this.computeSnapTime(hit.snap); // pass in the snap-index\n\n      var end;\n      start.time(time);\n      end = start.clone().add(this.snapDuration);\n      return {\n        start: start,\n        end: end\n      };\n    },\n    getHitEl: function getHitEl(hit) {\n      return this.colEls.eq(hit.col);\n    },\n\n    /* Dates\n    ------------------------------------------------------------------------------------------------------------------*/\n    rangeUpdated: function rangeUpdated() {\n      this.updateDayTable();\n    },\n    // Given a row number of the grid, representing a \"snap\", returns a time (Duration) from its start-of-day\n    computeSnapTime: function computeSnapTime(snapIndex) {\n      return moment.duration(this.minTime + this.snapDuration * snapIndex);\n    },\n    // Slices up the given span (unzoned start/end with other misc data) into an array of segments\n    spanToSegs: function spanToSegs(span) {\n      var segs = this.sliceRangeByTimes(span);\n      var i;\n\n      for (i = 0; i < segs.length; i++) {\n        if (this.isRTL) {\n          segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\n        } else {\n          segs[i].col = segs[i].dayIndex;\n        }\n      }\n\n      return segs;\n    },\n    sliceRangeByTimes: function sliceRangeByTimes(range) {\n      var segs = [];\n      var seg;\n      var dayIndex;\n      var dayDate;\n      var dayRange;\n\n      for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\n        dayDate = this.dayDates[dayIndex].clone(); // TODO: better API for this?\n\n        dayRange = {\n          start: dayDate.clone().time(this.minTime),\n          end: dayDate.clone().time(this.maxTime)\n        };\n        seg = intersectRanges(range, dayRange); // both will be ambig timezone\n\n        if (seg) {\n          seg.dayIndex = dayIndex;\n          segs.push(seg);\n        }\n      }\n\n      return segs;\n    },\n\n    /* Coordinates\n    ------------------------------------------------------------------------------------------------------------------*/\n    updateSize: function updateSize(isResize) {\n      // NOT a standard Grid method\n      this.slatCoordCache.build();\n\n      if (isResize) {\n        this.updateSegVerticals([].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || []));\n      }\n    },\n    getTotalSlatHeight: function getTotalSlatHeight() {\n      return this.slatContainerEl.outerHeight();\n    },\n    // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n    computeDateTop: function computeDateTop(date, startOfDayDate) {\n      return this.computeTimeTop(moment.duration(date - startOfDayDate.clone().stripTime()));\n    },\n    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n    computeTimeTop: function computeTimeTop(time) {\n      var len = this.slatEls.length;\n      var slatCoverage = (time - this.minTime) / this.slotDuration; // floating-point value of # of slots covered\n\n      var slatIndex;\n      var slatRemainder; // compute a floating-point number for how many slats should be progressed through.\n      // from 0 to number of slats (inclusive)\n      // constrained because minTime/maxTime might be customized.\n\n      slatCoverage = Math.max(0, slatCoverage);\n      slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat\n      // from 0 to number slats (*exclusive*, so len-1)\n\n      slatIndex = Math.floor(slatCoverage);\n      slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n      // could be 1.0 if slatCoverage is covering *all* the slots\n\n      slatRemainder = slatCoverage - slatIndex;\n      return this.slatCoordCache.getTopPosition(slatIndex) + this.slatCoordCache.getHeight(slatIndex) * slatRemainder;\n    },\n\n    /* Event Drag Visualization\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of an event being dragged over the specified date(s).\n    // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n    renderDrag: function renderDrag(eventLocation, seg) {\n      if (seg) {\n        // if there is event information for this drag, render a helper event\n        // returns mock event elements\n        // signal that a helper has been rendered\n        return this.renderEventLocationHelper(eventLocation, seg);\n      } else {\n        // otherwise, just render a highlight\n        this.renderHighlight(this.eventToSpan(eventLocation));\n      }\n    },\n    // Unrenders any visual indication of an event being dragged\n    unrenderDrag: function unrenderDrag() {\n      this.unrenderHelper();\n      this.unrenderHighlight();\n    },\n\n    /* Event Resize Visualization\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of an event being resized\n    renderEventResize: function renderEventResize(eventLocation, seg) {\n      return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n    },\n    // Unrenders any visual indication of an event being resized\n    unrenderEventResize: function unrenderEventResize() {\n      this.unrenderHelper();\n    },\n\n    /* Event Helper\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a mock \"helper\" event. `sourceSeg` is the original segment object and might be null (an external drag)\n    renderHelper: function renderHelper(event, sourceSeg) {\n      return this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements\n    },\n    // Unrenders any mock helper event\n    unrenderHelper: function unrenderHelper() {\n      this.unrenderHelperSegs();\n    },\n\n    /* Business Hours\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderBusinessHours: function renderBusinessHours() {\n      var events = this.view.calendar.getBusinessHoursEvents();\n      var segs = this.eventsToSegs(events);\n      this.renderBusinessSegs(segs);\n    },\n    unrenderBusinessHours: function unrenderBusinessHours() {\n      this.unrenderBusinessSegs();\n    },\n\n    /* Now Indicator\n    ------------------------------------------------------------------------------------------------------------------*/\n    getNowIndicatorUnit: function getNowIndicatorUnit() {\n      return 'minute'; // will refresh on the minute\n    },\n    renderNowIndicator: function renderNowIndicator(date) {\n      // seg system might be overkill, but it handles scenario where line needs to be rendered\n      //  more than once because of columns with the same date (resources columns for example)\n      var segs = this.spanToSegs({\n        start: date,\n        end: date\n      });\n      var top = this.computeDateTop(date, date);\n      var nodes = [];\n      var i; // render lines within the columns\n\n      for (i = 0; i < segs.length; i++) {\n        nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-line\"></div>').css('top', top).appendTo(this.colContainerEls.eq(segs[i].col))[0]);\n      } // render an arrow over the axis\n\n\n      if (segs.length > 0) {\n        // is the current time in view?\n        nodes.push($('<div class=\"fc-now-indicator fc-now-indicator-arrow\"></div>').css('top', top).appendTo(this.el.find('.fc-content-skeleton'))[0]);\n      }\n\n      this.nowIndicatorEls = $(nodes);\n    },\n    unrenderNowIndicator: function unrenderNowIndicator() {\n      if (this.nowIndicatorEls) {\n        this.nowIndicatorEls.remove();\n        this.nowIndicatorEls = null;\n      }\n    },\n\n    /* Selection\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\n    renderSelection: function renderSelection(span) {\n      if (this.view.opt('selectHelper')) {\n        // this setting signals that a mock helper event should be rendered\n        // normally acceps an eventLocation, span has a start/end, which is good enough\n        this.renderEventLocationHelper(span);\n      } else {\n        this.renderHighlight(span);\n      }\n    },\n    // Unrenders any visual indication of a selection\n    unrenderSelection: function unrenderSelection() {\n      this.unrenderHelper();\n      this.unrenderHighlight();\n    },\n\n    /* Highlight\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderHighlight: function renderHighlight(span) {\n      this.renderHighlightSegs(this.spanToSegs(span));\n    },\n    unrenderHighlight: function unrenderHighlight() {\n      this.unrenderHighlightSegs();\n    }\n  });\n  ;\n  ;\n  /* Methods for rendering SEGMENTS, pieces of content that live on the view\n   ( this file is no longer just for events )\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  TimeGrid.mixin({\n    colContainerEls: null,\n    // containers for each column\n    // inner-containers for each column where different types of segs live\n    fgContainerEls: null,\n    bgContainerEls: null,\n    helperContainerEls: null,\n    highlightContainerEls: null,\n    businessContainerEls: null,\n    // arrays of different types of displayed segments\n    fgSegs: null,\n    bgSegs: null,\n    helperSegs: null,\n    highlightSegs: null,\n    businessSegs: null,\n    // Renders the DOM that the view's content will live in\n    renderContentSkeleton: function renderContentSkeleton() {\n      var cellHtml = '';\n      var i;\n      var skeletonEl;\n\n      for (i = 0; i < this.colCnt; i++) {\n        cellHtml += '<td>' + '<div class=\"fc-content-col\">' + '<div class=\"fc-event-container fc-helper-container\"></div>' + '<div class=\"fc-event-container\"></div>' + '<div class=\"fc-highlight-container\"></div>' + '<div class=\"fc-bgevent-container\"></div>' + '<div class=\"fc-business-container\"></div>' + '</div>' + '</td>';\n      }\n\n      skeletonEl = $('<div class=\"fc-content-skeleton\">' + '<table>' + '<tr>' + cellHtml + '</tr>' + '</table>' + '</div>');\n      this.colContainerEls = skeletonEl.find('.fc-content-col');\n      this.helperContainerEls = skeletonEl.find('.fc-helper-container');\n      this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\n      this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\n      this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\n      this.businessContainerEls = skeletonEl.find('.fc-business-container');\n      this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\n\n      this.el.append(skeletonEl);\n    },\n\n    /* Foreground Events\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderFgSegs: function renderFgSegs(segs) {\n      segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);\n      this.fgSegs = segs;\n      return segs; // needed for Grid::renderEvents\n    },\n    unrenderFgSegs: function unrenderFgSegs() {\n      this.unrenderNamedSegs('fgSegs');\n    },\n\n    /* Foreground Helper Events\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderHelperSegs: function renderHelperSegs(segs, sourceSeg) {\n      var helperEls = [];\n      var i, seg;\n      var sourceEl;\n      segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls); // Try to make the segment that is in the same row as sourceSeg look the same\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i];\n\n        if (sourceSeg && sourceSeg.col === seg.col) {\n          sourceEl = sourceSeg.el;\n          seg.el.css({\n            left: sourceEl.css('left'),\n            right: sourceEl.css('right'),\n            'margin-left': sourceEl.css('margin-left'),\n            'margin-right': sourceEl.css('margin-right')\n          });\n        }\n\n        helperEls.push(seg.el[0]);\n      }\n\n      this.helperSegs = segs;\n      return $(helperEls); // must return rendered helpers\n    },\n    unrenderHelperSegs: function unrenderHelperSegs() {\n      this.unrenderNamedSegs('helperSegs');\n    },\n\n    /* Background Events\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderBgSegs: function renderBgSegs(segs) {\n      segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system\n\n      this.updateSegVerticals(segs);\n      this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);\n      this.bgSegs = segs;\n      return segs; // needed for Grid::renderEvents\n    },\n    unrenderBgSegs: function unrenderBgSegs() {\n      this.unrenderNamedSegs('bgSegs');\n    },\n\n    /* Highlight\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderHighlightSegs: function renderHighlightSegs(segs) {\n      segs = this.renderFillSegEls('highlight', segs); // TODO: old fill system\n\n      this.updateSegVerticals(segs);\n      this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);\n      this.highlightSegs = segs;\n    },\n    unrenderHighlightSegs: function unrenderHighlightSegs() {\n      this.unrenderNamedSegs('highlightSegs');\n    },\n\n    /* Business Hours\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderBusinessSegs: function renderBusinessSegs(segs) {\n      segs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system\n\n      this.updateSegVerticals(segs);\n      this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);\n      this.businessSegs = segs;\n    },\n    unrenderBusinessSegs: function unrenderBusinessSegs() {\n      this.unrenderNamedSegs('businessSegs');\n    },\n\n    /* Seg Rendering Utils\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\n    groupSegsByCol: function groupSegsByCol(segs) {\n      var segsByCol = [];\n      var i;\n\n      for (i = 0; i < this.colCnt; i++) {\n        segsByCol.push([]);\n      }\n\n      for (i = 0; i < segs.length; i++) {\n        segsByCol[segs[i].col].push(segs[i]);\n      }\n\n      return segsByCol;\n    },\n    // Given segments grouped by column, insert the segments' elements into a parallel array of container\n    // elements, each living within a column.\n    attachSegsByCol: function attachSegsByCol(segsByCol, containerEls) {\n      var col;\n      var segs;\n      var i;\n\n      for (col = 0; col < this.colCnt; col++) {\n        // iterate each column grouping\n        segs = segsByCol[col];\n\n        for (i = 0; i < segs.length; i++) {\n          containerEls.eq(col).append(segs[i].el);\n        }\n      }\n    },\n    // Given the name of a property of `this` object, assumed to be an array of segments,\n    // loops through each segment and removes from DOM. Will null-out the property afterwards.\n    unrenderNamedSegs: function unrenderNamedSegs(propName) {\n      var segs = this[propName];\n      var i;\n\n      if (segs) {\n        for (i = 0; i < segs.length; i++) {\n          segs[i].el.remove();\n        }\n\n        this[propName] = null;\n      }\n    },\n\n    /* Foreground Event Rendering Utils\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Given an array of foreground segments, render a DOM element for each, computes position,\n    // and attaches to the column inner-container elements.\n    renderFgSegsIntoContainers: function renderFgSegsIntoContainers(segs, containerEls) {\n      var segsByCol;\n      var col;\n      segs = this.renderFgSegEls(segs); // will call fgSegHtml\n\n      segsByCol = this.groupSegsByCol(segs);\n\n      for (col = 0; col < this.colCnt; col++) {\n        this.updateFgSegCoords(segsByCol[col]);\n      }\n\n      this.attachSegsByCol(segsByCol, containerEls);\n      return segs;\n    },\n    // Renders the HTML for a single event segment's default rendering\n    fgSegHtml: function fgSegHtml(seg, disableResizing) {\n      var view = this.view;\n      var event = seg.event;\n      var isDraggable = view.isEventDraggable(event);\n      var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);\n      var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);\n      var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n      var skinCss = cssToStr(this.getSegSkinCss(seg));\n      var timeText;\n      var fullTimeText; // more verbose time text. for the print stylesheet\n\n      var startTimeText; // just the start time text\n\n      classes.unshift('fc-time-grid-event', 'fc-v-event');\n\n      if (view.isMultiDayEvent(event)) {\n        // if the event appears to span more than one day...\n        // Don't display time text on segments that run entirely through a day.\n        // That would appear as midnight-midnight and would look dumb.\n        // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\n        if (seg.isStart || seg.isEnd) {\n          timeText = this.getEventTimeText(seg);\n          fullTimeText = this.getEventTimeText(seg, 'LT');\n          startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false\n        }\n      } else {\n        // Display the normal time text for the *event's* times\n        timeText = this.getEventTimeText(event);\n        fullTimeText = this.getEventTimeText(event, 'LT');\n        startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false\n      }\n\n      return '<a class=\"' + classes.join(' ') + '\"' + (event.url ? ' href=\"' + htmlEscape(event.url) + '\"' : '') + (skinCss ? ' style=\"' + skinCss + '\"' : '') + '>' + '<div class=\"fc-content\">' + (timeText ? '<div class=\"fc-time\"' + ' data-start=\"' + htmlEscape(startTimeText) + '\"' + ' data-full=\"' + htmlEscape(fullTimeText) + '\"' + '>' + '<span>' + htmlEscape(timeText) + '</span>' + '</div>' : '') + (event.title ? '<div class=\"fc-title\">' + htmlEscape(event.title) + '</div>' : '') + '</div>' + '<div class=\"fc-bg\"/>' + (\n      /* TODO: write CSS for this\n      (isResizableFromStart ?\n      \t'<div class=\"fc-resizer fc-start-resizer\" />' :\n      \t''\n      \t) +\n      */\n      isResizableFromEnd ? '<div class=\"fc-resizer fc-end-resizer\" />' : '') + '</a>';\n    },\n\n    /* Seg Position Utils\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Refreshes the CSS top/bottom coordinates for each segment element.\n    // Works when called after initial render, after a window resize/zoom for example.\n    updateSegVerticals: function updateSegVerticals(segs) {\n      this.computeSegVerticals(segs);\n      this.assignSegVerticals(segs);\n    },\n    // For each segment in an array, computes and assigns its top and bottom properties\n    computeSegVerticals: function computeSegVerticals(segs) {\n      var i, seg;\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i];\n        seg.top = this.computeDateTop(seg.start, seg.start);\n        seg.bottom = this.computeDateTop(seg.end, seg.start);\n      }\n    },\n    // Given segments that already have their top/bottom properties computed, applies those values to\n    // the segments' elements.\n    assignSegVerticals: function assignSegVerticals(segs) {\n      var i, seg;\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i];\n        seg.el.css(this.generateSegVerticalCss(seg));\n      }\n    },\n    // Generates an object with CSS properties for the top/bottom coordinates of a segment element\n    generateSegVerticalCss: function generateSegVerticalCss(seg) {\n      return {\n        top: seg.top,\n        bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\n\n      };\n    },\n\n    /* Foreground Event Positioning Utils\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Given segments that are assumed to all live in the *same column*,\n    // compute their verical/horizontal coordinates and assign to their elements.\n    updateFgSegCoords: function updateFgSegCoords(segs) {\n      this.computeSegVerticals(segs); // horizontals relies on this\n\n      this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\n\n      this.assignSegVerticals(segs);\n      this.assignFgSegHorizontals(segs);\n    },\n    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n    // NOTE: Also reorders the given array by date!\n    computeFgSegHorizontals: function computeFgSegHorizontals(segs) {\n      var levels;\n      var level0;\n      var i;\n      this.sortEventSegs(segs); // order by certain criteria\n\n      levels = buildSlotSegLevels(segs);\n      computeForwardSlotSegs(levels);\n\n      if (level0 = levels[0]) {\n        for (i = 0; i < level0.length; i++) {\n          computeSlotSegPressures(level0[i]);\n        }\n\n        for (i = 0; i < level0.length; i++) {\n          this.computeFgSegForwardBack(level0[i], 0, 0);\n        }\n      }\n    },\n    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n    // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n    //\n    // The segment might be part of a \"series\", which means consecutive segments with the same pressure\n    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n    // coordinate of the first segment in the series.\n    computeFgSegForwardBack: function computeFgSegForwardBack(seg, seriesBackwardPressure, seriesBackwardCoord) {\n      var forwardSegs = seg.forwardSegs;\n      var i;\n\n      if (seg.forwardCoord === undefined) {\n        // not already computed\n        if (!forwardSegs.length) {\n          // if there are no forward segments, this segment should butt up against the edge\n          seg.forwardCoord = 1;\n        } else {\n          // sort highest pressure first\n          this.sortForwardSegs(forwardSegs); // this segment's forwardCoord will be calculated from the backwardCoord of the\n          // highest-pressure forward segment.\n\n          this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\n          seg.forwardCoord = forwardSegs[0].backwardCoord;\n        } // calculate the backwardCoord from the forwardCoord. consider the series\n\n\n        seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / ( // available width for series\n        seriesBackwardPressure + 1); // # of segments in the series\n        // use this segment's coordinates to computed the coordinates of the less-pressurized\n        // forward segments\n\n        for (i = 0; i < forwardSegs.length; i++) {\n          this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\n        }\n      }\n    },\n    sortForwardSegs: function sortForwardSegs(forwardSegs) {\n      forwardSegs.sort(proxy(this, 'compareForwardSegs'));\n    },\n    // A cmp function for determining which forward segment to rely on more when computing coordinates.\n    compareForwardSegs: function compareForwardSegs(seg1, seg2) {\n      // put higher-pressure first\n      return seg2.forwardPressure - seg1.forwardPressure || // put segments that are closer to initial edge first (and favor ones with no coords yet)\n      (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) || // do normal sorting...\n      this.compareEventSegs(seg1, seg2);\n    },\n    // Given foreground event segments that have already had their position coordinates computed,\n    // assigns position-related CSS values to their elements.\n    assignFgSegHorizontals: function assignFgSegHorizontals(segs) {\n      var i, seg;\n\n      for (i = 0; i < segs.length; i++) {\n        seg = segs[i];\n        seg.el.css(this.generateFgSegHorizontalCss(seg)); // if the height is short, add a className for alternate styling\n\n        if (seg.bottom - seg.top < 30) {\n          seg.el.addClass('fc-short');\n        }\n      }\n    },\n    // Generates an object with CSS properties/values that should be applied to an event segment element.\n    // Contains important positioning-related properties that should be applied to any event element, customized or not.\n    generateFgSegHorizontalCss: function generateFgSegHorizontalCss(seg) {\n      var shouldOverlap = this.view.opt('slotEventOverlap');\n      var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n\n      var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n\n      var props = this.generateSegVerticalCss(seg); // get top/bottom first\n\n      var left; // amount of space from left edge, a fraction of the total width\n\n      var right; // amount of space from right edge, a fraction of the total width\n\n      if (shouldOverlap) {\n        // double the width, but don't go beyond the maximum forward coordinate (1.0)\n        forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n      }\n\n      if (this.isRTL) {\n        left = 1 - forwardCoord;\n        right = backwardCoord;\n      } else {\n        left = backwardCoord;\n        right = 1 - forwardCoord;\n      }\n\n      props.zIndex = seg.level + 1; // convert from 0-base to 1-based\n\n      props.left = left * 100 + '%';\n      props.right = right * 100 + '%';\n\n      if (shouldOverlap && seg.forwardPressure) {\n        // add padding to the edge so that forward stacked events don't cover the resizer's icon\n        props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n      }\n\n      return props;\n    }\n  }); // Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n  // left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\n\n  function buildSlotSegLevels(segs) {\n    var levels = [];\n    var i, seg;\n    var j;\n\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i]; // go through all the levels and stop on the first level where there are no collisions\n\n      for (j = 0; j < levels.length; j++) {\n        if (!computeSlotSegCollisions(seg, levels[j]).length) {\n          break;\n        }\n      }\n\n      seg.level = j;\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n\n    return levels;\n  } // For every segment, figure out the other segments that are in subsequent\n  // levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\n\n\n  function computeForwardSlotSegs(levels) {\n    var i, level;\n    var j, seg;\n    var k;\n\n    for (i = 0; i < levels.length; i++) {\n      level = levels[i];\n\n      for (j = 0; j < level.length; j++) {\n        seg = level[j];\n        seg.forwardSegs = [];\n\n        for (k = i + 1; k < levels.length; k++) {\n          computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n        }\n      }\n    }\n  } // Figure out which path forward (via seg.forwardSegs) results in the longest path until\n  // the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\n\n\n  function computeSlotSegPressures(seg) {\n    var forwardSegs = seg.forwardSegs;\n    var forwardPressure = 0;\n    var i, forwardSeg;\n\n    if (seg.forwardPressure === undefined) {\n      // not already computed\n      for (i = 0; i < forwardSegs.length; i++) {\n        forwardSeg = forwardSegs[i]; // figure out the child's maximum forward path\n\n        computeSlotSegPressures(forwardSeg); // either use the existing maximum, or use the child's forward pressure\n        // plus one (for the forwardSeg itself)\n\n        forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\n      }\n\n      seg.forwardPressure = forwardPressure;\n    }\n  } // Find all the segments in `otherSegs` that vertically collide with `seg`.\n  // Append into an optionally-supplied `results` array and return.\n\n\n  function computeSlotSegCollisions(seg, otherSegs, results) {\n    results = results || [];\n\n    for (var i = 0; i < otherSegs.length; i++) {\n      if (isSlotSegCollision(seg, otherSegs[i])) {\n        results.push(otherSegs[i]);\n      }\n    }\n\n    return results;\n  } // Do these segments occupy the same vertical space?\n\n\n  function isSlotSegCollision(seg1, seg2) {\n    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n  }\n\n  ;\n  ;\n  /* An abstract class from which other views inherit from\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  var View = FC.View = Class.extend(EmitterMixin, ListenerMixin, {\n    type: null,\n    // subclass' view name (string)\n    name: null,\n    // deprecated. use `type` instead\n    title: null,\n    // the text that will be displayed in the header's title\n    calendar: null,\n    // owner Calendar object\n    options: null,\n    // hash containing all options. already merged with view-specific-options\n    el: null,\n    // the view's containing element. set by Calendar\n    displaying: null,\n    // a promise representing the state of rendering. null if no render requested\n    isSkeletonRendered: false,\n    isEventsRendered: false,\n    // range the view is actually displaying (moments)\n    start: null,\n    end: null,\n    // exclusive\n    // range the view is formally responsible for (moments)\n    // may be different from start/end. for example, a month view might have 1st-31st, excluding padded dates\n    intervalStart: null,\n    intervalEnd: null,\n    // exclusive\n    intervalDuration: null,\n    intervalUnit: null,\n    // name of largest unit being displayed, like \"month\" or \"week\"\n    isRTL: false,\n    isSelected: false,\n    // boolean whether a range of time is user-selected or not\n    selectedEvent: null,\n    eventOrderSpecs: null,\n    // criteria for ordering events when they have same date/time\n    // classNames styled by jqui themes\n    widgetHeaderClass: null,\n    widgetContentClass: null,\n    highlightStateClass: null,\n    // for date utils, computed from options\n    nextDayThreshold: null,\n    isHiddenDayHash: null,\n    // now indicator\n    isNowIndicatorRendered: null,\n    initialNowDate: null,\n    // result first getNow call\n    initialNowQueriedMs: null,\n    // ms time the getNow was called\n    nowIndicatorTimeoutID: null,\n    // for refresh timing of now indicator\n    nowIndicatorIntervalID: null,\n    // \"\n    constructor: function constructor(calendar, type, options, intervalDuration) {\n      this.calendar = calendar;\n      this.type = this.name = type; // .name is deprecated\n\n      this.options = options;\n      this.intervalDuration = intervalDuration || moment.duration(1, 'day');\n      this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));\n      this.initThemingProps();\n      this.initHiddenDays();\n      this.isRTL = this.opt('isRTL');\n      this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));\n      this.initialize();\n    },\n    // A good place for subclasses to initialize member variables\n    initialize: function initialize() {// subclasses can implement\n    },\n    // Retrieves an option with the given name\n    opt: function opt(name) {\n      return this.options[name];\n    },\n    // Triggers handlers that are view-related. Modifies args before passing to calendar.\n    trigger: function trigger(name, thisObj) {\n      // arguments beyond thisObj are passed along\n      var calendar = this.calendar;\n      return calendar.trigger.apply(calendar, [name, thisObj || this].concat(Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj\n      [this] // always make the last argument a reference to the view. TODO: deprecate\n      ));\n    },\n\n    /* Dates\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Updates all internal dates to center around the given current unzoned date.\n    setDate: function setDate(date) {\n      this.setRange(this.computeRange(date));\n    },\n    // Updates all internal dates for displaying the given unzoned range.\n    setRange: function setRange(range) {\n      $.extend(this, range); // assigns every property to this object's member variables\n\n      this.updateTitle();\n    },\n    // Given a single current unzoned date, produce information about what range to display.\n    // Subclasses can override. Must return all properties.\n    computeRange: function computeRange(date) {\n      var intervalUnit = computeIntervalUnit(this.intervalDuration);\n      var intervalStart = date.clone().startOf(intervalUnit);\n      var intervalEnd = intervalStart.clone().add(this.intervalDuration);\n      var start, end; // normalize the range's time-ambiguity\n\n      if (/year|month|week|day/.test(intervalUnit)) {\n        // whole-days?\n        intervalStart.stripTime();\n        intervalEnd.stripTime();\n      } else {\n        // needs to have a time?\n        if (!intervalStart.hasTime()) {\n          intervalStart = this.calendar.time(0); // give 00:00 time\n        }\n\n        if (!intervalEnd.hasTime()) {\n          intervalEnd = this.calendar.time(0); // give 00:00 time\n        }\n      }\n\n      start = intervalStart.clone();\n      start = this.skipHiddenDays(start);\n      end = intervalEnd.clone();\n      end = this.skipHiddenDays(end, -1, true); // exclusively move backwards\n\n      return {\n        intervalUnit: intervalUnit,\n        intervalStart: intervalStart,\n        intervalEnd: intervalEnd,\n        start: start,\n        end: end\n      };\n    },\n    // Computes the new date when the user hits the prev button, given the current date\n    computePrevDate: function computePrevDate(date) {\n      return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1);\n    },\n    // Computes the new date when the user hits the next button, given the current date\n    computeNextDate: function computeNextDate(date) {\n      return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).add(this.intervalDuration));\n    },\n    // Given an arbitrarily calculated current date of the calendar, returns a date that is ensured to be completely\n    // visible. `direction` is optional and indicates which direction the current date was being\n    // incremented or decremented (1 or -1).\n    massageCurrentDate: function massageCurrentDate(date, direction) {\n      if (this.intervalDuration.as('days') <= 1) {\n        // if the view displays a single day or smaller\n        if (this.isHiddenDay(date)) {\n          date = this.skipHiddenDays(date, direction);\n          date.startOf('day');\n        }\n      }\n\n      return date;\n    },\n\n    /* Title and Date Formatting\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Sets the view's title property to the most updated computed value\n    updateTitle: function updateTitle() {\n      this.title = this.computeTitle();\n    },\n    // Computes what the title at the top of the calendar should be for this view\n    computeTitle: function computeTitle() {\n      return this.formatRange({\n        // in case intervalStart/End has a time, make sure timezone is correct\n        start: this.calendar.applyTimezone(this.intervalStart),\n        end: this.calendar.applyTimezone(this.intervalEnd)\n      }, this.opt('titleFormat') || this.computeTitleFormat(), this.opt('titleRangeSeparator'));\n    },\n    // Generates the format string that should be used to generate the title for the current date range.\n    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n    computeTitleFormat: function computeTitleFormat() {\n      if (this.intervalUnit == 'year') {\n        return 'YYYY';\n      } else if (this.intervalUnit == 'month') {\n        return this.opt('monthYearFormat'); // like \"September 2014\"\n      } else if (this.intervalDuration.as('days') > 1) {\n        return 'll'; // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n      } else {\n        return 'LL'; // one day. longer, like \"September 9 2014\"\n      }\n    },\n    // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\n    // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\n    // The timezones of the dates within `range` will be respected.\n    formatRange: function formatRange(range, formatStr, separator) {\n      var end = range.end;\n\n      if (!end.hasTime()) {\n        // all-day?\n        end = end.clone().subtract(1); // convert to inclusive. last ms of previous day\n      }\n\n      return _formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));\n    },\n\n    /* Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Sets the container element that the view should render inside of.\n    // Does other DOM-related initializations.\n    setElement: function setElement(el) {\n      this.el = el;\n      this.bindGlobalHandlers();\n    },\n    // Removes the view's container element from the DOM, clearing any content beforehand.\n    // Undoes any other DOM-related attachments.\n    removeElement: function removeElement() {\n      this.clear(); // clears all content\n      // clean up the skeleton\n\n      if (this.isSkeletonRendered) {\n        this.unrenderSkeleton();\n        this.isSkeletonRendered = false;\n      }\n\n      this.unbindGlobalHandlers();\n      this.el.remove(); // NOTE: don't null-out this.el in case the View was destroyed within an API callback.\n      // We don't null-out the View's other jQuery element references upon destroy,\n      //  so we shouldn't kill this.el either.\n    },\n    // Does everything necessary to display the view centered around the given unzoned date.\n    // Does every type of rendering EXCEPT rendering events.\n    // Is asychronous and returns a promise.\n    display: function display(date, explicitScrollState) {\n      var _this = this;\n\n      var prevScrollState = null;\n\n      if (explicitScrollState != null && this.displaying) {\n        // don't need prevScrollState if explicitScrollState\n        prevScrollState = this.queryScroll();\n      }\n\n      this.calendar.freezeContentHeight();\n      return syncThen(this.clear(), function () {\n        // clear the content first\n        return _this.displaying = syncThen(_this.displayView(date), function () {\n          // displayView might return a promise\n          // caller of display() wants a specific scroll state?\n          if (explicitScrollState != null) {\n            // we make an assumption that this is NOT the initial render,\n            // and thus don't need forceScroll (is inconveniently asynchronous)\n            _this.setScroll(explicitScrollState);\n          } else {\n            _this.forceScroll(_this.computeInitialScroll(prevScrollState));\n          }\n\n          _this.calendar.unfreezeContentHeight();\n\n          _this.triggerRender();\n        });\n      });\n    },\n    // Does everything necessary to clear the content of the view.\n    // Clears dates and events. Does not clear the skeleton.\n    // Is asychronous and returns a promise.\n    clear: function clear() {\n      var _this = this;\n\n      var displaying = this.displaying;\n\n      if (displaying) {\n        // previously displayed, or in the process of being displayed?\n        return syncThen(displaying, function () {\n          // wait for the display to finish\n          _this.displaying = null;\n\n          _this.clearEvents();\n\n          return _this.clearView(); // might return a promise. chain it\n        });\n      } else {\n        return $.when(); // an immediately-resolved promise\n      }\n    },\n    // Displays the view's non-event content, such as date-related content or anything required by events.\n    // Renders the view's non-content skeleton if necessary.\n    // Can be asynchronous and return a promise.\n    displayView: function displayView(date) {\n      if (!this.isSkeletonRendered) {\n        this.renderSkeleton();\n        this.isSkeletonRendered = true;\n      }\n\n      if (date) {\n        this.setDate(date);\n      }\n\n      if (this.render) {\n        this.render(); // TODO: deprecate\n      }\n\n      this.renderDates();\n      this.updateSize();\n      this.renderBusinessHours(); // might need coordinates, so should go after updateSize()\n\n      this.startNowIndicator();\n    },\n    // Unrenders the view content that was rendered in displayView.\n    // Can be asynchronous and return a promise.\n    clearView: function clearView() {\n      this.unselect();\n      this.stopNowIndicator();\n      this.triggerUnrender();\n      this.unrenderBusinessHours();\n      this.unrenderDates();\n\n      if (this.destroy) {\n        this.destroy(); // TODO: deprecate\n      }\n    },\n    // Renders the basic structure of the view before any content is rendered\n    renderSkeleton: function renderSkeleton() {// subclasses should implement\n    },\n    // Unrenders the basic structure of the view\n    unrenderSkeleton: function unrenderSkeleton() {// subclasses should implement\n    },\n    // Renders the view's date-related content.\n    // Assumes setRange has already been called and the skeleton has already been rendered.\n    renderDates: function renderDates() {// subclasses should implement\n    },\n    // Unrenders the view's date-related content\n    unrenderDates: function unrenderDates() {// subclasses should override\n    },\n    // Signals that the view's content has been rendered\n    triggerRender: function triggerRender() {\n      this.trigger('viewRender', this, this, this.el);\n    },\n    // Signals that the view's content is about to be unrendered\n    triggerUnrender: function triggerUnrender() {\n      this.trigger('viewDestroy', this, this, this.el);\n    },\n    // Binds DOM handlers to elements that reside outside the view container, such as the document\n    bindGlobalHandlers: function bindGlobalHandlers() {\n      this.listenTo($(document), 'mousedown', this.handleDocumentMousedown);\n      this.listenTo($(document), 'touchstart', this.processUnselect);\n    },\n    // Unbinds DOM handlers from elements that reside outside the view container\n    unbindGlobalHandlers: function unbindGlobalHandlers() {\n      this.stopListeningTo($(document));\n    },\n    // Initializes internal variables related to theming\n    initThemingProps: function initThemingProps() {\n      var tm = this.opt('theme') ? 'ui' : 'fc';\n      this.widgetHeaderClass = tm + '-widget-header';\n      this.widgetContentClass = tm + '-widget-content';\n      this.highlightStateClass = tm + '-state-highlight';\n    },\n\n    /* Business Hours\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders business-hours onto the view. Assumes updateSize has already been called.\n    renderBusinessHours: function renderBusinessHours() {// subclasses should implement\n    },\n    // Unrenders previously-rendered business-hours\n    unrenderBusinessHours: function unrenderBusinessHours() {// subclasses should implement\n    },\n\n    /* Now Indicator\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Immediately render the current time indicator and begins re-rendering it at an interval,\n    // which is defined by this.getNowIndicatorUnit().\n    // TODO: somehow do this for the current whole day's background too\n    startNowIndicator: function startNowIndicator() {\n      var _this = this;\n\n      var unit;\n      var update;\n      var delay; // ms wait value\n\n      if (this.opt('nowIndicator')) {\n        unit = this.getNowIndicatorUnit();\n\n        if (unit) {\n          update = proxy(this, 'updateNowIndicator'); // bind to `this`\n\n          this.initialNowDate = this.calendar.getNow();\n          this.initialNowQueriedMs = +new Date();\n          this.renderNowIndicator(this.initialNowDate);\n          this.isNowIndicatorRendered = true; // wait until the beginning of the next interval\n\n          delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;\n          this.nowIndicatorTimeoutID = setTimeout(function () {\n            _this.nowIndicatorTimeoutID = null;\n            update();\n            delay = +moment.duration(1, unit);\n            delay = Math.max(100, delay); // prevent too frequent\n\n            _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\n          }, delay);\n        }\n      }\n    },\n    // rerenders the now indicator, computing the new current time from the amount of time that has passed\n    // since the initial getNow call.\n    updateNowIndicator: function updateNowIndicator() {\n      if (this.isNowIndicatorRendered) {\n        this.unrenderNowIndicator();\n        this.renderNowIndicator(this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms\n        );\n      }\n    },\n    // Immediately unrenders the view's current time indicator and stops any re-rendering timers.\n    // Won't cause side effects if indicator isn't rendered.\n    stopNowIndicator: function stopNowIndicator() {\n      if (this.isNowIndicatorRendered) {\n        if (this.nowIndicatorTimeoutID) {\n          clearTimeout(this.nowIndicatorTimeoutID);\n          this.nowIndicatorTimeoutID = null;\n        }\n\n        if (this.nowIndicatorIntervalID) {\n          clearTimeout(this.nowIndicatorIntervalID);\n          this.nowIndicatorIntervalID = null;\n        }\n\n        this.unrenderNowIndicator();\n        this.isNowIndicatorRendered = false;\n      }\n    },\n    // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\n    // should be refreshed. If something falsy is returned, no time indicator is rendered at all.\n    getNowIndicatorUnit: function getNowIndicatorUnit() {// subclasses should implement\n    },\n    // Renders a current time indicator at the given datetime\n    renderNowIndicator: function renderNowIndicator(date) {// subclasses should implement\n    },\n    // Undoes the rendering actions from renderNowIndicator\n    unrenderNowIndicator: function unrenderNowIndicator() {// subclasses should implement\n    },\n\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Refreshes anything dependant upon sizing of the container element of the grid\n    updateSize: function updateSize(isResize) {\n      var scrollState;\n\n      if (isResize) {\n        scrollState = this.queryScroll();\n      }\n\n      this.updateHeight(isResize);\n      this.updateWidth(isResize);\n      this.updateNowIndicator();\n\n      if (isResize) {\n        this.setScroll(scrollState);\n      }\n    },\n    // Refreshes the horizontal dimensions of the calendar\n    updateWidth: function updateWidth(isResize) {// subclasses should implement\n    },\n    // Refreshes the vertical dimensions of the calendar\n    updateHeight: function updateHeight(isResize) {\n      var calendar = this.calendar; // we poll the calendar for height information\n\n      this.setHeight(calendar.getSuggestedViewHeight(), calendar.isHeightAuto());\n    },\n    // Updates the vertical dimensions of the calendar to the specified height.\n    // if `isAuto` is set to true, height becomes merely a suggestion and the view should use its \"natural\" height.\n    setHeight: function setHeight(height, isAuto) {// subclasses should implement\n    },\n\n    /* Scroller\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Computes the initial pre-configured scroll state prior to allowing the user to change it.\n    // Given the scroll state from the previous rendering. If first time rendering, given null.\n    computeInitialScroll: function computeInitialScroll(previousScrollState) {\n      return 0;\n    },\n    // Retrieves the view's current natural scroll state. Can return an arbitrary format.\n    queryScroll: function queryScroll() {// subclasses must implement\n    },\n    // Sets the view's scroll state. Will accept the same format computeInitialScroll and queryScroll produce.\n    setScroll: function setScroll(scrollState) {// subclasses must implement\n    },\n    // Sets the scroll state, making sure to overcome any predefined scroll value the browser has in mind\n    forceScroll: function forceScroll(scrollState) {\n      var _this = this;\n\n      this.setScroll(scrollState);\n      setTimeout(function () {\n        _this.setScroll(scrollState);\n      }, 0);\n    },\n\n    /* Event Elements / Segments\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Does everything necessary to display the given events onto the current view\n    displayEvents: function displayEvents(events) {\n      var scrollState = this.queryScroll();\n      this.clearEvents();\n      this.renderEvents(events);\n      this.isEventsRendered = true;\n      this.setScroll(scrollState);\n      this.triggerEventRender();\n    },\n    // Does everything necessary to clear the view's currently-rendered events\n    clearEvents: function clearEvents() {\n      var scrollState;\n\n      if (this.isEventsRendered) {\n        // TODO: optimize: if we know this is part of a displayEvents call, don't queryScroll/setScroll\n        scrollState = this.queryScroll();\n        this.triggerEventUnrender();\n\n        if (this.destroyEvents) {\n          this.destroyEvents(); // TODO: deprecate\n        }\n\n        this.unrenderEvents();\n        this.setScroll(scrollState);\n        this.isEventsRendered = false;\n      }\n    },\n    // Renders the events onto the view.\n    renderEvents: function renderEvents(events) {// subclasses should implement\n    },\n    // Removes event elements from the view.\n    unrenderEvents: function unrenderEvents() {// subclasses should implement\n    },\n    // Signals that all events have been rendered\n    triggerEventRender: function triggerEventRender() {\n      this.renderedEventSegEach(function (seg) {\n        this.trigger('eventAfterRender', seg.event, seg.event, seg.el);\n      });\n      this.trigger('eventAfterAllRender');\n    },\n    // Signals that all event elements are about to be removed\n    triggerEventUnrender: function triggerEventUnrender() {\n      this.renderedEventSegEach(function (seg) {\n        this.trigger('eventDestroy', seg.event, seg.event, seg.el);\n      });\n    },\n    // Given an event and the default element used for rendering, returns the element that should actually be used.\n    // Basically runs events and elements through the eventRender hook.\n    resolveEventEl: function resolveEventEl(event, el) {\n      var custom = this.trigger('eventRender', event, event, el);\n\n      if (custom === false) {\n        // means don't render at all\n        el = null;\n      } else if (custom && custom !== true) {\n        el = $(custom);\n      }\n\n      return el;\n    },\n    // Hides all rendered event segments linked to the given event\n    showEvent: function showEvent(event) {\n      this.renderedEventSegEach(function (seg) {\n        seg.el.css('visibility', '');\n      }, event);\n    },\n    // Shows all rendered event segments linked to the given event\n    hideEvent: function hideEvent(event) {\n      this.renderedEventSegEach(function (seg) {\n        seg.el.css('visibility', 'hidden');\n      }, event);\n    },\n    // Iterates through event segments that have been rendered (have an el). Goes through all by default.\n    // If the optional `event` argument is specified, only iterates through segments linked to that event.\n    // The `this` value of the callback function will be the view.\n    renderedEventSegEach: function renderedEventSegEach(func, event) {\n      var segs = this.getEventSegs();\n      var i;\n\n      for (i = 0; i < segs.length; i++) {\n        if (!event || segs[i].event._id === event._id) {\n          if (segs[i].el) {\n            func.call(this, segs[i]);\n          }\n        }\n      }\n    },\n    // Retrieves all the rendered segment objects for the view\n    getEventSegs: function getEventSegs() {\n      // subclasses must implement\n      return [];\n    },\n\n    /* Event Drag-n-Drop\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Computes if the given event is allowed to be dragged by the user\n    isEventDraggable: function isEventDraggable(event) {\n      var source = event.source || {};\n      return firstDefined(event.startEditable, source.startEditable, this.opt('eventStartEditable'), event.editable, source.editable, this.opt('editable'));\n    },\n    // Must be called when an event in the view is dropped onto new location.\n    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\n    reportEventDrop: function reportEventDrop(event, dropLocation, largeUnit, el, ev) {\n      var calendar = this.calendar;\n      var mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);\n\n      var undoFunc = function undoFunc() {\n        mutateResult.undo();\n        calendar.reportEventChange();\n      };\n\n      this.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);\n      calendar.reportEventChange(); // will rerender events\n    },\n    // Triggers event-drop handlers that have subscribed via the API\n    triggerEventDrop: function triggerEventDrop(event, dateDelta, undoFunc, el, ev) {\n      this.trigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy\n    },\n\n    /* External Element Drag-n-Drop\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\n    // `meta` is the parsed data that has been embedded into the dragging event.\n    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\n    reportExternalDrop: function reportExternalDrop(meta, dropLocation, el, ev, ui) {\n      var eventProps = meta.eventProps;\n      var eventInput;\n      var event; // Try to build an event object and render it. TODO: decouple the two\n\n      if (eventProps) {\n        eventInput = $.extend({}, eventProps, dropLocation);\n        event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array\n      }\n\n      this.triggerExternalDrop(event, dropLocation, el, ev, ui);\n    },\n    // Triggers external-drop handlers that have subscribed via the API\n    triggerExternalDrop: function triggerExternalDrop(event, dropLocation, el, ev, ui) {\n      // trigger 'drop' regardless of whether element represents an event\n      this.trigger('drop', el[0], dropLocation.start, ev, ui);\n\n      if (event) {\n        this.trigger('eventReceive', null, event); // signal an external event landed\n      }\n    },\n\n    /* Drag-n-Drop Rendering (for both events and external elements)\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of a event or external-element drag over the given drop zone.\n    // If an external-element, seg will be `null`.\n    // Must return elements used for any mock events.\n    renderDrag: function renderDrag(dropLocation, seg) {// subclasses must implement\n    },\n    // Unrenders a visual indication of an event or external-element being dragged.\n    unrenderDrag: function unrenderDrag() {// subclasses must implement\n    },\n\n    /* Event Resizing\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Computes if the given event is allowed to be resized from its starting edge\n    isEventResizableFromStart: function isEventResizableFromStart(event) {\n      return this.opt('eventResizableFromStart') && this.isEventResizable(event);\n    },\n    // Computes if the given event is allowed to be resized from its ending edge\n    isEventResizableFromEnd: function isEventResizableFromEnd(event) {\n      return this.isEventResizable(event);\n    },\n    // Computes if the given event is allowed to be resized by the user at all\n    isEventResizable: function isEventResizable(event) {\n      var source = event.source || {};\n      return firstDefined(event.durationEditable, source.durationEditable, this.opt('eventDurationEditable'), event.editable, source.editable, this.opt('editable'));\n    },\n    // Must be called when an event in the view has been resized to a new length\n    reportEventResize: function reportEventResize(event, resizeLocation, largeUnit, el, ev) {\n      var calendar = this.calendar;\n      var mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);\n\n      var undoFunc = function undoFunc() {\n        mutateResult.undo();\n        calendar.reportEventChange();\n      };\n\n      this.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);\n      calendar.reportEventChange(); // will rerender events\n    },\n    // Triggers event-resize handlers that have subscribed via the API\n    triggerEventResize: function triggerEventResize(event, durationDelta, undoFunc, el, ev) {\n      this.trigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy\n    },\n\n    /* Selection (time range)\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Selects a date span on the view. `start` and `end` are both Moments.\n    // `ev` is the native mouse event that begin the interaction.\n    select: function select(span, ev) {\n      this.unselect(ev);\n      this.renderSelection(span);\n      this.reportSelection(span, ev);\n    },\n    // Renders a visual indication of the selection\n    renderSelection: function renderSelection(span) {// subclasses should implement\n    },\n    // Called when a new selection is made. Updates internal state and triggers handlers.\n    reportSelection: function reportSelection(span, ev) {\n      this.isSelected = true;\n      this.triggerSelect(span, ev);\n    },\n    // Triggers handlers to 'select'\n    triggerSelect: function triggerSelect(span, ev) {\n      this.trigger('select', null, this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API\n      this.calendar.applyTimezone(span.end), // \"\n      ev);\n    },\n    // Undoes a selection. updates in the internal state and triggers handlers.\n    // `ev` is the native mouse event that began the interaction.\n    unselect: function unselect(ev) {\n      if (this.isSelected) {\n        this.isSelected = false;\n\n        if (this.destroySelection) {\n          this.destroySelection(); // TODO: deprecate\n        }\n\n        this.unrenderSelection();\n        this.trigger('unselect', null, ev);\n      }\n    },\n    // Unrenders a visual indication of selection\n    unrenderSelection: function unrenderSelection() {// subclasses should implement\n    },\n\n    /* Event Selection\n    ------------------------------------------------------------------------------------------------------------------*/\n    selectEvent: function selectEvent(event) {\n      if (!this.selectedEvent || this.selectedEvent !== event) {\n        this.unselectEvent();\n        this.renderedEventSegEach(function (seg) {\n          seg.el.addClass('fc-selected');\n        }, event);\n        this.selectedEvent = event;\n      }\n    },\n    unselectEvent: function unselectEvent() {\n      if (this.selectedEvent) {\n        this.renderedEventSegEach(function (seg) {\n          seg.el.removeClass('fc-selected');\n        }, this.selectedEvent);\n        this.selectedEvent = null;\n      }\n    },\n    isEventSelected: function isEventSelected(event) {\n      // event references might change on refetchEvents(), while selectedEvent doesn't,\n      // so compare IDs\n      return this.selectedEvent && this.selectedEvent._id === event._id;\n    },\n\n    /* Mouse / Touch Unselecting (time range & event unselection)\n    ------------------------------------------------------------------------------------------------------------------*/\n    // TODO: move consistently to down/start or up/end?\n    // TODO: don't kill previous selection if touch scrolling\n    handleDocumentMousedown: function handleDocumentMousedown(ev) {\n      if (isPrimaryMouseButton(ev)) {\n        this.processUnselect(ev);\n      }\n    },\n    processUnselect: function processUnselect(ev) {\n      this.processRangeUnselect(ev);\n      this.processEventUnselect(ev);\n    },\n    processRangeUnselect: function processRangeUnselect(ev) {\n      var ignore; // is there a time-range selection?\n\n      if (this.isSelected && this.opt('unselectAuto')) {\n        // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\n        ignore = this.opt('unselectCancel');\n\n        if (!ignore || !$(ev.target).closest(ignore).length) {\n          this.unselect(ev);\n        }\n      }\n    },\n    processEventUnselect: function processEventUnselect(ev) {\n      if (this.selectedEvent) {\n        if (!$(ev.target).closest('.fc-selected').length) {\n          this.unselectEvent();\n        }\n      }\n    },\n\n    /* Day Click\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Triggers handlers to 'dayClick'\n    // Span has start/end of the clicked area. Only the start is useful.\n    triggerDayClick: function triggerDayClick(span, dayEl, ev) {\n      this.trigger('dayClick', dayEl, this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API\n      ev);\n    },\n\n    /* Date Utils\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Initializes internal variables related to calculating hidden days-of-week\n    initHiddenDays: function initHiddenDays() {\n      var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\n\n      var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n\n      var dayCnt = 0;\n      var i;\n\n      if (this.opt('weekends') === false) {\n        hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n      }\n\n      for (i = 0; i < 7; i++) {\n        if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {\n          dayCnt++;\n        }\n      }\n\n      if (!dayCnt) {\n        throw 'invalid hiddenDays'; // all days were hidden? bad.\n      }\n\n      this.isHiddenDayHash = isHiddenDayHash;\n    },\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Moment\n    isHiddenDay: function isHiddenDay(day) {\n      if (moment.isMoment(day)) {\n        day = day.day();\n      }\n\n      return this.isHiddenDayHash[day];\n    },\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    skipHiddenDays: function skipHiddenDays(date, inc, isExclusive) {\n      var out = date.clone();\n      inc = inc || 1;\n\n      while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {\n        out.add(inc, 'days');\n      }\n\n      return out;\n    },\n    // Returns the date range of the full days the given range visually appears to occupy.\n    // Returns a new range object.\n    computeDayRange: function computeDayRange(range) {\n      var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts\n\n      var end = range.end;\n      var endDay = null;\n      var endTimeMS;\n\n      if (end) {\n        endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\n\n        endTimeMS = +end.time(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n\n        if (endTimeMS && endTimeMS >= this.nextDayThreshold) {\n          endDay.add(1, 'days');\n        }\n      } // If no end was specified, or if it is within `startDay` but not past nextDayThreshold,\n      // assign the default duration of one day.\n\n\n      if (!end || endDay <= startDay) {\n        endDay = startDay.clone().add(1, 'days');\n      }\n\n      return {\n        start: startDay,\n        end: endDay\n      };\n    },\n    // Does the given event visually appear to occupy more than one day?\n    isMultiDayEvent: function isMultiDayEvent(event) {\n      var range = this.computeDayRange(event); // event is range-ish\n\n      return range.end.diff(range.start, 'days') > 1;\n    }\n  });\n  ;\n  ;\n  /*\n  Embodies a div that has potential scrollbars\n  */\n\n  var Scroller = FC.Scroller = Class.extend({\n    el: null,\n    // the guaranteed outer element\n    scrollEl: null,\n    // the element with the scrollbars\n    overflowX: null,\n    overflowY: null,\n    constructor: function constructor(options) {\n      options = options || {};\n      this.overflowX = options.overflowX || options.overflow || 'auto';\n      this.overflowY = options.overflowY || options.overflow || 'auto';\n    },\n    render: function render() {\n      this.el = this.renderEl();\n      this.applyOverflow();\n    },\n    renderEl: function renderEl() {\n      return this.scrollEl = $('<div class=\"fc-scroller\"></div>');\n    },\n    // sets to natural height, unlocks overflow\n    clear: function clear() {\n      this.setHeight('auto');\n      this.applyOverflow();\n    },\n    destroy: function destroy() {\n      this.el.remove();\n    },\n    // Overflow\n    // -----------------------------------------------------------------------------------------------------------------\n    applyOverflow: function applyOverflow() {\n      this.scrollEl.css({\n        'overflow-x': this.overflowX,\n        'overflow-y': this.overflowY\n      });\n    },\n    // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\n    // Useful for preserving scrollbar widths regardless of future resizes.\n    // Can pass in scrollbarWidths for optimization.\n    lockOverflow: function lockOverflow(scrollbarWidths) {\n      var overflowX = this.overflowX;\n      var overflowY = this.overflowY;\n      scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\n\n      if (overflowX === 'auto') {\n        overflowX = scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\n        // OR scrolling pane with massless scrollbars?\n        this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth // subtract 1 because of IE off-by-one issue\n        ? 'scroll' : 'hidden';\n      }\n\n      if (overflowY === 'auto') {\n        overflowY = scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\n        // OR scrolling pane with massless scrollbars?\n        this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight // subtract 1 because of IE off-by-one issue\n        ? 'scroll' : 'hidden';\n      }\n\n      this.scrollEl.css({\n        'overflow-x': overflowX,\n        'overflow-y': overflowY\n      });\n    },\n    // Getters / Setters\n    // -----------------------------------------------------------------------------------------------------------------\n    setHeight: function setHeight(height) {\n      this.scrollEl.height(height);\n    },\n    getScrollTop: function getScrollTop() {\n      return this.scrollEl.scrollTop();\n    },\n    setScrollTop: function setScrollTop(top) {\n      this.scrollEl.scrollTop(top);\n    },\n    getClientWidth: function getClientWidth() {\n      return this.scrollEl[0].clientWidth;\n    },\n    getClientHeight: function getClientHeight() {\n      return this.scrollEl[0].clientHeight;\n    },\n    getScrollbarWidths: function getScrollbarWidths() {\n      return _getScrollbarWidths(this.scrollEl);\n    }\n  });\n  ;\n  ;\n  var Calendar = FC.Calendar = Class.extend({\n    dirDefaults: null,\n    // option defaults related to LTR or RTL\n    langDefaults: null,\n    // option defaults related to current locale\n    overrides: null,\n    // option overrides given to the fullCalendar constructor\n    dynamicOverrides: null,\n    // options set with dynamic setter method. higher precedence than view overrides.\n    options: null,\n    // all defaults combined with overrides\n    viewSpecCache: null,\n    // cache of view definitions\n    view: null,\n    // current View object\n    header: null,\n    loadingLevel: 0,\n    // number of simultaneous loading tasks\n    // a lot of this class' OOP logic is scoped within this constructor function,\n    // but in the future, write individual methods on the prototype.\n    constructor: Calendar_constructor,\n    // Subclasses can override this for initialization logic after the constructor has been called\n    initialize: function initialize() {},\n    // Computes the flattened options hash for the calendar and assigns to `this.options`.\n    // Assumes this.overrides and this.dynamicOverrides have already been initialized.\n    populateOptionsHash: function populateOptionsHash() {\n      var lang, langDefaults;\n      var isRTL, dirDefaults;\n      lang = firstDefined( // explicit lang option given?\n      this.dynamicOverrides.lang, this.overrides.lang);\n      langDefaults = langOptionHash[lang];\n\n      if (!langDefaults) {\n        // explicit lang option not given or invalid?\n        lang = Calendar.defaults.lang;\n        langDefaults = langOptionHash[lang] || {};\n      }\n\n      isRTL = firstDefined( // based on options computed so far, is direction RTL?\n      this.dynamicOverrides.isRTL, this.overrides.isRTL, langDefaults.isRTL, Calendar.defaults.isRTL);\n      dirDefaults = isRTL ? Calendar.rtlDefaults : {};\n      this.dirDefaults = dirDefaults;\n      this.langDefaults = langDefaults;\n      this.options = mergeOptions([// merge defaults and overrides. lowest to highest precedence\n      Calendar.defaults, // global defaults\n      dirDefaults, langDefaults, this.overrides, this.dynamicOverrides]);\n      populateInstanceComputableOptions(this.options); // fill in gaps with computed options\n    },\n    // Gets information about how to create a view. Will use a cache.\n    getViewSpec: function getViewSpec(viewType) {\n      var cache = this.viewSpecCache;\n      return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\n    },\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    getUnitViewSpec: function getUnitViewSpec(unit) {\n      var viewTypes;\n      var i;\n      var spec;\n\n      if ($.inArray(unit, intervalUnits) != -1) {\n        // put views that have buttons first. there will be duplicates, but oh well\n        viewTypes = this.header.getViewsWithButtons();\n        $.each(FC.views, function (viewType) {\n          // all views\n          viewTypes.push(viewType);\n        });\n\n        for (i = 0; i < viewTypes.length; i++) {\n          spec = this.getViewSpec(viewTypes[i]);\n\n          if (spec) {\n            if (spec.singleUnit == unit) {\n              return spec;\n            }\n          }\n        }\n      }\n    },\n    // Builds an object with information on how to create a given view\n    buildViewSpec: function buildViewSpec(requestedViewType) {\n      var viewOverrides = this.overrides.views || {};\n      var specChain = []; // for the view. lowest to highest priority\n\n      var defaultsChain = []; // for the view. lowest to highest priority\n\n      var overridesChain = []; // for the view. lowest to highest priority\n\n      var viewType = requestedViewType;\n      var spec; // for the view\n\n      var overrides; // for the view\n\n      var duration;\n      var unit; // iterate from the specific view definition to a more general one until we hit an actual View class\n\n      while (viewType) {\n        spec = fcViews[viewType];\n        overrides = viewOverrides[viewType];\n        viewType = null; // clear. might repopulate for another iteration\n\n        if (typeof spec === 'function') {\n          // TODO: deprecate\n          spec = {\n            'class': spec\n          };\n        }\n\n        if (spec) {\n          specChain.unshift(spec);\n          defaultsChain.unshift(spec.defaults || {});\n          duration = duration || spec.duration;\n          viewType = viewType || spec.type;\n        }\n\n        if (overrides) {\n          overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\n\n          duration = duration || overrides.duration;\n          viewType = viewType || overrides.type;\n        }\n      }\n\n      spec = mergeProps(specChain);\n      spec.type = requestedViewType;\n\n      if (!spec['class']) {\n        return false;\n      }\n\n      if (duration) {\n        duration = moment.duration(duration);\n\n        if (duration.valueOf()) {\n          // valid?\n          spec.duration = duration;\n          unit = computeIntervalUnit(duration); // view is a single-unit duration, like \"week\" or \"day\"\n          // incorporate options for this. lowest priority\n\n          if (duration.as(unit) === 1) {\n            spec.singleUnit = unit;\n            overridesChain.unshift(viewOverrides[unit] || {});\n          }\n        }\n      }\n\n      spec.defaults = mergeOptions(defaultsChain);\n      spec.overrides = mergeOptions(overridesChain);\n      this.buildViewSpecOptions(spec);\n      this.buildViewSpecButtonText(spec, requestedViewType);\n      return spec;\n    },\n    // Builds and assigns a view spec's options object from its already-assigned defaults and overrides\n    buildViewSpecOptions: function buildViewSpecOptions(spec) {\n      spec.options = mergeOptions([// lowest to highest priority\n      Calendar.defaults, // global defaults\n      spec.defaults, // view's defaults (from ViewSubclass.defaults)\n      this.dirDefaults, this.langDefaults, // locale and dir take precedence over view's defaults!\n      this.overrides, // calendar's overrides (options given to constructor)\n      spec.overrides, // view's overrides (view-specific options)\n      this.dynamicOverrides // dynamically set via setter. highest precedence\n      ]);\n      populateInstanceComputableOptions(spec.options);\n    },\n    // Computes and assigns a view spec's buttonText-related options\n    buildViewSpecButtonText: function buildViewSpecButtonText(spec, requestedViewType) {\n      // given an options object with a possible `buttonText` hash, lookup the buttonText for the\n      // requested view, falling back to a generic unit entry like \"week\" or \"day\"\n      function queryButtonText(options) {\n        var buttonText = options.buttonText || {};\n        return buttonText[requestedViewType] || (spec.singleUnit ? buttonText[spec.singleUnit] : null);\n      } // highest to lowest priority\n\n\n      spec.buttonTextOverride = queryButtonText(this.dynamicOverrides) || queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence\n      spec.overrides.buttonText; // `buttonText` for view-specific options is a string\n      // highest to lowest priority. mirrors buildViewSpecOptions\n\n      spec.buttonTextDefault = queryButtonText(this.langDefaults) || queryButtonText(this.dirDefaults) || spec.defaults.buttonText || // a single string. from ViewSubclass.defaults\n      queryButtonText(Calendar.defaults) || (spec.duration ? this.humanizeDuration(spec.duration) : null) || // like \"3 days\"\n      requestedViewType; // fall back to given view name\n    },\n    // Given a view name for a custom view or a standard view, creates a ready-to-go View object\n    instantiateView: function instantiateView(viewType) {\n      var spec = this.getViewSpec(viewType);\n      return new spec['class'](this, viewType, spec.options, spec.duration);\n    },\n    // Returns a boolean about whether the view is okay to instantiate at some point\n    isValidViewType: function isValidViewType(viewType) {\n      return Boolean(this.getViewSpec(viewType));\n    },\n    // Should be called when any type of async data fetching begins\n    pushLoading: function pushLoading() {\n      if (!this.loadingLevel++) {\n        this.trigger('loading', null, true, this.view);\n      }\n    },\n    // Should be called when any type of async data fetching completes\n    popLoading: function popLoading() {\n      if (! --this.loadingLevel) {\n        this.trigger('loading', null, false, this.view);\n      }\n    },\n    // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\n    buildSelectSpan: function buildSelectSpan(zonedStartInput, zonedEndInput) {\n      var start = this.moment(zonedStartInput).stripZone();\n      var end;\n\n      if (zonedEndInput) {\n        end = this.moment(zonedEndInput).stripZone();\n      } else if (start.hasTime()) {\n        end = start.clone().add(this.defaultTimedEventDuration);\n      } else {\n        end = start.clone().add(this.defaultAllDayEventDuration);\n      }\n\n      return {\n        start: start,\n        end: end\n      };\n    }\n  });\n  Calendar.mixin(EmitterMixin);\n\n  function Calendar_constructor(element, overrides) {\n    var t = this; // Exports\n    // -----------------------------------------------------------------------------------\n\n    t.render = render;\n    t.destroy = destroy;\n    t.refetchEvents = refetchEvents;\n    t.refetchEventSources = refetchEventSources;\n    t.reportEvents = reportEvents;\n    t.reportEventChange = reportEventChange;\n    t.rerenderEvents = renderEvents; // `renderEvents` serves as a rerender. an API method\n\n    t.changeView = renderView; // `renderView` will switch to another view\n\n    t.select = select;\n    t.unselect = unselect;\n    t.prev = prev;\n    t.next = next;\n    t.prevYear = prevYear;\n    t.nextYear = nextYear;\n    t.today = today;\n    t.gotoDate = gotoDate;\n    t.incrementDate = incrementDate;\n    t.zoomTo = zoomTo;\n    t.getDate = getDate;\n    t.getCalendar = getCalendar;\n    t.getView = getView;\n    t.option = option; // getter/setter method\n\n    t.trigger = trigger; // Options\n    // -----------------------------------------------------------------------------------\n\n    t.dynamicOverrides = {};\n    t.viewSpecCache = {};\n    t.optionHandlers = {}; // for Calendar.options.js\n    // convert legacy options into non-legacy ones.\n    // in the future, when this is removed, don't use `overrides` reference. make a copy.\n\n    t.overrides = massageOverrides(overrides || {});\n    t.populateOptionsHash(); // sets this.options\n    // Language-data Internals\n    // -----------------------------------------------------------------------------------\n    // Apply overrides to the current language's data\n\n    var localeData; // Called immediately, and when any of the options change.\n    // Happens before any internal objects rebuild or rerender, because this is very core.\n\n    t.bindOptions(['lang', 'monthNames', 'monthNamesShort', 'dayNames', 'dayNamesShort', 'firstDay', 'weekNumberCalculation'], function (lang, monthNames, monthNamesShort, dayNames, dayNamesShort, firstDay, weekNumberCalculation) {\n      localeData = createObject( // make a cheap copy\n      getMomentLocaleData(lang) // will fall back to en\n      );\n\n      if (monthNames) {\n        localeData._months = monthNames;\n      }\n\n      if (monthNamesShort) {\n        localeData._monthsShort = monthNamesShort;\n      }\n\n      if (dayNames) {\n        localeData._weekdays = dayNames;\n      }\n\n      if (dayNamesShort) {\n        localeData._weekdaysShort = dayNamesShort;\n      }\n\n      if (firstDay != null) {\n        var _week = createObject(localeData._week); // _week: { dow: # }\n\n\n        _week.dow = firstDay;\n        localeData._week = _week;\n      }\n\n      if (weekNumberCalculation === 'iso') {\n        weekNumberCalculation = 'ISO'; // normalize\n      }\n\n      if ( // whitelist certain kinds of input\n      weekNumberCalculation === 'ISO' || weekNumberCalculation === 'local' || typeof weekNumberCalculation === 'function') {\n        localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\n      } // If the internal current date object already exists, move to new locale.\n      // We do NOT need to do this technique for event dates, because this happens when converting to \"segments\".\n\n\n      if (date) {\n        localizeMoment(date); // sets to localeData\n      }\n    }); // Calendar-specific Date Utilities\n    // -----------------------------------------------------------------------------------\n\n    t.defaultAllDayEventDuration = moment.duration(t.options.defaultAllDayEventDuration);\n    t.defaultTimedEventDuration = moment.duration(t.options.defaultTimedEventDuration); // Builds a moment using the settings of the current calendar: timezone and language.\n    // Accepts anything the vanilla moment() constructor accepts.\n\n    t.moment = function () {\n      var mom;\n\n      if (t.options.timezone === 'local') {\n        mom = FC.moment.apply(null, arguments); // Force the moment to be local, because FC.moment doesn't guarantee it.\n\n        if (mom.hasTime()) {\n          // don't give ambiguously-timed moments a local zone\n          mom.local();\n        }\n      } else if (t.options.timezone === 'UTC') {\n        mom = FC.moment.utc.apply(null, arguments); // process as UTC\n      } else {\n        mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone\n      }\n\n      localizeMoment(mom);\n      return mom;\n    }; // Updates the given moment's locale settings to the current calendar locale settings.\n\n\n    function localizeMoment(mom) {\n      if ('_locale' in mom) {\n        // moment 2.8 and above\n        mom._locale = localeData;\n      } else {\n        // pre-moment-2.8\n        mom._lang = localeData;\n      }\n    } // Returns a boolean about whether or not the calendar knows how to calculate\n    // the timezone offset of arbitrary dates in the current timezone.\n\n\n    t.getIsAmbigTimezone = function () {\n      return t.options.timezone !== 'local' && t.options.timezone !== 'UTC';\n    }; // Returns a copy of the given date in the current timezone. Has no effect on dates without times.\n\n\n    t.applyTimezone = function (date) {\n      if (!date.hasTime()) {\n        return date.clone();\n      }\n\n      var zonedDate = t.moment(date.toArray());\n      var timeAdjust = date.time() - zonedDate.time();\n      var adjustedZonedDate; // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\n\n      if (timeAdjust) {\n        // is the time result different than expected?\n        adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\n\n        if (date.time() - adjustedZonedDate.time() === 0) {\n          // does it match perfectly now?\n          zonedDate = adjustedZonedDate;\n        }\n      }\n\n      return zonedDate;\n    }; // Returns a moment for the current date, as defined by the client's computer or from the `now` option.\n    // Will return an moment with an ambiguous timezone.\n\n\n    t.getNow = function () {\n      var now = t.options.now;\n\n      if (typeof now === 'function') {\n        now = now();\n      }\n\n      return t.moment(now).stripZone();\n    }; // Get an event's normalized end date. If not present, calculate it from the defaults.\n\n\n    t.getEventEnd = function (event) {\n      if (event.end) {\n        return event.end.clone();\n      } else {\n        return t.getDefaultEventEnd(event.allDay, event.start);\n      }\n    }; // Given an event's allDay status and start date, return what its fallback end date should be.\n    // TODO: rename to computeDefaultEventEnd\n\n\n    t.getDefaultEventEnd = function (allDay, zonedStart) {\n      var end = zonedStart.clone();\n\n      if (allDay) {\n        end.stripTime().add(t.defaultAllDayEventDuration);\n      } else {\n        end.add(t.defaultTimedEventDuration);\n      }\n\n      if (t.getIsAmbigTimezone()) {\n        end.stripZone(); // we don't know what the tzo should be\n      }\n\n      return end;\n    }; // Produces a human-readable string for the given duration.\n    // Side-effect: changes the locale of the given duration.\n\n\n    t.humanizeDuration = function (duration) {\n      return (duration.locale || duration.lang).call(duration, t.options.lang) // works moment-pre-2.8\n      .humanize();\n    }; // Imports\n    // -----------------------------------------------------------------------------------\n\n\n    EventManager.call(t);\n    var isFetchNeeded = t.isFetchNeeded;\n    var fetchEvents = t.fetchEvents;\n    var fetchEventSources = t.fetchEventSources; // Locals\n    // -----------------------------------------------------------------------------------\n\n    var _element = element[0];\n    var header;\n    var content;\n    var tm; // for making theme classes\n\n    var currentView; // NOTE: keep this in sync with this.view\n\n    var viewsByType = {}; // holds all instantiated view instances, current or not\n\n    var suggestedViewHeight;\n    var windowResizeProxy; // wraps the windowResize function\n\n    var ignoreWindowResize = 0;\n    var events = [];\n    var date; // unzoned\n    // Main Rendering\n    // -----------------------------------------------------------------------------------\n    // compute the initial ambig-timezone date\n\n    if (t.options.defaultDate != null) {\n      date = t.moment(t.options.defaultDate).stripZone();\n    } else {\n      date = t.getNow(); // getNow already returns unzoned\n    }\n\n    function render() {\n      if (!content) {\n        initialRender();\n      } else if (elementVisible()) {\n        // mainly for the public API\n        calcSize();\n        renderView();\n      }\n    }\n\n    function initialRender() {\n      element.addClass('fc'); // called immediately, and upon option change\n\n      t.bindOption('theme', function (theme) {\n        tm = theme ? 'ui' : 'fc'; // affects a larger scope\n\n        element.toggleClass('ui-widget', theme);\n        element.toggleClass('fc-unthemed', !theme);\n      }); // called immediately, and upon option change.\n      // HACK: lang often affects isRTL, so we explicitly listen to that too.\n\n      t.bindOptions(['isRTL', 'lang'], function (isRTL) {\n        element.toggleClass('fc-ltr', !isRTL);\n        element.toggleClass('fc-rtl', isRTL);\n      });\n      content = $(\"<div class='fc-view-container'/>\").prependTo(element);\n      header = t.header = new Header(t);\n      renderHeader();\n      renderView(t.options.defaultView);\n\n      if (t.options.handleWindowResize) {\n        windowResizeProxy = debounce(windowResize, t.options.windowResizeDelay); // prevents rapid calls\n\n        $(window).resize(windowResizeProxy);\n      }\n    } // can be called repeatedly and Header will rerender\n\n\n    function renderHeader() {\n      header.render();\n\n      if (header.el) {\n        element.prepend(header.el);\n      }\n    }\n\n    function destroy() {\n      if (currentView) {\n        currentView.removeElement(); // NOTE: don't null-out currentView/t.view in case API methods are called after destroy.\n        // It is still the \"current\" view, just not rendered.\n      }\n\n      header.removeElement();\n      content.remove();\n      element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');\n\n      if (windowResizeProxy) {\n        $(window).unbind('resize', windowResizeProxy);\n      }\n    }\n\n    function elementVisible() {\n      return element.is(':visible');\n    } // View Rendering\n    // -----------------------------------------------------------------------------------\n    // Renders a view because of a date change, view-type change, or for the first time.\n    // If not given a viewType, keep the current view but render different dates.\n    // Accepts an optional scroll state to restore to.\n\n\n    function renderView(viewType, explicitScrollState) {\n      ignoreWindowResize++; // if viewType is changing, remove the old view's rendering\n\n      if (currentView && viewType && currentView.type !== viewType) {\n        freezeContentHeight(); // prevent a scroll jump when view element is removed\n\n        clearView();\n      } // if viewType changed, or the view was never created, create a fresh view\n\n\n      if (!currentView && viewType) {\n        currentView = t.view = viewsByType[viewType] || (viewsByType[viewType] = t.instantiateView(viewType));\n        currentView.setElement($(\"<div class='fc-view fc-\" + viewType + \"-view' />\").appendTo(content));\n        header.activateButton(viewType);\n      }\n\n      if (currentView) {\n        // in case the view should render a period of time that is completely hidden\n        date = currentView.massageCurrentDate(date); // render or rerender the view\n\n        if (!currentView.displaying || !date.isWithin(currentView.intervalStart, currentView.intervalEnd) // implicit date window change\n        ) {\n            if (elementVisible()) {\n              currentView.display(date, explicitScrollState); // will call freezeContentHeight\n\n              unfreezeContentHeight(); // immediately unfreeze regardless of whether display is async\n              // need to do this after View::render, so dates are calculated\n\n              updateHeaderTitle();\n              updateTodayButton();\n              getAndRenderEvents();\n            }\n          }\n      }\n\n      unfreezeContentHeight(); // undo any lone freezeContentHeight calls\n\n      ignoreWindowResize--;\n    } // Unrenders the current view and reflects this change in the Header.\n    // Unregsiters the `currentView`, but does not remove from viewByType hash.\n\n\n    function clearView() {\n      header.deactivateButton(currentView.type);\n      currentView.removeElement();\n      currentView = t.view = null;\n    } // Destroys the view, including the view object. Then, re-instantiates it and renders it.\n    // Maintains the same scroll state.\n    // TODO: maintain any other user-manipulated state.\n\n\n    function reinitView() {\n      ignoreWindowResize++;\n      freezeContentHeight();\n      var viewType = currentView.type;\n      var scrollState = currentView.queryScroll();\n      clearView();\n      renderView(viewType, scrollState);\n      unfreezeContentHeight();\n      ignoreWindowResize--;\n    } // Resizing\n    // -----------------------------------------------------------------------------------\n\n\n    t.getSuggestedViewHeight = function () {\n      if (suggestedViewHeight === undefined) {\n        calcSize();\n      }\n\n      return suggestedViewHeight;\n    };\n\n    t.isHeightAuto = function () {\n      return t.options.contentHeight === 'auto' || t.options.height === 'auto';\n    };\n\n    function updateSize(shouldRecalc) {\n      if (elementVisible()) {\n        if (shouldRecalc) {\n          _calcSize();\n        }\n\n        ignoreWindowResize++;\n        currentView.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()\n\n        ignoreWindowResize--;\n        return true; // signal success\n      }\n    }\n\n    function calcSize() {\n      if (elementVisible()) {\n        _calcSize();\n      }\n    }\n\n    function _calcSize() {\n      // assumes elementVisible\n      if (typeof t.options.contentHeight === 'number') {\n        // exists and not 'auto'\n        suggestedViewHeight = t.options.contentHeight;\n      } else if (typeof t.options.height === 'number') {\n        // exists and not 'auto'\n        suggestedViewHeight = t.options.height - (header.el ? header.el.outerHeight(true) : 0);\n      } else {\n        suggestedViewHeight = Math.round(content.width() / Math.max(t.options.aspectRatio, .5));\n      }\n    }\n\n    function windowResize(ev) {\n      if (!ignoreWindowResize && ev.target === window && // so we don't process jqui \"resize\" events that have bubbled up\n      currentView.start // view has already been rendered\n      ) {\n          if (updateSize(true)) {\n            currentView.trigger('windowResize', _element);\n          }\n        }\n    }\n    /* Event Fetching/Rendering\n    -----------------------------------------------------------------------------*/\n    // TODO: going forward, most of this stuff should be directly handled by the view\n\n\n    function refetchEvents() {\n      // can be called as an API method\n      fetchAndRenderEvents();\n    } // TODO: move this into EventManager?\n\n\n    function refetchEventSources(matchInputs) {\n      fetchEventSources(t.getEventSourcesByMatchArray(matchInputs));\n    }\n\n    function renderEvents() {\n      // destroys old events if previously rendered\n      if (elementVisible()) {\n        freezeContentHeight();\n        currentView.displayEvents(events);\n        unfreezeContentHeight();\n      }\n    }\n\n    function getAndRenderEvents() {\n      if (!t.options.lazyFetching || isFetchNeeded(currentView.start, currentView.end)) {\n        fetchAndRenderEvents();\n      } else {\n        renderEvents();\n      }\n    }\n\n    function fetchAndRenderEvents() {\n      fetchEvents(currentView.start, currentView.end); // ... will call reportEvents\n      // ... which will call renderEvents\n    } // called when event data arrives\n\n\n    function reportEvents(_events) {\n      events = _events;\n      renderEvents();\n    } // called when a single event's data has been changed\n\n\n    function reportEventChange() {\n      renderEvents();\n    }\n    /* Header Updating\n    -----------------------------------------------------------------------------*/\n\n\n    function updateHeaderTitle() {\n      header.updateTitle(currentView.title);\n    }\n\n    function updateTodayButton() {\n      var now = t.getNow();\n\n      if (now.isWithin(currentView.intervalStart, currentView.intervalEnd)) {\n        header.disableButton('today');\n      } else {\n        header.enableButton('today');\n      }\n    }\n    /* Selection\n    -----------------------------------------------------------------------------*/\n    // this public method receives start/end dates in any format, with any timezone\n\n\n    function select(zonedStartInput, zonedEndInput) {\n      currentView.select(t.buildSelectSpan.apply(t, arguments));\n    }\n\n    function unselect() {\n      // safe to be called before renderView\n      if (currentView) {\n        currentView.unselect();\n      }\n    }\n    /* Date\n    -----------------------------------------------------------------------------*/\n\n\n    function prev() {\n      date = currentView.computePrevDate(date);\n      renderView();\n    }\n\n    function next() {\n      date = currentView.computeNextDate(date);\n      renderView();\n    }\n\n    function prevYear() {\n      date.add(-1, 'years');\n      renderView();\n    }\n\n    function nextYear() {\n      date.add(1, 'years');\n      renderView();\n    }\n\n    function today() {\n      date = t.getNow();\n      renderView();\n    }\n\n    function gotoDate(zonedDateInput) {\n      date = t.moment(zonedDateInput).stripZone();\n      renderView();\n    }\n\n    function incrementDate(delta) {\n      date.add(moment.duration(delta));\n      renderView();\n    } // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n\n\n    function zoomTo(newDate, viewType) {\n      var spec;\n      viewType = viewType || 'day'; // day is default zoom\n\n      spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);\n      date = newDate.clone();\n      renderView(spec ? spec.type : null);\n    } // for external API\n\n\n    function getDate() {\n      return t.applyTimezone(date); // infuse the calendar's timezone\n    }\n    /* Height \"Freezing\"\n    -----------------------------------------------------------------------------*/\n    // TODO: move this into the view\n\n\n    t.freezeContentHeight = freezeContentHeight;\n    t.unfreezeContentHeight = unfreezeContentHeight;\n\n    function freezeContentHeight() {\n      content.css({\n        width: '100%',\n        height: content.height(),\n        overflow: 'hidden'\n      });\n    }\n\n    function unfreezeContentHeight() {\n      content.css({\n        width: '',\n        height: '',\n        overflow: ''\n      });\n    }\n    /* Misc\n    -----------------------------------------------------------------------------*/\n\n\n    function getCalendar() {\n      return t;\n    }\n\n    function getView() {\n      return currentView;\n    }\n\n    function option(name, value) {\n      var newOptionHash;\n\n      if (typeof name === 'string') {\n        if (value === undefined) {\n          // getter\n          return t.options[name];\n        } else {\n          // setter for individual option\n          newOptionHash = {};\n          newOptionHash[name] = value;\n          setOptions(newOptionHash);\n        }\n      } else if (typeof name === 'object') {\n        // compound setter with object input\n        setOptions(name);\n      }\n    }\n\n    function setOptions(newOptionHash) {\n      var optionCnt = 0;\n      var optionName;\n\n      for (optionName in newOptionHash) {\n        t.dynamicOverrides[optionName] = newOptionHash[optionName];\n      }\n\n      t.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it\n\n      t.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override\n      // trigger handlers after this.options has been updated\n\n      for (optionName in newOptionHash) {\n        t.triggerOptionHandlers(optionName); // recall bindOption/bindOptions\n\n        optionCnt++;\n      } // special-case handling of single option change.\n      // if only one option change, `optionName` will be its name.\n\n\n      if (optionCnt === 1) {\n        if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\n          updateSize(true); // true = allow recalculation of height\n\n          return;\n        } else if (optionName === 'defaultDate') {\n          return; // can't change date this way. use gotoDate instead\n        } else if (optionName === 'businessHours') {\n          if (currentView) {\n            currentView.unrenderBusinessHours();\n            currentView.renderBusinessHours();\n          }\n\n          return;\n        } else if (optionName === 'timezone') {\n          t.rezoneArrayEventSources();\n          refetchEvents();\n          return;\n        }\n      } // catch-all. rerender the header and rebuild/rerender the current view\n\n\n      renderHeader();\n      viewsByType = {}; // even non-current views will be affected by this option change. do before rerender\n\n      reinitView();\n    }\n\n    function trigger(name, thisObj) {\n      // overrides the Emitter's trigger method :(\n      var args = Array.prototype.slice.call(arguments, 2);\n      thisObj = thisObj || _element;\n      this.triggerWith(name, thisObj, args); // Emitter's method\n\n      if (t.options[name]) {\n        return t.options[name].apply(thisObj, args);\n      }\n    }\n\n    t.initialize();\n  }\n\n  ;\n  ;\n  /*\n  Options binding/triggering system.\n  */\n\n  Calendar.mixin({\n    // A map of option names to arrays of handler objects. Initialized to {} in Calendar.\n    // Format for a handler object:\n    // {\n    //   func // callback function to be called upon change\n    //   names // option names whose values should be given to func\n    // }\n    optionHandlers: null,\n    // Calls handlerFunc immediately, and when the given option has changed.\n    // handlerFunc will be given the option value.\n    bindOption: function bindOption(optionName, handlerFunc) {\n      this.bindOptions([optionName], handlerFunc);\n    },\n    // Calls handlerFunc immediately, and when any of the given options change.\n    // handlerFunc will be given each option value as ordered function arguments.\n    bindOptions: function bindOptions(optionNames, handlerFunc) {\n      var handlerObj = {\n        func: handlerFunc,\n        names: optionNames\n      };\n      var i;\n\n      for (i = 0; i < optionNames.length; i++) {\n        this.registerOptionHandlerObj(optionNames[i], handlerObj);\n      }\n\n      this.triggerOptionHandlerObj(handlerObj);\n    },\n    // Puts the given handler object into the internal hash\n    registerOptionHandlerObj: function registerOptionHandlerObj(optionName, handlerObj) {\n      (this.optionHandlers[optionName] || (this.optionHandlers[optionName] = [])).push(handlerObj);\n    },\n    // Reports that the given option has changed, and calls all appropriate handlers.\n    triggerOptionHandlers: function triggerOptionHandlers(optionName) {\n      var handlerObjs = this.optionHandlers[optionName] || [];\n      var i;\n\n      for (i = 0; i < handlerObjs.length; i++) {\n        this.triggerOptionHandlerObj(handlerObjs[i]);\n      }\n    },\n    // Calls the callback for a specific handler object, passing in the appropriate arguments.\n    triggerOptionHandlerObj: function triggerOptionHandlerObj(handlerObj) {\n      var optionNames = handlerObj.names;\n      var optionValues = [];\n      var i;\n\n      for (i = 0; i < optionNames.length; i++) {\n        optionValues.push(this.options[optionNames[i]]);\n      }\n\n      handlerObj.func.apply(this, optionValues); // maintain the Calendar's `this` context\n    }\n  });\n  ;\n  ;\n  Calendar.defaults = {\n    titleRangeSeparator: \" \\u2013 \",\n    // en dash\n    monthYearFormat: 'MMMM YYYY',\n    // required for en. other languages rely on datepicker computable option\n    defaultTimedEventDuration: '02:00:00',\n    defaultAllDayEventDuration: {\n      days: 1\n    },\n    forceEventDuration: false,\n    nextDayThreshold: '09:00:00',\n    // 9am\n    // display\n    defaultView: 'month',\n    aspectRatio: 1.35,\n    header: {\n      left: 'title',\n      center: '',\n      right: 'today prev,next'\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberTitle: 'W',\n    weekNumberCalculation: 'local',\n    //editable: false,\n    //nowIndicator: false,\n    scrollTime: '06:00:00',\n    // event ajax\n    lazyFetching: true,\n    startParam: 'start',\n    endParam: 'end',\n    timezoneParam: 'timezone',\n    timezone: false,\n    //allDayDefault: undefined,\n    // locale\n    isRTL: false,\n    buttonText: {\n      prev: \"prev\",\n      next: \"next\",\n      prevYear: \"prev year\",\n      nextYear: \"next year\",\n      year: 'year',\n      // TODO: locale files need to specify this\n      today: 'today',\n      month: 'month',\n      week: 'week',\n      day: 'day'\n    },\n    buttonIcons: {\n      prev: 'left-single-arrow',\n      next: 'right-single-arrow',\n      prevYear: 'left-double-arrow',\n      nextYear: 'right-double-arrow'\n    },\n    // jquery-ui theming\n    theme: false,\n    themeButtonIcons: {\n      prev: 'circle-triangle-w',\n      next: 'circle-triangle-e',\n      prevYear: 'seek-prev',\n      nextYear: 'seek-next'\n    },\n    //eventResizableFromStart: false,\n    dragOpacity: .75,\n    dragRevertDuration: 500,\n    dragScroll: true,\n    //selectable: false,\n    unselectAuto: true,\n    dropAccept: '*',\n    eventOrder: 'title',\n    eventLimit: false,\n    eventLimitText: 'more',\n    eventLimitClick: 'popover',\n    dayPopoverFormat: 'LL',\n    handleWindowResize: true,\n    windowResizeDelay: 200,\n    // milliseconds before an updateSize happens\n    longPressDelay: 1000\n  };\n  Calendar.englishDefaults = {\n    // used by lang.js\n    dayPopoverFormat: 'dddd, MMMM D'\n  };\n  Calendar.rtlDefaults = {\n    // right-to-left defaults\n    header: {\n      // TODO: smarter solution (first/center/last ?)\n      left: 'next,prev today',\n      center: '',\n      right: 'title'\n    },\n    buttonIcons: {\n      prev: 'right-single-arrow',\n      next: 'left-single-arrow',\n      prevYear: 'right-double-arrow',\n      nextYear: 'left-double-arrow'\n    },\n    themeButtonIcons: {\n      prev: 'circle-triangle-e',\n      next: 'circle-triangle-w',\n      nextYear: 'seek-prev',\n      prevYear: 'seek-next'\n    }\n  };\n  ;\n  ;\n  var langOptionHash = FC.langs = {}; // initialize and expose\n  // TODO: document the structure and ordering of a FullCalendar lang file\n  // TODO: rename everything \"lang\" to \"locale\", like what the moment project did\n  // Initialize jQuery UI datepicker translations while using some of the translations\n  // Will set this as the default language for datepicker.\n\n  FC.datepickerLang = function (langCode, dpLangCode, dpOptions) {\n    // get the FullCalendar internal option hash for this language. create if necessary\n    var fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {}); // transfer some simple options from datepicker to fc\n\n    fcOptions.isRTL = dpOptions.isRTL;\n    fcOptions.weekNumberTitle = dpOptions.weekHeader; // compute some more complex options from datepicker\n\n    $.each(dpComputableOptions, function (name, func) {\n      fcOptions[name] = func(dpOptions);\n    }); // is jQuery UI Datepicker is on the page?\n\n    if ($.datepicker) {\n      // Register the language data.\n      // FullCalendar and MomentJS use language codes like \"pt-br\" but Datepicker\n      // does it like \"pt-BR\" or if it doesn't have the language, maybe just \"pt\".\n      // Make an alias so the language can be referenced either way.\n      $.datepicker.regional[dpLangCode] = $.datepicker.regional[langCode] = // alias\n      dpOptions; // Alias 'en' to the default language data. Do this every time.\n\n      $.datepicker.regional.en = $.datepicker.regional['']; // Set as Datepicker's global defaults.\n\n      $.datepicker.setDefaults(dpOptions);\n    }\n  }; // Sets FullCalendar-specific translations. Will set the language as the global default.\n\n\n  FC.lang = function (langCode, newFcOptions) {\n    var fcOptions;\n    var momOptions; // get the FullCalendar internal option hash for this language. create if necessary\n\n    fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {}); // provided new options for this language? merge them in\n\n    if (newFcOptions) {\n      fcOptions = langOptionHash[langCode] = mergeOptions([fcOptions, newFcOptions]);\n    } // compute language options that weren't defined.\n    // always do this. newFcOptions can be undefined when initializing from i18n file,\n    // so no way to tell if this is an initialization or a default-setting.\n\n\n    momOptions = getMomentLocaleData(langCode); // will fall back to en\n\n    $.each(momComputableOptions, function (name, func) {\n      if (fcOptions[name] == null) {\n        fcOptions[name] = func(momOptions, fcOptions);\n      }\n    }); // set it as the default language for FullCalendar\n\n    Calendar.defaults.lang = langCode;\n  }; // NOTE: can't guarantee any of these computations will run because not every language has datepicker\n  // configs, so make sure there are English fallbacks for these in the defaults file.\n\n\n  var dpComputableOptions = {\n    buttonText: function buttonText(dpOptions) {\n      return {\n        // the translations sometimes wrongly contain HTML entities\n        prev: stripHtmlEntities(dpOptions.prevText),\n        next: stripHtmlEntities(dpOptions.nextText),\n        today: stripHtmlEntities(dpOptions.currentText)\n      };\n    },\n    // Produces format strings like \"MMMM YYYY\" -> \"September 2014\"\n    monthYearFormat: function monthYearFormat(dpOptions) {\n      return dpOptions.showMonthAfterYear ? 'YYYY[' + dpOptions.yearSuffix + '] MMMM' : 'MMMM YYYY[' + dpOptions.yearSuffix + ']';\n    }\n  };\n  var momComputableOptions = {\n    // Produces format strings like \"ddd M/D\" -> \"Fri 9/15\"\n    dayOfMonthFormat: function dayOfMonthFormat(momOptions, fcOptions) {\n      var format = momOptions.longDateFormat('l'); // for the format like \"M/D/YYYY\"\n      // strip the year off the edge, as well as other misc non-whitespace chars\n\n      format = format.replace(/^Y+[^\\w\\s]*|[^\\w\\s]*Y+$/g, '');\n\n      if (fcOptions.isRTL) {\n        format += ' ddd'; // for RTL, add day-of-week to end\n      } else {\n        format = 'ddd ' + format; // for LTR, add day-of-week to beginning\n      }\n\n      return format;\n    },\n    // Produces format strings like \"h:mma\" -> \"6:00pm\"\n    mediumTimeFormat: function mediumTimeFormat(momOptions) {\n      // can't be called `timeFormat` because collides with option\n      return momOptions.longDateFormat('LT').replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n    },\n    // Produces format strings like \"h(:mm)a\" -> \"6pm\" / \"6:30pm\"\n    smallTimeFormat: function smallTimeFormat(momOptions) {\n      return momOptions.longDateFormat('LT').replace(':mm', '(:mm)').replace(/(\\Wmm)$/, '($1)') // like above, but for foreign langs\n      .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n    },\n    // Produces format strings like \"h(:mm)t\" -> \"6p\" / \"6:30p\"\n    extraSmallTimeFormat: function extraSmallTimeFormat(momOptions) {\n      return momOptions.longDateFormat('LT').replace(':mm', '(:mm)').replace(/(\\Wmm)$/, '($1)') // like above, but for foreign langs\n      .replace(/\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\n    },\n    // Produces format strings like \"ha\" / \"H\" -> \"6pm\" / \"18\"\n    hourFormat: function hourFormat(momOptions) {\n      return momOptions.longDateFormat('LT').replace(':mm', '').replace(/(\\Wmm)$/, '') // like above, but for foreign langs\n      .replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n    },\n    // Produces format strings like \"h:mm\" -> \"6:30\" (with no AM/PM)\n    noMeridiemTimeFormat: function noMeridiemTimeFormat(momOptions) {\n      return momOptions.longDateFormat('LT').replace(/\\s*a$/i, ''); // remove trailing AM/PM\n    }\n  }; // options that should be computed off live calendar options (considers override options)\n  // TODO: best place for this? related to lang?\n  // TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\n\n  var instanceComputableOptions = {\n    // Produces format strings for results like \"Mo 16\"\n    smallDayDateFormat: function smallDayDateFormat(options) {\n      return options.isRTL ? 'D dd' : 'dd D';\n    },\n    // Produces format strings for results like \"Wk 5\"\n    weekFormat: function weekFormat(options) {\n      return options.isRTL ? 'w[ ' + options.weekNumberTitle + ']' : '[' + options.weekNumberTitle + ' ]w';\n    },\n    // Produces format strings for results like \"Wk5\"\n    smallWeekFormat: function smallWeekFormat(options) {\n      return options.isRTL ? 'w[' + options.weekNumberTitle + ']' : '[' + options.weekNumberTitle + ']w';\n    }\n  };\n\n  function populateInstanceComputableOptions(options) {\n    $.each(instanceComputableOptions, function (name, func) {\n      if (options[name] == null) {\n        options[name] = func(options);\n      }\n    });\n  } // Returns moment's internal locale data. If doesn't exist, returns English.\n  // Works with moment-pre-2.8\n\n\n  function getMomentLocaleData(langCode) {\n    var func = moment.localeData || moment.langData;\n    return func.call(moment, langCode) || func.call(moment, 'en'); // the newer localData could return null, so fall back to en\n  } // Initialize English by forcing computation of moment-derived options.\n  // Also, sets it as the default.\n\n\n  FC.lang('en', Calendar.englishDefaults);\n  ;\n  ;\n  /* Top toolbar area with buttons and title\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // TODO: rename all header-related things to \"toolbar\"\n\n  function Header(calendar) {\n    var t = this; // exports\n\n    t.render = render;\n    t.removeElement = removeElement;\n    t.updateTitle = updateTitle;\n    t.activateButton = activateButton;\n    t.deactivateButton = deactivateButton;\n    t.disableButton = disableButton;\n    t.enableButton = enableButton;\n    t.getViewsWithButtons = getViewsWithButtons;\n    t.el = null; // mirrors local `el`\n    // locals\n\n    var el;\n    var viewsWithButtons = [];\n    var tm; // can be called repeatedly and will rerender\n\n    function render() {\n      var options = calendar.options;\n      var sections = options.header;\n      tm = options.theme ? 'ui' : 'fc';\n\n      if (sections) {\n        if (!el) {\n          el = this.el = $(\"<div class='fc-toolbar'/>\");\n        } else {\n          el.empty();\n        }\n\n        el.append(renderSection('left')).append(renderSection('right')).append(renderSection('center')).append('<div class=\"fc-clear\"/>');\n      } else {\n        removeElement();\n      }\n    }\n\n    function removeElement() {\n      if (el) {\n        el.remove();\n        el = t.el = null;\n      }\n    }\n\n    function renderSection(position) {\n      var sectionEl = $('<div class=\"fc-' + position + '\"/>');\n      var options = calendar.options;\n      var buttonStr = options.header[position];\n\n      if (buttonStr) {\n        $.each(buttonStr.split(' '), function (i) {\n          var groupChildren = $();\n          var isOnlyButtons = true;\n          var groupEl;\n          $.each(this.split(','), function (j, buttonName) {\n            var customButtonProps;\n            var viewSpec;\n            var buttonClick;\n            var overrideText; // text explicitly set by calendar's constructor options. overcomes icons\n\n            var defaultText;\n            var themeIcon;\n            var normalIcon;\n            var innerHtml;\n            var classes;\n            var button; // the element\n\n            if (buttonName == 'title') {\n              groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\n\n              isOnlyButtons = false;\n            } else {\n              if (customButtonProps = (options.customButtons || {})[buttonName]) {\n                buttonClick = function buttonClick(ev) {\n                  if (customButtonProps.click) {\n                    customButtonProps.click.call(button[0], ev);\n                  }\n                };\n\n                overrideText = ''; // icons will override text\n\n                defaultText = customButtonProps.text;\n              } else if (viewSpec = calendar.getViewSpec(buttonName)) {\n                buttonClick = function buttonClick() {\n                  calendar.changeView(buttonName);\n                };\n\n                viewsWithButtons.push(buttonName);\n                overrideText = viewSpec.buttonTextOverride;\n                defaultText = viewSpec.buttonTextDefault;\n              } else if (calendar[buttonName]) {\n                // a calendar method\n                buttonClick = function buttonClick() {\n                  calendar[buttonName]();\n                };\n\n                overrideText = (calendar.overrides.buttonText || {})[buttonName];\n                defaultText = options.buttonText[buttonName]; // everything else is considered default\n              }\n\n              if (buttonClick) {\n                themeIcon = customButtonProps ? customButtonProps.themeIcon : options.themeButtonIcons[buttonName];\n                normalIcon = customButtonProps ? customButtonProps.icon : options.buttonIcons[buttonName];\n\n                if (overrideText) {\n                  innerHtml = htmlEscape(overrideText);\n                } else if (themeIcon && options.theme) {\n                  innerHtml = \"<span class='ui-icon ui-icon-\" + themeIcon + \"'></span>\";\n                } else if (normalIcon && !options.theme) {\n                  innerHtml = \"<span class='fc-icon fc-icon-\" + normalIcon + \"'></span>\";\n                } else {\n                  innerHtml = htmlEscape(defaultText);\n                }\n\n                classes = ['fc-' + buttonName + '-button', tm + '-button', tm + '-state-default'];\n                button = $( // type=\"button\" so that it doesn't submit a form\n                '<button type=\"button\" class=\"' + classes.join(' ') + '\">' + innerHtml + '</button>').click(function (ev) {\n                  // don't process clicks for disabled buttons\n                  if (!button.hasClass(tm + '-state-disabled')) {\n                    buttonClick(ev); // after the click action, if the button becomes the \"active\" tab, or disabled,\n                    // it should never have a hover class, so remove it now.\n\n                    if (button.hasClass(tm + '-state-active') || button.hasClass(tm + '-state-disabled')) {\n                      button.removeClass(tm + '-state-hover');\n                    }\n                  }\n                }).mousedown(function () {\n                  // the *down* effect (mouse pressed in).\n                  // only on buttons that are not the \"active\" tab, or disabled\n                  button.not('.' + tm + '-state-active').not('.' + tm + '-state-disabled').addClass(tm + '-state-down');\n                }).mouseup(function () {\n                  // undo the *down* effect\n                  button.removeClass(tm + '-state-down');\n                }).hover(function () {\n                  // the *hover* effect.\n                  // only on buttons that are not the \"active\" tab, or disabled\n                  button.not('.' + tm + '-state-active').not('.' + tm + '-state-disabled').addClass(tm + '-state-hover');\n                }, function () {\n                  // undo the *hover* effect\n                  button.removeClass(tm + '-state-hover').removeClass(tm + '-state-down'); // if mouseleave happens before mouseup\n                });\n                groupChildren = groupChildren.add(button);\n              }\n            }\n          });\n\n          if (isOnlyButtons) {\n            groupChildren.first().addClass(tm + '-corner-left').end().last().addClass(tm + '-corner-right').end();\n          }\n\n          if (groupChildren.length > 1) {\n            groupEl = $('<div/>');\n\n            if (isOnlyButtons) {\n              groupEl.addClass('fc-button-group');\n            }\n\n            groupEl.append(groupChildren);\n            sectionEl.append(groupEl);\n          } else {\n            sectionEl.append(groupChildren); // 1 or 0 children\n          }\n        });\n      }\n\n      return sectionEl;\n    }\n\n    function updateTitle(text) {\n      if (el) {\n        el.find('h2').text(text);\n      }\n    }\n\n    function activateButton(buttonName) {\n      if (el) {\n        el.find('.fc-' + buttonName + '-button').addClass(tm + '-state-active');\n      }\n    }\n\n    function deactivateButton(buttonName) {\n      if (el) {\n        el.find('.fc-' + buttonName + '-button').removeClass(tm + '-state-active');\n      }\n    }\n\n    function disableButton(buttonName) {\n      if (el) {\n        el.find('.fc-' + buttonName + '-button').prop('disabled', true).addClass(tm + '-state-disabled');\n      }\n    }\n\n    function enableButton(buttonName) {\n      if (el) {\n        el.find('.fc-' + buttonName + '-button').prop('disabled', false).removeClass(tm + '-state-disabled');\n      }\n    }\n\n    function getViewsWithButtons() {\n      return viewsWithButtons;\n    }\n  }\n\n  ;\n  ;\n  FC.sourceNormalizers = [];\n  FC.sourceFetchers = [];\n  var ajaxDefaults = {\n    dataType: 'json',\n    cache: false\n  };\n  var eventGUID = 1;\n\n  function EventManager() {\n    // assumed to be a calendar\n    var t = this; // exports\n\n    t.isFetchNeeded = isFetchNeeded;\n    t.fetchEvents = fetchEvents;\n    t.fetchEventSources = fetchEventSources;\n    t.getEventSources = getEventSources;\n    t.getEventSourceById = getEventSourceById;\n    t.getEventSourcesByMatchArray = getEventSourcesByMatchArray;\n    t.getEventSourcesByMatch = getEventSourcesByMatch;\n    t.addEventSource = addEventSource;\n    t.removeEventSource = removeEventSource;\n    t.removeEventSources = removeEventSources;\n    t.updateEvent = updateEvent;\n    t.renderEvent = renderEvent;\n    t.removeEvents = removeEvents;\n    t.clientEvents = clientEvents;\n    t.mutateEvent = mutateEvent;\n    t.normalizeEventDates = normalizeEventDates;\n    t.normalizeEventTimes = normalizeEventTimes; // imports\n\n    var reportEvents = t.reportEvents; // locals\n\n    var stickySource = {\n      events: []\n    };\n    var sources = [stickySource];\n    var rangeStart, rangeEnd;\n    var pendingSourceCnt = 0; // outstanding fetch requests, max one per source\n\n    var cache = []; // holds events that have already been expanded\n\n    $.each((t.options.events ? [t.options.events] : []).concat(t.options.eventSources || []), function (i, sourceInput) {\n      var source = buildEventSource(sourceInput);\n\n      if (source) {\n        sources.push(source);\n      }\n    });\n    /* Fetching\n    -----------------------------------------------------------------------------*/\n    // start and end are assumed to be unzoned\n\n    function isFetchNeeded(start, end) {\n      return !rangeStart || // nothing has been fetched yet?\n      start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?\n    }\n\n    function fetchEvents(start, end) {\n      rangeStart = start;\n      rangeEnd = end;\n      fetchEventSources(sources, 'reset');\n    } // expects an array of event source objects (the originals, not copies)\n    // `specialFetchType` is an optimization parameter that affects purging of the event cache.\n\n\n    function fetchEventSources(specificSources, specialFetchType) {\n      var i, source;\n\n      if (specialFetchType === 'reset') {\n        cache = [];\n      } else if (specialFetchType !== 'add') {\n        cache = excludeEventsBySources(cache, specificSources);\n      }\n\n      for (i = 0; i < specificSources.length; i++) {\n        source = specificSources[i]; // already-pending sources have already been accounted for in pendingSourceCnt\n\n        if (source._status !== 'pending') {\n          pendingSourceCnt++;\n        }\n\n        source._fetchId = (source._fetchId || 0) + 1;\n        source._status = 'pending';\n      }\n\n      for (i = 0; i < specificSources.length; i++) {\n        source = specificSources[i];\n        tryFetchEventSource(source, source._fetchId);\n      }\n    } // fetches an event source and processes its result ONLY if it is still the current fetch.\n    // caller is responsible for incrementing pendingSourceCnt first.\n\n\n    function tryFetchEventSource(source, fetchId) {\n      _fetchEventSource(source, function (eventInputs) {\n        var isArraySource = $.isArray(source.events);\n        var i, eventInput;\n        var abstractEvent;\n\n        if ( // is this the source's most recent fetch?\n        // if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt\n        fetchId === source._fetchId && // event source no longer valid?\n        source._status !== 'rejected') {\n          source._status = 'resolved';\n\n          if (eventInputs) {\n            for (i = 0; i < eventInputs.length; i++) {\n              eventInput = eventInputs[i];\n\n              if (isArraySource) {\n                // array sources have already been convert to Event Objects\n                abstractEvent = eventInput;\n              } else {\n                abstractEvent = buildEventFromInput(eventInput, source);\n              }\n\n              if (abstractEvent) {\n                // not false (an invalid event)\n                cache.push.apply(cache, expandEvent(abstractEvent) // add individual expanded events to the cache\n                );\n              }\n            }\n          }\n\n          decrementPendingSourceCnt();\n        }\n      });\n    }\n\n    function rejectEventSource(source) {\n      var wasPending = source._status === 'pending';\n      source._status = 'rejected';\n\n      if (wasPending) {\n        decrementPendingSourceCnt();\n      }\n    }\n\n    function decrementPendingSourceCnt() {\n      pendingSourceCnt--;\n\n      if (!pendingSourceCnt) {\n        reportEvents(cache);\n      }\n    }\n\n    function _fetchEventSource(source, callback) {\n      var i;\n      var fetchers = FC.sourceFetchers;\n      var res;\n\n      for (i = 0; i < fetchers.length; i++) {\n        res = fetchers[i].call(t, // this, the Calendar object\n        source, rangeStart.clone(), rangeEnd.clone(), t.options.timezone, callback);\n\n        if (res === true) {\n          // the fetcher is in charge. made its own async request\n          return;\n        } else if (typeof res == 'object') {\n          // the fetcher returned a new source. process it\n          _fetchEventSource(res, callback);\n\n          return;\n        }\n      }\n\n      var events = source.events;\n\n      if (events) {\n        if ($.isFunction(events)) {\n          t.pushLoading();\n          events.call(t, // this, the Calendar object\n          rangeStart.clone(), rangeEnd.clone(), t.options.timezone, function (events) {\n            callback(events);\n            t.popLoading();\n          });\n        } else if ($.isArray(events)) {\n          callback(events);\n        } else {\n          callback();\n        }\n      } else {\n        var url = source.url;\n\n        if (url) {\n          var _success = source.success;\n          var _error = source.error;\n          var _complete = source.complete; // retrieve any outbound GET/POST $.ajax data from the options\n\n          var customData;\n\n          if ($.isFunction(source.data)) {\n            // supplied as a function that returns a key/value object\n            customData = source.data();\n          } else {\n            // supplied as a straight key/value object\n            customData = source.data;\n          } // use a copy of the custom data so we can modify the parameters\n          // and not affect the passed-in object.\n\n\n          var data = $.extend({}, customData || {});\n          var startParam = firstDefined(source.startParam, t.options.startParam);\n          var endParam = firstDefined(source.endParam, t.options.endParam);\n          var timezoneParam = firstDefined(source.timezoneParam, t.options.timezoneParam);\n\n          if (startParam) {\n            data[startParam] = rangeStart.format();\n          }\n\n          if (endParam) {\n            data[endParam] = rangeEnd.format();\n          }\n\n          if (t.options.timezone && t.options.timezone != 'local') {\n            data[timezoneParam] = t.options.timezone;\n          }\n\n          t.pushLoading();\n          $.ajax($.extend({}, ajaxDefaults, source, {\n            data: data,\n            success: function success(events) {\n              events = events || [];\n              var res = applyAll(_success, this, arguments);\n\n              if ($.isArray(res)) {\n                events = res;\n              }\n\n              callback(events);\n            },\n            error: function error() {\n              applyAll(_error, this, arguments);\n              callback();\n            },\n            complete: function complete() {\n              applyAll(_complete, this, arguments);\n              t.popLoading();\n            }\n          }));\n        } else {\n          callback();\n        }\n      }\n    }\n    /* Sources\n    -----------------------------------------------------------------------------*/\n\n\n    function addEventSource(sourceInput) {\n      var source = buildEventSource(sourceInput);\n\n      if (source) {\n        sources.push(source);\n        fetchEventSources([source], 'add'); // will eventually call reportEvents\n      }\n    }\n\n    function buildEventSource(sourceInput) {\n      // will return undefined if invalid source\n      var normalizers = FC.sourceNormalizers;\n      var source;\n      var i;\n\n      if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {\n        source = {\n          events: sourceInput\n        };\n      } else if (typeof sourceInput === 'string') {\n        source = {\n          url: sourceInput\n        };\n      } else if (typeof sourceInput === 'object') {\n        source = $.extend({}, sourceInput); // shallow copy\n      }\n\n      if (source) {\n        // TODO: repeat code, same code for event classNames\n        if (source.className) {\n          if (typeof source.className === 'string') {\n            source.className = source.className.split(/\\s+/);\n          } // otherwise, assumed to be an array\n\n        } else {\n          source.className = [];\n        } // for array sources, we convert to standard Event Objects up front\n\n\n        if ($.isArray(source.events)) {\n          source.origArray = source.events; // for removeEventSource\n\n          source.events = $.map(source.events, function (eventInput) {\n            return buildEventFromInput(eventInput, source);\n          });\n        }\n\n        for (i = 0; i < normalizers.length; i++) {\n          normalizers[i].call(t, source);\n        }\n\n        return source;\n      }\n    }\n\n    function removeEventSource(matchInput) {\n      removeSpecificEventSources(getEventSourcesByMatch(matchInput));\n    } // if called with no arguments, removes all.\n\n\n    function removeEventSources(matchInputs) {\n      if (matchInputs == null) {\n        removeSpecificEventSources(sources, true); // isAll=true\n      } else {\n        removeSpecificEventSources(getEventSourcesByMatchArray(matchInputs));\n      }\n    }\n\n    function removeSpecificEventSources(targetSources, isAll) {\n      var i; // cancel pending requests\n\n      for (i = 0; i < targetSources.length; i++) {\n        rejectEventSource(targetSources[i]);\n      }\n\n      if (isAll) {\n        // an optimization\n        sources = [];\n        cache = [];\n      } else {\n        // remove from persisted source list\n        sources = $.grep(sources, function (source) {\n          for (i = 0; i < targetSources.length; i++) {\n            if (source === targetSources[i]) {\n              return false; // exclude\n            }\n          }\n\n          return true; // include\n        });\n        cache = excludeEventsBySources(cache, targetSources);\n      }\n\n      reportEvents(cache);\n    }\n\n    function getEventSources() {\n      return sources.slice(1); // returns a shallow copy of sources with stickySource removed\n    }\n\n    function getEventSourceById(id) {\n      return $.grep(sources, function (source) {\n        return source.id && source.id === id;\n      })[0];\n    } // like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)\n\n\n    function getEventSourcesByMatchArray(matchInputs) {\n      // coerce into an array\n      if (!matchInputs) {\n        matchInputs = [];\n      } else if (!$.isArray(matchInputs)) {\n        matchInputs = [matchInputs];\n      }\n\n      var matchingSources = [];\n      var i; // resolve raw inputs to real event source objects\n\n      for (i = 0; i < matchInputs.length; i++) {\n        matchingSources.push.apply( // append\n        matchingSources, getEventSourcesByMatch(matchInputs[i]));\n      }\n\n      return matchingSources;\n    } // matchInput can either by a real event source object, an ID, or the function/URL for the source.\n    // returns an array of matching source objects.\n\n\n    function getEventSourcesByMatch(matchInput) {\n      var i, source; // given an proper event source object\n\n      for (i = 0; i < sources.length; i++) {\n        source = sources[i];\n\n        if (source === matchInput) {\n          return [source];\n        }\n      } // an ID match\n\n\n      source = getEventSourceById(matchInput);\n\n      if (source) {\n        return [source];\n      }\n\n      return $.grep(sources, function (source) {\n        return isSourcesEquivalent(matchInput, source);\n      });\n    }\n\n    function isSourcesEquivalent(source1, source2) {\n      return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);\n    }\n\n    function getSourcePrimitive(source) {\n      return (typeof source === 'object' ? // a normalized event source?\n      source.origArray || source.googleCalendarId || source.url || source.events : // get the primitive\n      null) || source; // the given argument *is* the primitive\n    } // util\n    // returns a filtered array without events that are part of any of the given sources\n\n\n    function excludeEventsBySources(specificEvents, specificSources) {\n      return $.grep(specificEvents, function (event) {\n        for (var i = 0; i < specificSources.length; i++) {\n          if (event.source === specificSources[i]) {\n            return false; // exclude\n          }\n        }\n\n        return true; // keep\n      });\n    }\n    /* Manipulation\n    -----------------------------------------------------------------------------*/\n    // Only ever called from the externally-facing API\n\n\n    function updateEvent(event) {\n      // massage start/end values, even if date string values\n      event.start = t.moment(event.start);\n\n      if (event.end) {\n        event.end = t.moment(event.end);\n      } else {\n        event.end = null;\n      }\n\n      mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization\n\n      reportEvents(cache); // reports event modifications (so we can redraw)\n    } // Returns a hash of misc event properties that should be copied over to related events.\n\n\n    function getMiscEventProps(event) {\n      var props = {};\n      $.each(event, function (name, val) {\n        if (isMiscEventPropName(name)) {\n          if (val !== undefined && isAtomic(val)) {\n            // a defined non-object\n            props[name] = val;\n          }\n        }\n      });\n      return props;\n    } // non-date-related, non-id-related, non-secret\n\n\n    function isMiscEventPropName(name) {\n      return !/^_|^(id|allDay|start|end)$/.test(name);\n    } // returns the expanded events that were created\n\n\n    function renderEvent(eventInput, stick) {\n      var abstractEvent = buildEventFromInput(eventInput);\n      var events;\n      var i, event;\n\n      if (abstractEvent) {\n        // not false (a valid input)\n        events = expandEvent(abstractEvent);\n\n        for (i = 0; i < events.length; i++) {\n          event = events[i];\n\n          if (!event.source) {\n            if (stick) {\n              stickySource.events.push(event);\n              event.source = stickySource;\n            }\n\n            cache.push(event);\n          }\n        }\n\n        reportEvents(cache);\n        return events;\n      }\n\n      return [];\n    }\n\n    function removeEvents(filter) {\n      var eventID;\n      var i;\n\n      if (filter == null) {\n        // null or undefined. remove all events\n        filter = function filter() {\n          return true;\n        }; // will always match\n\n      } else if (!$.isFunction(filter)) {\n        // an event ID\n        eventID = filter + '';\n\n        filter = function filter(event) {\n          return event._id == eventID;\n        };\n      } // Purge event(s) from our local cache\n\n\n      cache = $.grep(cache, filter, true); // inverse=true\n      // Remove events from array sources.\n      // This works because they have been converted to official Event Objects up front.\n      // (and as a result, event._id has been calculated).\n\n      for (i = 0; i < sources.length; i++) {\n        if ($.isArray(sources[i].events)) {\n          sources[i].events = $.grep(sources[i].events, filter, true);\n        }\n      }\n\n      reportEvents(cache);\n    }\n\n    function clientEvents(filter) {\n      if ($.isFunction(filter)) {\n        return $.grep(cache, filter);\n      } else if (filter != null) {\n        // not null, not undefined. an event ID\n        filter += '';\n        return $.grep(cache, function (e) {\n          return e._id == filter;\n        });\n      }\n\n      return cache; // else, return all\n    } // Makes sure all array event sources have their internal event objects\n    // converted over to the Calendar's current timezone.\n\n\n    t.rezoneArrayEventSources = function () {\n      var i;\n      var events;\n      var j;\n\n      for (i = 0; i < sources.length; i++) {\n        events = sources[i].events;\n\n        if ($.isArray(events)) {\n          for (j = 0; j < events.length; j++) {\n            rezoneEventDates(events[j]);\n          }\n        }\n      }\n    };\n\n    function rezoneEventDates(event) {\n      event.start = t.moment(event.start);\n\n      if (event.end) {\n        event.end = t.moment(event.end);\n      }\n\n      backupEventDates(event);\n    }\n    /* Event Normalization\n    -----------------------------------------------------------------------------*/\n    // Given a raw object with key/value properties, returns an \"abstract\" Event object.\n    // An \"abstract\" event is an event that, if recurring, will not have been expanded yet.\n    // Will return `false` when input is invalid.\n    // `source` is optional\n\n\n    function buildEventFromInput(input, source) {\n      var out = {};\n      var start, end;\n      var allDay;\n\n      if (t.options.eventDataTransform) {\n        input = t.options.eventDataTransform(input);\n      }\n\n      if (source && source.eventDataTransform) {\n        input = source.eventDataTransform(input);\n      } // Copy all properties over to the resulting object.\n      // The special-case properties will be copied over afterwards.\n\n\n      $.extend(out, input);\n\n      if (source) {\n        out.source = source;\n      }\n\n      out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');\n\n      if (input.className) {\n        if (typeof input.className == 'string') {\n          out.className = input.className.split(/\\s+/);\n        } else {\n          // assumed to be an array\n          out.className = input.className;\n        }\n      } else {\n        out.className = [];\n      }\n\n      start = input.start || input.date; // \"date\" is an alias for \"start\"\n\n      end = input.end; // parse as a time (Duration) if applicable\n\n      if (isTimeString(start)) {\n        start = moment.duration(start);\n      }\n\n      if (isTimeString(end)) {\n        end = moment.duration(end);\n      }\n\n      if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {\n        // the event is \"abstract\" (recurring) so don't calculate exact start/end dates just yet\n        out.start = start ? moment.duration(start) : null; // will be a Duration or null\n\n        out.end = end ? moment.duration(end) : null; // will be a Duration or null\n\n        out._recurring = true; // our internal marker\n      } else {\n        if (start) {\n          start = t.moment(start);\n\n          if (!start.isValid()) {\n            return false;\n          }\n        }\n\n        if (end) {\n          end = t.moment(end);\n\n          if (!end.isValid()) {\n            end = null; // let defaults take over\n          }\n        }\n\n        allDay = input.allDay;\n\n        if (allDay === undefined) {\n          // still undefined? fallback to default\n          allDay = firstDefined(source ? source.allDayDefault : undefined, t.options.allDayDefault); // still undefined? normalizeEventDates will calculate it\n        }\n\n        assignDatesToEvent(start, end, allDay, out);\n      }\n\n      t.normalizeEvent(out); // hook for external use. a prototype method\n\n      return out;\n    } // Normalizes and assigns the given dates to the given partially-formed event object.\n    // NOTE: mutates the given start/end moments. does not make a copy.\n\n\n    function assignDatesToEvent(start, end, allDay, event) {\n      event.start = start;\n      event.end = end;\n      event.allDay = allDay;\n      normalizeEventDates(event);\n      backupEventDates(event);\n    } // Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.\n    // NOTE: Will modify the given object.\n\n\n    function normalizeEventDates(eventProps) {\n      normalizeEventTimes(eventProps);\n\n      if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {\n        eventProps.end = null;\n      }\n\n      if (!eventProps.end) {\n        if (t.options.forceEventDuration) {\n          eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);\n        } else {\n          eventProps.end = null;\n        }\n      }\n    } // Ensures the allDay property exists and the timeliness of the start/end dates are consistent\n\n\n    function normalizeEventTimes(eventProps) {\n      if (eventProps.allDay == null) {\n        eventProps.allDay = !(eventProps.start.hasTime() || eventProps.end && eventProps.end.hasTime());\n      }\n\n      if (eventProps.allDay) {\n        eventProps.start.stripTime();\n\n        if (eventProps.end) {\n          // TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment\n          eventProps.end.stripTime();\n        }\n      } else {\n        if (!eventProps.start.hasTime()) {\n          eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time\n        }\n\n        if (eventProps.end && !eventProps.end.hasTime()) {\n          eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time\n        }\n      }\n    } // If the given event is a recurring event, break it down into an array of individual instances.\n    // If not a recurring event, return an array with the single original event.\n    // If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.\n    // HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).\n\n\n    function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {\n      var events = [];\n      var dowHash;\n      var dow;\n      var i;\n      var date;\n      var startTime, endTime;\n      var start, end;\n      var event;\n      _rangeStart = _rangeStart || rangeStart;\n      _rangeEnd = _rangeEnd || rangeEnd;\n\n      if (abstractEvent) {\n        if (abstractEvent._recurring) {\n          // make a boolean hash as to whether the event occurs on each day-of-week\n          if (dow = abstractEvent.dow) {\n            dowHash = {};\n\n            for (i = 0; i < dow.length; i++) {\n              dowHash[dow[i]] = true;\n            }\n          } // iterate through every day in the current range\n\n\n          date = _rangeStart.clone().stripTime(); // holds the date of the current day\n\n          while (date.isBefore(_rangeEnd)) {\n            if (!dowHash || dowHash[date.day()]) {\n              // if everyday, or this particular day-of-week\n              startTime = abstractEvent.start; // the stored start and end properties are times (Durations)\n\n              endTime = abstractEvent.end; // \"\n\n              start = date.clone();\n              end = null;\n\n              if (startTime) {\n                start = start.time(startTime);\n              }\n\n              if (endTime) {\n                end = date.clone().time(endTime);\n              }\n\n              event = $.extend({}, abstractEvent); // make a copy of the original\n\n              assignDatesToEvent(start, end, !startTime && !endTime, // allDay?\n              event);\n              events.push(event);\n            }\n\n            date.add(1, 'days');\n          }\n        } else {\n          events.push(abstractEvent); // return the original event. will be a one-item array\n        }\n      }\n\n      return events;\n    }\n    /* Event Modification Math\n    -----------------------------------------------------------------------------------------*/\n    // Modifies an event and all related events by applying the given properties.\n    // Special date-diffing logic is used for manipulation of dates.\n    // If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.\n    // All date comparisons are done against the event's pristine _start and _end dates.\n    // Returns an object with delta information and a function to undo all operations.\n    // For making computations in a granularity greater than day/time, specify largeUnit.\n    // NOTE: The given `newProps` might be mutated for normalization purposes.\n\n\n    function mutateEvent(event, newProps, largeUnit) {\n      var miscProps = {};\n      var oldProps;\n      var clearEnd;\n      var startDelta;\n      var endDelta;\n      var durationDelta;\n      var undoFunc; // diffs the dates in the appropriate way, returning a duration\n\n      function diffDates(date1, date0) {\n        // date1 - date0\n        if (largeUnit) {\n          return diffByUnit(date1, date0, largeUnit);\n        } else if (newProps.allDay) {\n          return diffDay(date1, date0);\n        } else {\n          return diffDayTime(date1, date0);\n        }\n      }\n\n      newProps = newProps || {}; // normalize new date-related properties\n\n      if (!newProps.start) {\n        newProps.start = event.start.clone();\n      }\n\n      if (newProps.end === undefined) {\n        newProps.end = event.end ? event.end.clone() : null;\n      }\n\n      if (newProps.allDay == null) {\n        // is null or undefined?\n        newProps.allDay = event.allDay;\n      }\n\n      normalizeEventDates(newProps); // create normalized versions of the original props to compare against\n      // need a real end value, for diffing\n\n      oldProps = {\n        start: event._start.clone(),\n        end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),\n        allDay: newProps.allDay // normalize the dates in the same regard as the new properties\n\n      };\n      normalizeEventDates(oldProps); // need to clear the end date if explicitly changed to null\n\n      clearEnd = event._end !== null && newProps.end === null; // compute the delta for moving the start date\n\n      startDelta = diffDates(newProps.start, oldProps.start); // compute the delta for moving the end date\n\n      if (newProps.end) {\n        endDelta = diffDates(newProps.end, oldProps.end);\n        durationDelta = endDelta.subtract(startDelta);\n      } else {\n        durationDelta = null;\n      } // gather all non-date-related properties\n\n\n      $.each(newProps, function (name, val) {\n        if (isMiscEventPropName(name)) {\n          if (val !== undefined) {\n            miscProps[name] = val;\n          }\n        }\n      }); // apply the operations to the event and all related events\n\n      undoFunc = mutateEvents(clientEvents(event._id), // get events with this ID\n      clearEnd, newProps.allDay, startDelta, durationDelta, miscProps);\n      return {\n        dateDelta: startDelta,\n        durationDelta: durationDelta,\n        undo: undoFunc\n      };\n    } // Modifies an array of events in the following ways (operations are in order):\n    // - clear the event's `end`\n    // - convert the event to allDay\n    // - add `dateDelta` to the start and end\n    // - add `durationDelta` to the event's duration\n    // - assign `miscProps` to the event\n    //\n    // Returns a function that can be called to undo all the operations.\n    //\n    // TODO: don't use so many closures. possible memory issues when lots of events with same ID.\n    //\n\n\n    function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {\n      var isAmbigTimezone = t.getIsAmbigTimezone();\n      var undoFunctions = []; // normalize zero-length deltas to be null\n\n      if (dateDelta && !dateDelta.valueOf()) {\n        dateDelta = null;\n      }\n\n      if (durationDelta && !durationDelta.valueOf()) {\n        durationDelta = null;\n      }\n\n      $.each(events, function (i, event) {\n        var oldProps;\n        var newProps; // build an object holding all the old values, both date-related and misc.\n        // for the undo function.\n\n        oldProps = {\n          start: event.start.clone(),\n          end: event.end ? event.end.clone() : null,\n          allDay: event.allDay\n        };\n        $.each(miscProps, function (name) {\n          oldProps[name] = event[name];\n        }); // new date-related properties. work off the original date snapshot.\n        // ok to use references because they will be thrown away when backupEventDates is called.\n\n        newProps = {\n          start: event._start,\n          end: event._end,\n          allDay: allDay // normalize the dates in the same regard as the new properties\n\n        };\n        normalizeEventDates(newProps); // massages start/end/allDay\n        // strip or ensure the end date\n\n        if (clearEnd) {\n          newProps.end = null;\n        } else if (durationDelta && !newProps.end) {\n          // the duration translation requires an end date\n          newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);\n        }\n\n        if (dateDelta) {\n          newProps.start.add(dateDelta);\n\n          if (newProps.end) {\n            newProps.end.add(dateDelta);\n          }\n        }\n\n        if (durationDelta) {\n          newProps.end.add(durationDelta); // end already ensured above\n        } // if the dates have changed, and we know it is impossible to recompute the\n        // timezone offsets, strip the zone.\n\n\n        if (isAmbigTimezone && !newProps.allDay && (dateDelta || durationDelta)) {\n          newProps.start.stripZone();\n\n          if (newProps.end) {\n            newProps.end.stripZone();\n          }\n        }\n\n        $.extend(event, miscProps, newProps); // copy over misc props, then date-related props\n\n        backupEventDates(event); // regenerate internal _start/_end/_allDay\n\n        undoFunctions.push(function () {\n          $.extend(event, oldProps);\n          backupEventDates(event); // regenerate internal _start/_end/_allDay\n        });\n      });\n      return function () {\n        for (var i = 0; i < undoFunctions.length; i++) {\n          undoFunctions[i]();\n        }\n      };\n    }\n    /* Business Hours\n    -----------------------------------------------------------------------------------------*/\n\n\n    t.getBusinessHoursEvents = getBusinessHoursEvents; // Returns an array of events as to when the business hours occur in the given view.\n    // Abuse of our event system :(\n\n    function getBusinessHoursEvents(wholeDay) {\n      var optionVal = t.options.businessHours;\n      var defaultVal = {\n        className: 'fc-nonbusiness',\n        start: '09:00',\n        end: '17:00',\n        dow: [1, 2, 3, 4, 5],\n        // monday - friday\n        rendering: 'inverse-background'\n      };\n      var view = t.getView();\n      var eventInput;\n\n      if (optionVal) {\n        // `true` (which means \"use the defaults\") or an override object\n        eventInput = $.extend({}, // copy to a new object in either case\n        defaultVal, typeof optionVal === 'object' ? optionVal : {} // override the defaults\n        );\n      }\n\n      if (eventInput) {\n        // if a whole-day series is requested, clear the start/end times\n        if (wholeDay) {\n          eventInput.start = null;\n          eventInput.end = null;\n        }\n\n        return expandEvent(buildEventFromInput(eventInput), view.start, view.end);\n      }\n\n      return [];\n    }\n    /* Overlapping / Constraining\n    -----------------------------------------------------------------------------------------*/\n\n\n    t.isEventSpanAllowed = isEventSpanAllowed;\n    t.isExternalSpanAllowed = isExternalSpanAllowed;\n    t.isSelectionSpanAllowed = isSelectionSpanAllowed; // Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)\n\n    function isEventSpanAllowed(span, event) {\n      var source = event.source || {};\n      var constraint = firstDefined(event.constraint, source.constraint, t.options.eventConstraint);\n      var overlap = firstDefined(event.overlap, source.overlap, t.options.eventOverlap);\n      return isSpanAllowed(span, constraint, overlap, event);\n    } // Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)\n\n\n    function isExternalSpanAllowed(eventSpan, eventLocation, eventProps) {\n      var eventInput;\n      var event; // note: very similar logic is in View's reportExternalDrop\n\n      if (eventProps) {\n        eventInput = $.extend({}, eventProps, eventLocation);\n        event = expandEvent(buildEventFromInput(eventInput))[0];\n      }\n\n      if (event) {\n        return isEventSpanAllowed(eventSpan, event);\n      } else {\n        // treat it as a selection\n        return isSelectionSpanAllowed(eventSpan);\n      }\n    } // Determines the given span (unzoned start/end with other misc data) can be selected.\n\n\n    function isSelectionSpanAllowed(span) {\n      return isSpanAllowed(span, t.options.selectConstraint, t.options.selectOverlap);\n    } // Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist\n    // according to the constraint/overlap settings.\n    // `event` is not required if checking a selection.\n\n\n    function isSpanAllowed(span, constraint, overlap, event) {\n      var constraintEvents;\n      var anyContainment;\n      var peerEvents;\n      var i, peerEvent;\n      var peerOverlap; // the range must be fully contained by at least one of produced constraint events\n\n      if (constraint != null) {\n        // not treated as an event! intermediate data structure\n        // TODO: use ranges in the future\n        constraintEvents = constraintToEvents(constraint);\n        anyContainment = false;\n\n        for (i = 0; i < constraintEvents.length; i++) {\n          if (eventContainsRange(constraintEvents[i], span)) {\n            anyContainment = true;\n            break;\n          }\n        }\n\n        if (!anyContainment) {\n          return false;\n        }\n      }\n\n      peerEvents = t.getPeerEvents(span, event);\n\n      for (i = 0; i < peerEvents.length; i++) {\n        peerEvent = peerEvents[i]; // there needs to be an actual intersection before disallowing anything\n\n        if (eventIntersectsRange(peerEvent, span)) {\n          // evaluate overlap for the given range and short-circuit if necessary\n          if (overlap === false) {\n            return false;\n          } // if the event's overlap is a test function, pass the peer event in question as the first param\n          else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {\n              return false;\n            } // if we are computing if the given range is allowable for an event, consider the other event's\n          // EventObject-specific or Source-specific `overlap` property\n\n\n          if (event) {\n            peerOverlap = firstDefined(peerEvent.overlap, (peerEvent.source || {}).overlap // we already considered the global `eventOverlap`\n            );\n\n            if (peerOverlap === false) {\n              return false;\n            } // if the peer event's overlap is a test function, pass the subject event as the first param\n\n\n            if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {\n              return false;\n            }\n          }\n        }\n      }\n\n      return true;\n    } // Given an event input from the API, produces an array of event objects. Possible event inputs:\n    // 'businessHours'\n    // An event ID (number or string)\n    // An object with specific start/end dates or a recurring event (like what businessHours accepts)\n\n\n    function constraintToEvents(constraintInput) {\n      if (constraintInput === 'businessHours') {\n        return getBusinessHoursEvents();\n      }\n\n      if (typeof constraintInput === 'object') {\n        return expandEvent(buildEventFromInput(constraintInput));\n      }\n\n      return clientEvents(constraintInput); // probably an ID\n    } // Does the event's date range fully contain the given range?\n    // start/end already assumed to have stripped zones :(\n\n\n    function eventContainsRange(event, range) {\n      var eventStart = event.start.clone().stripZone();\n      var eventEnd = t.getEventEnd(event).stripZone();\n      return range.start >= eventStart && range.end <= eventEnd;\n    } // Does the event's date range intersect with the given range?\n    // start/end already assumed to have stripped zones :(\n\n\n    function eventIntersectsRange(event, range) {\n      var eventStart = event.start.clone().stripZone();\n      var eventEnd = t.getEventEnd(event).stripZone();\n      return range.start < eventEnd && range.end > eventStart;\n    }\n\n    t.getEventCache = function () {\n      return cache;\n    };\n  } // hook for external libs to manipulate event properties upon creation.\n  // should manipulate the event in-place.\n\n\n  Calendar.prototype.normalizeEvent = function (event) {}; // Returns a list of events that the given event should be compared against when being considered for a move to\n  // the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.\n\n\n  Calendar.prototype.getPeerEvents = function (span, event) {\n    var cache = this.getEventCache();\n    var peerEvents = [];\n    var i, otherEvent;\n\n    for (i = 0; i < cache.length; i++) {\n      otherEvent = cache[i];\n\n      if (!event || event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events\n      ) {\n          peerEvents.push(otherEvent);\n        }\n    }\n\n    return peerEvents;\n  }; // updates the \"backup\" properties, which are preserved in order to compute diffs later on.\n\n\n  function backupEventDates(event) {\n    event._allDay = event.allDay;\n    event._start = event.start.clone();\n    event._end = event.end ? event.end.clone() : null;\n  }\n\n  ;\n  ;\n  /* An abstract class for the \"basic\" views, as well as month view. Renders one or more rows of day cells.\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\n  // It is responsible for managing width/height.\n\n  var BasicView = FC.BasicView = View.extend({\n    scroller: null,\n    dayGridClass: DayGrid,\n    // class the dayGrid will be instantiated from (overridable by subclasses)\n    dayGrid: null,\n    // the main subcomponent that does most of the heavy lifting\n    dayNumbersVisible: false,\n    // display day numbers on each day cell?\n    weekNumbersVisible: false,\n    // display week numbers along the side?\n    weekNumberWidth: null,\n    // width of all the week-number cells running down the side\n    headContainerEl: null,\n    // div that hold's the dayGrid's rendered date header\n    headRowEl: null,\n    // the fake row element of the day-of-week header\n    initialize: function initialize() {\n      this.dayGrid = this.instantiateDayGrid();\n      this.scroller = new Scroller({\n        overflowX: 'hidden',\n        overflowY: 'auto'\n      });\n    },\n    // Generates the DayGrid object this view needs. Draws from this.dayGridClass\n    instantiateDayGrid: function instantiateDayGrid() {\n      // generate a subclass on the fly with BasicView-specific behavior\n      // TODO: cache this subclass\n      var subclass = this.dayGridClass.extend(basicDayGridMethods);\n      return new subclass(this);\n    },\n    // Sets the display range and computes all necessary dates\n    setRange: function setRange(range) {\n      View.prototype.setRange.call(this, range); // call the super-method\n\n      this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit); // do before setRange\n\n      this.dayGrid.setRange(range);\n    },\n    // Compute the value to feed into setRange. Overrides superclass.\n    computeRange: function computeRange(date) {\n      var range = View.prototype.computeRange.call(this, date); // get value from the super-method\n      // year and month views should be aligned with weeks. this is already done for week\n\n      if (/year|month/.test(range.intervalUnit)) {\n        range.start.startOf('week');\n        range.start = this.skipHiddenDays(range.start); // make end-of-week if not already\n\n        if (range.end.weekday()) {\n          range.end.add(1, 'week').startOf('week');\n          range.end = this.skipHiddenDays(range.end, -1, true); // exclusively move backwards\n        }\n      }\n\n      return range;\n    },\n    // Renders the view into `this.el`, which should already be assigned\n    renderDates: function renderDates() {\n      this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible\n\n      this.weekNumbersVisible = this.opt('weekNumbers');\n      this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible;\n      this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\n      this.renderHead();\n      this.scroller.render();\n      var dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\n      var dayGridEl = $('<div class=\"fc-day-grid\" />').appendTo(dayGridContainerEl);\n      this.el.find('.fc-body > tr > td').append(dayGridContainerEl);\n      this.dayGrid.setElement(dayGridEl);\n      this.dayGrid.renderDates(this.hasRigidRows());\n    },\n    // render the day-of-week headers\n    renderHead: function renderHead() {\n      this.headContainerEl = this.el.find('.fc-head-container').html(this.dayGrid.renderHeadHtml());\n      this.headRowEl = this.headContainerEl.find('.fc-row');\n    },\n    // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\n    // always completely kill the dayGrid's rendering.\n    unrenderDates: function unrenderDates() {\n      this.dayGrid.unrenderDates();\n      this.dayGrid.removeElement();\n      this.scroller.destroy();\n    },\n    renderBusinessHours: function renderBusinessHours() {\n      this.dayGrid.renderBusinessHours();\n    },\n    unrenderBusinessHours: function unrenderBusinessHours() {\n      this.dayGrid.unrenderBusinessHours();\n    },\n    // Builds the HTML skeleton for the view.\n    // The day-grid component will render inside of a container defined by this HTML.\n    renderSkeletonHtml: function renderSkeletonHtml() {\n      return '' + '<table>' + '<thead class=\"fc-head\">' + '<tr>' + '<td class=\"fc-head-container ' + this.widgetHeaderClass + '\"></td>' + '</tr>' + '</thead>' + '<tbody class=\"fc-body\">' + '<tr>' + '<td class=\"' + this.widgetContentClass + '\"></td>' + '</tr>' + '</tbody>' + '</table>';\n    },\n    // Generates an HTML attribute string for setting the width of the week number column, if it is known\n    weekNumberStyleAttr: function weekNumberStyleAttr() {\n      if (this.weekNumberWidth !== null) {\n        return 'style=\"width:' + this.weekNumberWidth + 'px\"';\n      }\n\n      return '';\n    },\n    // Determines whether each row should have a constant height\n    hasRigidRows: function hasRigidRows() {\n      var eventLimit = this.opt('eventLimit');\n      return eventLimit && typeof eventLimit !== 'number';\n    },\n\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Refreshes the horizontal dimensions of the view\n    updateWidth: function updateWidth() {\n      if (this.weekNumbersVisible) {\n        // Make sure all week number cells running down the side have the same width.\n        // Record the width for cells created later.\n        this.weekNumberWidth = matchCellWidths(this.el.find('.fc-week-number'));\n      }\n    },\n    // Adjusts the vertical dimensions of the view to the specified values\n    setHeight: function setHeight(totalHeight, isAuto) {\n      var eventLimit = this.opt('eventLimit');\n      var scrollerHeight;\n      var scrollbarWidths; // reset all heights to be natural\n\n      this.scroller.clear();\n      uncompensateScroll(this.headRowEl);\n      this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n      // is the event limit a constant level number?\n\n      if (eventLimit && typeof eventLimit === 'number') {\n        this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\n      } // distribute the height to the rows\n      // (totalHeight is a \"recommended\" value if isAuto)\n\n\n      scrollerHeight = this.computeScrollerHeight(totalHeight);\n      this.setGridHeight(scrollerHeight, isAuto); // is the event limit dynamically calculated?\n\n      if (eventLimit && typeof eventLimit !== 'number') {\n        this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\n      }\n\n      if (!isAuto) {\n        // should we force dimensions of the scroll container?\n        this.scroller.setHeight(scrollerHeight);\n        scrollbarWidths = this.scroller.getScrollbarWidths();\n\n        if (scrollbarWidths.left || scrollbarWidths.right) {\n          // using scrollbars?\n          compensateScroll(this.headRowEl, scrollbarWidths); // doing the scrollbar compensation might have created text overflow which created more height. redo\n\n          scrollerHeight = this.computeScrollerHeight(totalHeight);\n          this.scroller.setHeight(scrollerHeight);\n        } // guarantees the same scrollbar widths\n\n\n        this.scroller.lockOverflow(scrollbarWidths);\n      }\n    },\n    // given a desired total height of the view, returns what the height of the scroller should be\n    computeScrollerHeight: function computeScrollerHeight(totalHeight) {\n      return totalHeight - subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n    },\n    // Sets the height of just the DayGrid component in this view\n    setGridHeight: function setGridHeight(height, isAuto) {\n      if (isAuto) {\n        undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\n      } else {\n        distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\n      }\n    },\n\n    /* Scroll\n    ------------------------------------------------------------------------------------------------------------------*/\n    queryScroll: function queryScroll() {\n      return this.scroller.getScrollTop();\n    },\n    setScroll: function setScroll(top) {\n      this.scroller.setScrollTop(top);\n    },\n\n    /* Hit Areas\n    ------------------------------------------------------------------------------------------------------------------*/\n    // forward all hit-related method calls to dayGrid\n    prepareHits: function prepareHits() {\n      this.dayGrid.prepareHits();\n    },\n    releaseHits: function releaseHits() {\n      this.dayGrid.releaseHits();\n    },\n    queryHit: function queryHit(left, top) {\n      return this.dayGrid.queryHit(left, top);\n    },\n    getHitSpan: function getHitSpan(hit) {\n      return this.dayGrid.getHitSpan(hit);\n    },\n    getHitEl: function getHitEl(hit) {\n      return this.dayGrid.getHitEl(hit);\n    },\n\n    /* Events\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders the given events onto the view and populates the segments array\n    renderEvents: function renderEvents(events) {\n      this.dayGrid.renderEvents(events);\n      this.updateHeight(); // must compensate for events that overflow the row\n    },\n    // Retrieves all segment objects that are rendered in the view\n    getEventSegs: function getEventSegs() {\n      return this.dayGrid.getEventSegs();\n    },\n    // Unrenders all event elements and clears internal segment data\n    unrenderEvents: function unrenderEvents() {\n      this.dayGrid.unrenderEvents(); // we DON'T need to call updateHeight() because:\n      // A) a renderEvents() call always happens after this, which will eventually call updateHeight()\n      // B) in IE8, this causes a flash whenever events are rerendered\n    },\n\n    /* Dragging (for both events and external elements)\n    ------------------------------------------------------------------------------------------------------------------*/\n    // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n    renderDrag: function renderDrag(dropLocation, seg) {\n      return this.dayGrid.renderDrag(dropLocation, seg);\n    },\n    unrenderDrag: function unrenderDrag() {\n      this.dayGrid.unrenderDrag();\n    },\n\n    /* Selection\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of a selection\n    renderSelection: function renderSelection(span) {\n      this.dayGrid.renderSelection(span);\n    },\n    // Unrenders a visual indications of a selection\n    unrenderSelection: function unrenderSelection() {\n      this.dayGrid.unrenderSelection();\n    }\n  }); // Methods that will customize the rendering behavior of the BasicView's dayGrid\n\n  var basicDayGridMethods = {\n    // Generates the HTML that will go before the day-of week header cells\n    renderHeadIntroHtml: function renderHeadIntroHtml() {\n      var view = this.view;\n\n      if (view.weekNumbersVisible) {\n        return '' + '<th class=\"fc-week-number ' + view.widgetHeaderClass + '\" ' + view.weekNumberStyleAttr() + '>' + '<span>' + // needed for matchCellWidths\n        htmlEscape(view.opt('weekNumberTitle')) + '</span>' + '</th>';\n      }\n\n      return '';\n    },\n    // Generates the HTML that will go before content-skeleton cells that display the day/week numbers\n    renderNumberIntroHtml: function renderNumberIntroHtml(row) {\n      var view = this.view;\n\n      if (view.weekNumbersVisible) {\n        return '' + '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '>' + '<span>' + // needed for matchCellWidths\n        this.getCellDate(row, 0).format('w') + '</span>' + '</td>';\n      }\n\n      return '';\n    },\n    // Generates the HTML that goes before the day bg cells for each day-row\n    renderBgIntroHtml: function renderBgIntroHtml() {\n      var view = this.view;\n\n      if (view.weekNumbersVisible) {\n        return '<td class=\"fc-week-number ' + view.widgetContentClass + '\" ' + view.weekNumberStyleAttr() + '></td>';\n      }\n\n      return '';\n    },\n    // Generates the HTML that goes before every other type of row generated by DayGrid.\n    // Affects helper-skeleton and highlight-skeleton rows.\n    renderIntroHtml: function renderIntroHtml() {\n      var view = this.view;\n\n      if (view.weekNumbersVisible) {\n        return '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '></td>';\n      }\n\n      return '';\n    }\n  };\n  ;\n  ;\n  /* A month view with day cells running in rows (one-per-week) and columns\n  ----------------------------------------------------------------------------------------------------------------------*/\n\n  var MonthView = FC.MonthView = BasicView.extend({\n    // Produces information about what range to display\n    computeRange: function computeRange(date) {\n      var range = BasicView.prototype.computeRange.call(this, date); // get value from super-method\n\n      var rowCnt; // ensure 6 weeks\n\n      if (this.isFixedWeeks()) {\n        rowCnt = Math.ceil(range.end.diff(range.start, 'weeks', true)); // could be partial weeks due to hiddenDays\n\n        range.end.add(6 - rowCnt, 'weeks');\n      }\n\n      return range;\n    },\n    // Overrides the default BasicView behavior to have special multi-week auto-height logic\n    setGridHeight: function setGridHeight(height, isAuto) {\n      isAuto = isAuto || this.opt('weekMode') === 'variable'; // LEGACY: weekMode is deprecated\n      // if auto, make the height of each row the height that it would be if there were 6 weeks\n\n      if (isAuto) {\n        height *= this.rowCnt / 6;\n      }\n\n      distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\n    },\n    isFixedWeeks: function isFixedWeeks() {\n      var weekMode = this.opt('weekMode'); // LEGACY: weekMode is deprecated\n\n      if (weekMode) {\n        return weekMode === 'fixed'; // if any other type of weekMode, assume NOT fixed\n      }\n\n      return this.opt('fixedWeekCount');\n    }\n  });\n  ;\n  ;\n  fcViews.basic = {\n    'class': BasicView\n  };\n  fcViews.basicDay = {\n    type: 'basic',\n    duration: {\n      days: 1\n    }\n  };\n  fcViews.basicWeek = {\n    type: 'basic',\n    duration: {\n      weeks: 1\n    }\n  };\n  fcViews.month = {\n    'class': MonthView,\n    duration: {\n      months: 1\n    },\n    // important for prev/next\n    defaults: {\n      fixedWeekCount: true\n    }\n  };\n  ;\n  ;\n  /* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\n  ----------------------------------------------------------------------------------------------------------------------*/\n  // Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n  // Responsible for managing width/height.\n\n  var AgendaView = FC.AgendaView = View.extend({\n    scroller: null,\n    timeGridClass: TimeGrid,\n    // class used to instantiate the timeGrid. subclasses can override\n    timeGrid: null,\n    // the main time-grid subcomponent of this view\n    dayGridClass: DayGrid,\n    // class used to instantiate the dayGrid. subclasses can override\n    dayGrid: null,\n    // the \"all-day\" subcomponent. if all-day is turned off, this will be null\n    axisWidth: null,\n    // the width of the time axis running down the side\n    headContainerEl: null,\n    // div that hold's the timeGrid's rendered date header\n    noScrollRowEls: null,\n    // set of fake row elements that must compensate when scroller has scrollbars\n    // when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath\n    bottomRuleEl: null,\n    initialize: function initialize() {\n      this.timeGrid = this.instantiateTimeGrid();\n\n      if (this.opt('allDaySlot')) {\n        // should we display the \"all-day\" area?\n        this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view\n      }\n\n      this.scroller = new Scroller({\n        overflowX: 'hidden',\n        overflowY: 'auto'\n      });\n    },\n    // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\n    instantiateTimeGrid: function instantiateTimeGrid() {\n      var subclass = this.timeGridClass.extend(agendaTimeGridMethods);\n      return new subclass(this);\n    },\n    // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\n    instantiateDayGrid: function instantiateDayGrid() {\n      var subclass = this.dayGridClass.extend(agendaDayGridMethods);\n      return new subclass(this);\n    },\n\n    /* Rendering\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Sets the display range and computes all necessary dates\n    setRange: function setRange(range) {\n      View.prototype.setRange.call(this, range); // call the super-method\n\n      this.timeGrid.setRange(range);\n\n      if (this.dayGrid) {\n        this.dayGrid.setRange(range);\n      }\n    },\n    // Renders the view into `this.el`, which has already been assigned\n    renderDates: function renderDates() {\n      this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\n      this.renderHead();\n      this.scroller.render();\n      var timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\n      var timeGridEl = $('<div class=\"fc-time-grid\" />').appendTo(timeGridWrapEl);\n      this.el.find('.fc-body > tr > td').append(timeGridWrapEl);\n      this.timeGrid.setElement(timeGridEl);\n      this.timeGrid.renderDates(); // the <hr> that sometimes displays under the time-grid\n\n      this.bottomRuleEl = $('<hr class=\"fc-divider ' + this.widgetHeaderClass + '\"/>').appendTo(this.timeGrid.el); // inject it into the time-grid\n\n      if (this.dayGrid) {\n        this.dayGrid.setElement(this.el.find('.fc-day-grid'));\n        this.dayGrid.renderDates(); // have the day-grid extend it's coordinate area over the <hr> dividing the two grids\n\n        this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\n      }\n\n      this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller\n    },\n    // render the day-of-week headers\n    renderHead: function renderHead() {\n      this.headContainerEl = this.el.find('.fc-head-container').html(this.timeGrid.renderHeadHtml());\n    },\n    // Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\n    // always completely kill each grid's rendering.\n    unrenderDates: function unrenderDates() {\n      this.timeGrid.unrenderDates();\n      this.timeGrid.removeElement();\n\n      if (this.dayGrid) {\n        this.dayGrid.unrenderDates();\n        this.dayGrid.removeElement();\n      }\n\n      this.scroller.destroy();\n    },\n    // Builds the HTML skeleton for the view.\n    // The day-grid and time-grid components will render inside containers defined by this HTML.\n    renderSkeletonHtml: function renderSkeletonHtml() {\n      return '' + '<table>' + '<thead class=\"fc-head\">' + '<tr>' + '<td class=\"fc-head-container ' + this.widgetHeaderClass + '\"></td>' + '</tr>' + '</thead>' + '<tbody class=\"fc-body\">' + '<tr>' + '<td class=\"' + this.widgetContentClass + '\">' + (this.dayGrid ? '<div class=\"fc-day-grid\"/>' + '<hr class=\"fc-divider ' + this.widgetHeaderClass + '\"/>' : '') + '</td>' + '</tr>' + '</tbody>' + '</table>';\n    },\n    // Generates an HTML attribute string for setting the width of the axis, if it is known\n    axisStyleAttr: function axisStyleAttr() {\n      if (this.axisWidth !== null) {\n        return 'style=\"width:' + this.axisWidth + 'px\"';\n      }\n\n      return '';\n    },\n\n    /* Business Hours\n    ------------------------------------------------------------------------------------------------------------------*/\n    renderBusinessHours: function renderBusinessHours() {\n      this.timeGrid.renderBusinessHours();\n\n      if (this.dayGrid) {\n        this.dayGrid.renderBusinessHours();\n      }\n    },\n    unrenderBusinessHours: function unrenderBusinessHours() {\n      this.timeGrid.unrenderBusinessHours();\n\n      if (this.dayGrid) {\n        this.dayGrid.unrenderBusinessHours();\n      }\n    },\n\n    /* Now Indicator\n    ------------------------------------------------------------------------------------------------------------------*/\n    getNowIndicatorUnit: function getNowIndicatorUnit() {\n      return this.timeGrid.getNowIndicatorUnit();\n    },\n    renderNowIndicator: function renderNowIndicator(date) {\n      this.timeGrid.renderNowIndicator(date);\n    },\n    unrenderNowIndicator: function unrenderNowIndicator() {\n      this.timeGrid.unrenderNowIndicator();\n    },\n\n    /* Dimensions\n    ------------------------------------------------------------------------------------------------------------------*/\n    updateSize: function updateSize(isResize) {\n      this.timeGrid.updateSize(isResize);\n      View.prototype.updateSize.call(this, isResize); // call the super-method\n    },\n    // Refreshes the horizontal dimensions of the view\n    updateWidth: function updateWidth() {\n      // make all axis cells line up, and record the width so newly created axis cells will have it\n      this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));\n    },\n    // Adjusts the vertical dimensions of the view to the specified values\n    setHeight: function setHeight(totalHeight, isAuto) {\n      var eventLimit;\n      var scrollerHeight;\n      var scrollbarWidths; // reset all dimensions back to the original state\n\n      this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\n\n      this.scroller.clear(); // sets height to 'auto' and clears overflow\n\n      uncompensateScroll(this.noScrollRowEls); // limit number of events in the all-day area\n\n      if (this.dayGrid) {\n        this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n\n        eventLimit = this.opt('eventLimit');\n\n        if (eventLimit && typeof eventLimit !== 'number') {\n          eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\n        }\n\n        if (eventLimit) {\n          this.dayGrid.limitRows(eventLimit);\n        }\n      }\n\n      if (!isAuto) {\n        // should we force dimensions of the scroll container?\n        scrollerHeight = this.computeScrollerHeight(totalHeight);\n        this.scroller.setHeight(scrollerHeight);\n        scrollbarWidths = this.scroller.getScrollbarWidths();\n\n        if (scrollbarWidths.left || scrollbarWidths.right) {\n          // using scrollbars?\n          // make the all-day and header rows lines up\n          compensateScroll(this.noScrollRowEls, scrollbarWidths); // the scrollbar compensation might have changed text flow, which might affect height, so recalculate\n          // and reapply the desired height to the scroller.\n\n          scrollerHeight = this.computeScrollerHeight(totalHeight);\n          this.scroller.setHeight(scrollerHeight);\n        } // guarantees the same scrollbar widths\n\n\n        this.scroller.lockOverflow(scrollbarWidths); // if there's any space below the slats, show the horizontal rule.\n        // this won't cause any new overflow, because lockOverflow already called.\n\n        if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\n          this.bottomRuleEl.show();\n        }\n      }\n    },\n    // given a desired total height of the view, returns what the height of the scroller should be\n    computeScrollerHeight: function computeScrollerHeight(totalHeight) {\n      return totalHeight - subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n    },\n\n    /* Scroll\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Computes the initial pre-configured scroll state prior to allowing the user to change it\n    computeInitialScroll: function computeInitialScroll() {\n      var scrollTime = moment.duration(this.opt('scrollTime'));\n      var top = this.timeGrid.computeTimeTop(scrollTime); // zoom can give weird floating-point values. rather scroll a little bit further\n\n      top = Math.ceil(top);\n\n      if (top) {\n        top++; // to overcome top border that slots beyond the first have. looks better\n      }\n\n      return top;\n    },\n    queryScroll: function queryScroll() {\n      return this.scroller.getScrollTop();\n    },\n    setScroll: function setScroll(top) {\n      this.scroller.setScrollTop(top);\n    },\n\n    /* Hit Areas\n    ------------------------------------------------------------------------------------------------------------------*/\n    // forward all hit-related method calls to the grids (dayGrid might not be defined)\n    prepareHits: function prepareHits() {\n      this.timeGrid.prepareHits();\n\n      if (this.dayGrid) {\n        this.dayGrid.prepareHits();\n      }\n    },\n    releaseHits: function releaseHits() {\n      this.timeGrid.releaseHits();\n\n      if (this.dayGrid) {\n        this.dayGrid.releaseHits();\n      }\n    },\n    queryHit: function queryHit(left, top) {\n      var hit = this.timeGrid.queryHit(left, top);\n\n      if (!hit && this.dayGrid) {\n        hit = this.dayGrid.queryHit(left, top);\n      }\n\n      return hit;\n    },\n    getHitSpan: function getHitSpan(hit) {\n      // TODO: hit.component is set as a hack to identify where the hit came from\n      return hit.component.getHitSpan(hit);\n    },\n    getHitEl: function getHitEl(hit) {\n      // TODO: hit.component is set as a hack to identify where the hit came from\n      return hit.component.getHitEl(hit);\n    },\n\n    /* Events\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders events onto the view and populates the View's segment array\n    renderEvents: function renderEvents(events) {\n      var dayEvents = [];\n      var timedEvents = [];\n      var daySegs = [];\n      var timedSegs;\n      var i; // separate the events into all-day and timed\n\n      for (i = 0; i < events.length; i++) {\n        if (events[i].allDay) {\n          dayEvents.push(events[i]);\n        } else {\n          timedEvents.push(events[i]);\n        }\n      } // render the events in the subcomponents\n\n\n      timedSegs = this.timeGrid.renderEvents(timedEvents);\n\n      if (this.dayGrid) {\n        daySegs = this.dayGrid.renderEvents(dayEvents);\n      } // the all-day area is flexible and might have a lot of events, so shift the height\n\n\n      this.updateHeight();\n    },\n    // Retrieves all segment objects that are rendered in the view\n    getEventSegs: function getEventSegs() {\n      return this.timeGrid.getEventSegs().concat(this.dayGrid ? this.dayGrid.getEventSegs() : []);\n    },\n    // Unrenders all event elements and clears internal segment data\n    unrenderEvents: function unrenderEvents() {\n      // unrender the events in the subcomponents\n      this.timeGrid.unrenderEvents();\n\n      if (this.dayGrid) {\n        this.dayGrid.unrenderEvents();\n      } // we DON'T need to call updateHeight() because:\n      // A) a renderEvents() call always happens after this, which will eventually call updateHeight()\n      // B) in IE8, this causes a flash whenever events are rerendered\n\n    },\n\n    /* Dragging (for events and external elements)\n    ------------------------------------------------------------------------------------------------------------------*/\n    // A returned value of `true` signals that a mock \"helper\" event has been rendered.\n    renderDrag: function renderDrag(dropLocation, seg) {\n      if (dropLocation.start.hasTime()) {\n        return this.timeGrid.renderDrag(dropLocation, seg);\n      } else if (this.dayGrid) {\n        return this.dayGrid.renderDrag(dropLocation, seg);\n      }\n    },\n    unrenderDrag: function unrenderDrag() {\n      this.timeGrid.unrenderDrag();\n\n      if (this.dayGrid) {\n        this.dayGrid.unrenderDrag();\n      }\n    },\n\n    /* Selection\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Renders a visual indication of a selection\n    renderSelection: function renderSelection(span) {\n      if (span.start.hasTime() || span.end.hasTime()) {\n        this.timeGrid.renderSelection(span);\n      } else if (this.dayGrid) {\n        this.dayGrid.renderSelection(span);\n      }\n    },\n    // Unrenders a visual indications of a selection\n    unrenderSelection: function unrenderSelection() {\n      this.timeGrid.unrenderSelection();\n\n      if (this.dayGrid) {\n        this.dayGrid.unrenderSelection();\n      }\n    }\n  }); // Methods that will customize the rendering behavior of the AgendaView's timeGrid\n  // TODO: move into TimeGrid\n\n  var agendaTimeGridMethods = {\n    // Generates the HTML that will go before the day-of week header cells\n    renderHeadIntroHtml: function renderHeadIntroHtml() {\n      var view = this.view;\n      var weekText;\n\n      if (view.opt('weekNumbers')) {\n        weekText = this.start.format(view.opt('smallWeekFormat'));\n        return '' + '<th class=\"fc-axis fc-week-number ' + view.widgetHeaderClass + '\" ' + view.axisStyleAttr() + '>' + '<span>' + // needed for matchCellWidths\n        htmlEscape(weekText) + '</span>' + '</th>';\n      } else {\n        return '<th class=\"fc-axis ' + view.widgetHeaderClass + '\" ' + view.axisStyleAttr() + '></th>';\n      }\n    },\n    // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\n    renderBgIntroHtml: function renderBgIntroHtml() {\n      var view = this.view;\n      return '<td class=\"fc-axis ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '></td>';\n    },\n    // Generates the HTML that goes before all other types of cells.\n    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n    renderIntroHtml: function renderIntroHtml() {\n      var view = this.view;\n      return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n    }\n  }; // Methods that will customize the rendering behavior of the AgendaView's dayGrid\n\n  var agendaDayGridMethods = {\n    // Generates the HTML that goes before the all-day cells\n    renderBgIntroHtml: function renderBgIntroHtml() {\n      var view = this.view;\n      return '' + '<td class=\"fc-axis ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '>' + '<span>' + ( // needed for matchCellWidths\n      view.opt('allDayHtml') || htmlEscape(view.opt('allDayText'))) + '</span>' + '</td>';\n    },\n    // Generates the HTML that goes before all other types of cells.\n    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n    renderIntroHtml: function renderIntroHtml() {\n      var view = this.view;\n      return '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n    }\n  };\n  ;\n  ;\n  var AGENDA_ALL_DAY_EVENT_LIMIT = 5; // potential nice values for the slot-duration and interval-duration\n  // from largest to smallest\n\n  var AGENDA_STOCK_SUB_DURATIONS = [{\n    hours: 1\n  }, {\n    minutes: 30\n  }, {\n    minutes: 15\n  }, {\n    seconds: 30\n  }, {\n    seconds: 15\n  }];\n  fcViews.agenda = {\n    'class': AgendaView,\n    defaults: {\n      allDaySlot: true,\n      allDayText: 'all-day',\n      slotDuration: '00:30:00',\n      minTime: '00:00:00',\n      maxTime: '24:00:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n\n    }\n  };\n  fcViews.agendaDay = {\n    type: 'agenda',\n    duration: {\n      days: 1\n    }\n  };\n  fcViews.agendaWeek = {\n    type: 'agenda',\n    duration: {\n      weeks: 1\n    }\n  };\n  ;\n  ;\n  return FC; // export for Node/CommonJS\n});","map":null,"metadata":{},"sourceType":"script"}