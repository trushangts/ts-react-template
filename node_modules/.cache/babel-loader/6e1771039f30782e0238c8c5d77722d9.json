{"ast":null,"code":"/**\n * @license\n * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the\n * needs of dygraphs.\n *\n * In particular, support for:\n * - grid overlays\n * - error bars\n * - dygraphs attribute system\n */\n\n/**\n * The DygraphCanvasRenderer class does the actual rendering of the chart onto\n * a canvas. It's based on PlotKit.CanvasRenderer.\n * @param {Object} element The canvas to attach to\n * @param {Object} elementContext The 2d context of the canvas (injected so it\n * can be mocked for testing.)\n * @param {Layout} layout The DygraphLayout object for this graph.\n * @constructor\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nvar _dygraphUtils = require('./dygraph-utils');\n\nvar utils = _interopRequireWildcard(_dygraphUtils);\n\nvar _dygraph = require('./dygraph');\n\nvar _dygraph2 = _interopRequireDefault(_dygraph);\n/**\n * @constructor\n *\n * This gets called when there are \"new points\" to chart. This is generally the\n * case when the underlying data being charted has changed. It is _not_ called\n * in the common case that the user has zoomed or is panning the view.\n *\n * The chart canvas has already been created by the Dygraph object. The\n * renderer simply gets a drawing context.\n *\n * @param {Dygraph} dygraph The chart to which this renderer belongs.\n * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.\n * @param {CanvasRenderingContext2D} elementContext The drawing context.\n * @param {DygraphLayout} layout The chart's DygraphLayout object.\n *\n * TODO(danvk): remove the elementContext property.\n */\n\n\nvar DygraphCanvasRenderer = function DygraphCanvasRenderer(dygraph, element, elementContext, layout) {\n  this.dygraph_ = dygraph;\n  this.layout = layout;\n  this.element = element;\n  this.elementContext = elementContext;\n  this.height = dygraph.height_;\n  this.width = dygraph.width_; // --- check whether everything is ok before we return\n\n  if (!utils.isCanvasSupported(this.element)) {\n    throw \"Canvas is not supported.\";\n  } // internal state\n\n\n  this.area = layout.getPlotArea(); // Set up a clipping area for the canvas (and the interaction canvas).\n  // This ensures that we don't overdraw.\n\n  var ctx = this.dygraph_.canvas_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n  ctx = this.dygraph_.hidden_ctx_;\n  ctx.beginPath();\n  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);\n  ctx.clip();\n};\n/**\n * Clears out all chart content and DOM elements.\n * This is called immediately before render() on every frame, including\n * during zooms and pans.\n * @private\n */\n\n\nDygraphCanvasRenderer.prototype.clear = function () {\n  this.elementContext.clearRect(0, 0, this.width, this.height);\n};\n/**\n * This method is responsible for drawing everything on the chart, including\n * lines, error bars, fills and axes.\n * It is called immediately after clear() on every frame, including during pans\n * and zooms.\n * @private\n */\n\n\nDygraphCanvasRenderer.prototype.render = function () {\n  // attaches point.canvas{x,y}\n  this._updatePoints(); // actually draws the chart.\n\n\n  this._renderLineChart();\n};\n/**\n * Returns a predicate to be used with an iterator, which will\n * iterate over points appropriately, depending on whether\n * connectSeparatedPoints is true. When it's false, the predicate will\n * skip over points with missing yVals.\n */\n\n\nDygraphCanvasRenderer._getIteratorPredicate = function (connectSeparatedPoints) {\n  return connectSeparatedPoints ? DygraphCanvasRenderer._predicateThatSkipsEmptyPoints : null;\n};\n\nDygraphCanvasRenderer._predicateThatSkipsEmptyPoints = function (array, idx) {\n  return array[idx].yval !== null;\n};\n/**\n * Draws a line with the styles passed in and calls all the drawPointCallbacks.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\n\n\nDygraphCanvasRenderer._drawStyledLine = function (e, color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize) {\n  var g = e.dygraph; // TODO(konigsberg): Compute attributes outside this method call.\n\n  var stepPlot = g.getBooleanOption(\"stepPlot\", e.setName);\n\n  if (!utils.isArrayLike(strokePattern)) {\n    strokePattern = null;\n  }\n\n  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);\n  var points = e.points;\n  var setName = e.setName;\n  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n  var stroking = strokePattern && strokePattern.length >= 2;\n  var ctx = e.drawingContext;\n  ctx.save();\n\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash(strokePattern);\n  }\n\n  var pointsOnLine = DygraphCanvasRenderer._drawSeries(e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);\n\n  DygraphCanvasRenderer._drawPointsOnLine(e, pointsOnLine, drawPointCallback, color, pointSize);\n\n  if (stroking) {\n    if (ctx.setLineDash) ctx.setLineDash([]);\n  }\n\n  ctx.restore();\n};\n/**\n * This does the actual drawing of lines on the canvas, for just one series.\n * Returns a list of [canvasx, canvasy] pairs for points for which a\n * drawPointCallback should be fired.  These include isolated points, or all\n * points if drawPoints=true.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\n\n\nDygraphCanvasRenderer._drawSeries = function (e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {\n  var prevCanvasX = null;\n  var prevCanvasY = null;\n  var nextCanvasY = null;\n  var isIsolated; // true if this point is isolated (no line segments)\n\n  var point; // the point being processed in the while loop\n\n  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.\n\n  var first = true; // the first cycle through the while loop\n\n  var ctx = e.drawingContext;\n  ctx.beginPath();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = strokeWidth; // NOTE: we break the iterator's encapsulation here for about a 25% speedup.\n\n  var arr = iter.array_;\n  var limit = iter.end_;\n  var predicate = iter.predicate_;\n\n  for (var i = iter.start_; i < limit; i++) {\n    point = arr[i];\n\n    if (predicate) {\n      while (i < limit && !predicate(arr, i)) {\n        i++;\n      }\n\n      if (i == limit) break;\n      point = arr[i];\n    } // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test\n    // doesn't catch Infinity values. Could change this to\n    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?\n\n\n    if (point.canvasy === null || point.canvasy != point.canvasy) {\n      if (stepPlot && prevCanvasX !== null) {\n        // Draw a horizontal line to the start of the missing data\n        ctx.moveTo(prevCanvasX, prevCanvasY);\n        ctx.lineTo(point.canvasx, prevCanvasY);\n      }\n\n      prevCanvasX = prevCanvasY = null;\n    } else {\n      isIsolated = false;\n\n      if (drawGapPoints || prevCanvasX === null) {\n        iter.nextIdx_ = i;\n        iter.next();\n        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;\n        var isNextCanvasYNullOrNaN = nextCanvasY === null || nextCanvasY != nextCanvasY;\n        isIsolated = prevCanvasX === null && isNextCanvasYNullOrNaN;\n\n        if (drawGapPoints) {\n          // Also consider a point to be \"isolated\" if it's adjacent to a\n          // null point, excluding the graph edges.\n          if (!first && prevCanvasX === null || iter.hasNext && isNextCanvasYNullOrNaN) {\n            isIsolated = true;\n          }\n        }\n      }\n\n      if (prevCanvasX !== null) {\n        if (strokeWidth) {\n          if (stepPlot) {\n            ctx.moveTo(prevCanvasX, prevCanvasY);\n            ctx.lineTo(point.canvasx, prevCanvasY);\n          }\n\n          ctx.lineTo(point.canvasx, point.canvasy);\n        }\n      } else {\n        ctx.moveTo(point.canvasx, point.canvasy);\n      }\n\n      if (drawPoints || isIsolated) {\n        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);\n      }\n\n      prevCanvasX = point.canvasx;\n      prevCanvasY = point.canvasy;\n    }\n\n    first = false;\n  }\n\n  ctx.stroke();\n  return pointsOnLine;\n};\n/**\n * This fires the drawPointCallback functions, which draw dots on the points by\n * default. This gets used when the \"drawPoints\" option is set, or when there\n * are isolated points.\n * @param {Object} e The dictionary passed to the plotter function.\n * @private\n */\n\n\nDygraphCanvasRenderer._drawPointsOnLine = function (e, pointsOnLine, drawPointCallback, color, pointSize) {\n  var ctx = e.drawingContext;\n\n  for (var idx = 0; idx < pointsOnLine.length; idx++) {\n    var cb = pointsOnLine[idx];\n    ctx.save();\n    drawPointCallback.call(e.dygraph, e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);\n    ctx.restore();\n  }\n};\n/**\n * Attaches canvas coordinates to the points array.\n * @private\n */\n\n\nDygraphCanvasRenderer.prototype._updatePoints = function () {\n  // Update Points\n  // TODO(danvk): here\n  //\n  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These\n  // transformations can be pushed into the canvas via linear transformation\n  // matrices.\n  // NOTE(danvk): this is trickier than it sounds at first. The transformation\n  // needs to be done before the .moveTo() and .lineTo() calls, but must be\n  // undone before the .stroke() call to ensure that the stroke width is\n  // unaffected.  An alternative is to reduce the stroke width in the\n  // transformed coordinate space, but you can't specify different values for\n  // each dimension (as you can with .scale()). The speedup here is ~12%.\n  var sets = this.layout.points;\n\n  for (var i = sets.length; i--;) {\n    var points = sets[i];\n\n    for (var j = points.length; j--;) {\n      var point = points[j];\n      point.canvasx = this.area.w * point.x + this.area.x;\n      point.canvasy = this.area.h * point.y + this.area.y;\n    }\n  }\n};\n/**\n * Add canvas Actually draw the lines chart, including error bars.\n *\n * This function can only be called if DygraphLayout's points array has been\n * updated with canvas{x,y} attributes, i.e. by\n * DygraphCanvasRenderer._updatePoints.\n *\n * @param {string=} opt_seriesName when specified, only that series will\n *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)\n * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing\n *     context.  However, lines are typically drawn on the object's\n *     elementContext.\n * @private\n */\n\n\nDygraphCanvasRenderer.prototype._renderLineChart = function (opt_seriesName, opt_ctx) {\n  var ctx = opt_ctx || this.elementContext;\n  var i;\n  var sets = this.layout.points;\n  var setNames = this.layout.setNames;\n  var setName;\n  this.colors = this.dygraph_.colorsMap_; // Determine which series have specialized plotters.\n\n  var plotter_attr = this.dygraph_.getOption(\"plotter\");\n  var plotters = plotter_attr;\n\n  if (!utils.isArrayLike(plotters)) {\n    plotters = [plotters];\n  }\n\n  var setPlotters = {}; // series name -> plotter fn.\n\n  for (i = 0; i < setNames.length; i++) {\n    setName = setNames[i];\n    var setPlotter = this.dygraph_.getOption(\"plotter\", setName);\n    if (setPlotter == plotter_attr) continue; // not specialized.\n\n    setPlotters[setName] = setPlotter;\n  }\n\n  for (i = 0; i < plotters.length; i++) {\n    var plotter = plotters[i];\n    var is_last = i == plotters.length - 1;\n\n    for (var j = 0; j < sets.length; j++) {\n      setName = setNames[j];\n      if (opt_seriesName && setName != opt_seriesName) continue;\n      var points = sets[j]; // Only throw in the specialized plotters on the last iteration.\n\n      var p = plotter;\n\n      if (setName in setPlotters) {\n        if (is_last) {\n          p = setPlotters[setName];\n        } else {\n          // Don't use the standard plotters in this case.\n          continue;\n        }\n      }\n\n      var color = this.colors[setName];\n      var strokeWidth = this.dygraph_.getOption(\"strokeWidth\", setName);\n      ctx.save();\n      ctx.strokeStyle = color;\n      ctx.lineWidth = strokeWidth;\n      p({\n        points: points,\n        setName: setName,\n        drawingContext: ctx,\n        color: color,\n        strokeWidth: strokeWidth,\n        dygraph: this.dygraph_,\n        axis: this.dygraph_.axisPropertiesForSeries(setName),\n        plotArea: this.area,\n        seriesIndex: j,\n        seriesCount: sets.length,\n        singleSeriesName: opt_seriesName,\n        allSeriesPoints: sets\n      });\n      ctx.restore();\n    }\n  }\n};\n/**\n * Standard plotters. These may be used by clients via Dygraph.Plotters.\n * See comments there for more details.\n */\n\n\nDygraphCanvasRenderer._Plotters = {\n  linePlotter: function linePlotter(e) {\n    DygraphCanvasRenderer._linePlotter(e);\n  },\n  fillPlotter: function fillPlotter(e) {\n    DygraphCanvasRenderer._fillPlotter(e);\n  },\n  errorPlotter: function errorPlotter(e) {\n    DygraphCanvasRenderer._errorPlotter(e);\n  }\n};\n/**\n * Plotter which draws the central lines for a series.\n * @private\n */\n\nDygraphCanvasRenderer._linePlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var strokeWidth = e.strokeWidth; // TODO(danvk): Check if there's any performance impact of just calling\n  // getOption() inside of _drawStyledLine. Passing in so many parameters makes\n  // this code a bit nasty.\n\n  var borderWidth = g.getNumericOption(\"strokeBorderWidth\", setName);\n  var drawPointCallback = g.getOption(\"drawPointCallback\", setName) || utils.Circles.DEFAULT;\n  var strokePattern = g.getOption(\"strokePattern\", setName);\n  var drawPoints = g.getBooleanOption(\"drawPoints\", setName);\n  var pointSize = g.getNumericOption(\"pointSize\", setName);\n\n  if (borderWidth && strokeWidth) {\n    DygraphCanvasRenderer._drawStyledLine(e, g.getOption(\"strokeBorderColor\", setName), strokeWidth + 2 * borderWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n  }\n\n  DygraphCanvasRenderer._drawStyledLine(e, e.color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize);\n};\n/**\n * Draws the shaded error bars/confidence intervals for each series.\n * This happens before the center lines are drawn, since the center lines\n * need to be drawn on top of the error bars for all series.\n * @private\n */\n\n\nDygraphCanvasRenderer._errorPlotter = function (e) {\n  var g = e.dygraph;\n  var setName = e.setName;\n  var errorBars = g.getBooleanOption(\"errorBars\") || g.getBooleanOption(\"customBars\");\n  if (!errorBars) return;\n  var fillGraph = g.getBooleanOption(\"fillGraph\", setName);\n\n  if (fillGraph) {\n    console.warn(\"Can't use fillGraph option with error bars\");\n  }\n\n  var ctx = e.drawingContext;\n  var color = e.color;\n  var fillAlpha = g.getNumericOption('fillAlpha', setName);\n  var stepPlot = g.getBooleanOption(\"stepPlot\", setName);\n  var points = e.points;\n  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName)));\n  var newYs; // setup graphics context\n\n  var prevX = NaN;\n  var prevY = NaN;\n  var prevYs = [-1, -1]; // should be same color as the lines but only 15% opaque.\n\n  var rgb = utils.toRGB_(color);\n  var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n  ctx.fillStyle = err_color;\n  ctx.beginPath();\n\n  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(x) {\n    return x === null || x === undefined || isNaN(x);\n  };\n\n  while (iter.hasNext) {\n    var point = iter.next();\n\n    if (!stepPlot && isNullUndefinedOrNaN(point.y) || stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY)) {\n      prevX = NaN;\n      continue;\n    }\n\n    newYs = [point.y_bottom, point.y_top];\n\n    if (stepPlot) {\n      prevY = point.y;\n    } // The documentation specifically disallows nulls inside the point arrays,\n    // but in case it happens we should do something sensible.\n\n\n    if (isNaN(newYs[0])) newYs[0] = point.y;\n    if (isNaN(newYs[1])) newYs[1] = point.y;\n    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;\n    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;\n\n    if (!isNaN(prevX)) {\n      if (stepPlot) {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[0]);\n        ctx.lineTo(point.canvasx, prevYs[1]);\n      } else {\n        ctx.moveTo(prevX, prevYs[0]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n        ctx.lineTo(point.canvasx, newYs[1]);\n      }\n\n      ctx.lineTo(prevX, prevYs[1]);\n      ctx.closePath();\n    }\n\n    prevYs = newYs;\n    prevX = point.canvasx;\n  }\n\n  ctx.fill();\n};\n/**\n * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are\n * superfluous. It accumulates all movements which haven't changed the x-value\n * and only applies the two with the most extreme y-values.\n *\n * Calls to lineTo/moveTo must have non-decreasing x-values.\n */\n\n\nDygraphCanvasRenderer._fastCanvasProxy = function (context) {\n  var pendingActions = []; // array of [type, x, y] tuples\n\n  var lastRoundedX = null;\n  var lastFlushedX = null;\n  var LINE_TO = 1,\n      MOVE_TO = 2;\n  var actionCount = 0; // number of moveTos and lineTos passed to context.\n  // Drop superfluous motions\n  // Assumes all pendingActions have the same (rounded) x-value.\n\n  var compressActions = function compressActions(opt_losslessOnly) {\n    if (pendingActions.length <= 1) return; // Lossless compression: drop inconsequential moveTos.\n\n    for (var i = pendingActions.length - 1; i > 0; i--) {\n      var action = pendingActions[i];\n\n      if (action[0] == MOVE_TO) {\n        var prevAction = pendingActions[i - 1];\n\n        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {\n          pendingActions.splice(i, 1);\n        }\n      }\n    } // Lossless compression: ... drop consecutive moveTos ...\n\n\n    for (var i = 0; i < pendingActions.length - 1;)\n    /* incremented internally */\n    {\n      var action = pendingActions[i];\n\n      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {\n        pendingActions.splice(i, 1);\n      } else {\n        i++;\n      }\n    } // Lossy compression: ... drop all but the extreme y-values ...\n\n\n    if (pendingActions.length > 2 && !opt_losslessOnly) {\n      // keep an initial moveTo, but drop all others.\n      var startIdx = 0;\n      if (pendingActions[0][0] == MOVE_TO) startIdx++;\n      var minIdx = null,\n          maxIdx = null;\n\n      for (var i = startIdx; i < pendingActions.length; i++) {\n        var action = pendingActions[i];\n        if (action[0] != LINE_TO) continue;\n\n        if (minIdx === null && maxIdx === null) {\n          minIdx = i;\n          maxIdx = i;\n        } else {\n          var y = action[2];\n\n          if (y < pendingActions[minIdx][2]) {\n            minIdx = i;\n          } else if (y > pendingActions[maxIdx][2]) {\n            maxIdx = i;\n          }\n        }\n      }\n\n      var minAction = pendingActions[minIdx],\n          maxAction = pendingActions[maxIdx];\n      pendingActions.splice(startIdx, pendingActions.length - startIdx);\n\n      if (minIdx < maxIdx) {\n        pendingActions.push(minAction);\n        pendingActions.push(maxAction);\n      } else if (minIdx > maxIdx) {\n        pendingActions.push(maxAction);\n        pendingActions.push(minAction);\n      } else {\n        pendingActions.push(minAction);\n      }\n    }\n  };\n\n  var flushActions = function flushActions(opt_noLossyCompression) {\n    compressActions(opt_noLossyCompression);\n\n    for (var i = 0, len = pendingActions.length; i < len; i++) {\n      var action = pendingActions[i];\n\n      if (action[0] == LINE_TO) {\n        context.lineTo(action[1], action[2]);\n      } else if (action[0] == MOVE_TO) {\n        context.moveTo(action[1], action[2]);\n      }\n    }\n\n    if (pendingActions.length) {\n      lastFlushedX = pendingActions[pendingActions.length - 1][1];\n    }\n\n    actionCount += pendingActions.length;\n    pendingActions = [];\n  };\n\n  var addAction = function addAction(action, x, y) {\n    var rx = Math.round(x);\n\n    if (lastRoundedX === null || rx != lastRoundedX) {\n      // if there are large gaps on the x-axis, it's essential to keep the\n      // first and last point as well.\n      var hasGapOnLeft = lastRoundedX - lastFlushedX > 1,\n          hasGapOnRight = rx - lastRoundedX > 1,\n          hasGap = hasGapOnLeft || hasGapOnRight;\n      flushActions(hasGap);\n      lastRoundedX = rx;\n    }\n\n    pendingActions.push([action, x, y]);\n  };\n\n  return {\n    moveTo: function moveTo(x, y) {\n      addAction(MOVE_TO, x, y);\n    },\n    lineTo: function lineTo(x, y) {\n      addAction(LINE_TO, x, y);\n    },\n    // for major operations like stroke/fill, we skip compression to ensure\n    // that there are no artifacts at the right edge.\n    stroke: function stroke() {\n      flushActions(true);\n      context.stroke();\n    },\n    fill: function fill() {\n      flushActions(true);\n      context.fill();\n    },\n    beginPath: function beginPath() {\n      flushActions(true);\n      context.beginPath();\n    },\n    closePath: function closePath() {\n      flushActions(true);\n      context.closePath();\n    },\n    _count: function _count() {\n      return actionCount;\n    }\n  };\n};\n/**\n * Draws the shaded regions when \"fillGraph\" is set. Not to be confused with\n * error bars.\n *\n * For stacked charts, it's more convenient to handle all the series\n * simultaneously. So this plotter plots all the points on the first series\n * it's asked to draw, then ignores all the other series.\n *\n * @private\n */\n\n\nDygraphCanvasRenderer._fillPlotter = function (e) {\n  // Skip if we're drawing a single series for interactive highlight overlay.\n  if (e.singleSeriesName) return; // We'll handle all the series at once, not one-by-one.\n\n  if (e.seriesIndex !== 0) return;\n  var g = e.dygraph;\n  var setNames = g.getLabels().slice(1); // remove x-axis\n  // getLabels() includes names for invisible series, which are not included in\n  // allSeriesPoints. We remove those to make the two match.\n  // TODO(danvk): provide a simpler way to get this information.\n\n  for (var i = setNames.length; i >= 0; i--) {\n    if (!g.visibility()[i]) setNames.splice(i, 1);\n  }\n\n  var anySeriesFilled = function () {\n    for (var i = 0; i < setNames.length; i++) {\n      if (g.getBooleanOption(\"fillGraph\", setNames[i])) return true;\n    }\n\n    return false;\n  }();\n\n  if (!anySeriesFilled) return;\n  var area = e.plotArea;\n  var sets = e.allSeriesPoints;\n  var setCount = sets.length;\n  var stackedGraph = g.getBooleanOption(\"stackedGraph\");\n  var colors = g.getColors(); // For stacked graphs, track the baseline for filling.\n  //\n  // The filled areas below graph lines are trapezoids with two\n  // vertical edges. The top edge is the line segment being drawn, and\n  // the baseline is the bottom edge. Each baseline corresponds to the\n  // top line segment from the previous stacked line. In the case of\n  // step plots, the trapezoids are rectangles.\n\n  var baseline = {};\n  var currBaseline;\n  var prevStepPlot; // for different line drawing modes (line/step) per series\n  // Helper function to trace a line back along the baseline.\n\n  var traceBackPath = function traceBackPath(ctx, baselineX, baselineY, pathBack) {\n    ctx.lineTo(baselineX, baselineY);\n\n    if (stackedGraph) {\n      for (var i = pathBack.length - 1; i >= 0; i--) {\n        var pt = pathBack[i];\n        ctx.lineTo(pt[0], pt[1]);\n      }\n    }\n  }; // process sets in reverse order (needed for stacked graphs)\n\n\n  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {\n    var ctx = e.drawingContext;\n    var setName = setNames[setIdx];\n    if (!g.getBooleanOption('fillGraph', setName)) continue;\n    var fillAlpha = g.getNumericOption('fillAlpha', setName);\n    var stepPlot = g.getBooleanOption('stepPlot', setName);\n    var color = colors[setIdx];\n    var axis = g.axisPropertiesForSeries(setName);\n    var axisY = 1.0 + axis.minyval * axis.yscale;\n    if (axisY < 0.0) axisY = 0.0;else if (axisY > 1.0) axisY = 1.0;\n    axisY = area.h * axisY + area.y;\n    var points = sets[setIdx];\n    var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption(\"connectSeparatedPoints\", setName))); // setup graphics context\n\n    var prevX = NaN;\n    var prevYs = [-1, -1];\n    var newYs; // should be same color as the lines but only 15% opaque.\n\n    var rgb = utils.toRGB_(color);\n    var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';\n    ctx.fillStyle = err_color;\n    ctx.beginPath();\n    var last_x,\n        is_first = true; // If the point density is high enough, dropping segments on their way to\n    // the canvas justifies the overhead of doing so.\n\n    if (points.length > 2 * g.width_ || _dygraph2['default'].FORCE_FAST_PROXY) {\n      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);\n    } // For filled charts, we draw points from left to right, then back along\n    // the x-axis to complete a shape for filling.\n    // For stacked plots, this \"back path\" is a more complex shape. This array\n    // stores the [x, y] values needed to trace that shape.\n\n\n    var pathBack = []; // TODO(danvk): there are a lot of options at play in this loop.\n    //     The logic would be much clearer if some (e.g. stackGraph and\n    //     stepPlot) were split off into separate sub-plotters.\n\n    var point;\n\n    while (iter.hasNext) {\n      point = iter.next();\n\n      if (!utils.isOK(point.y) && !stepPlot) {\n        traceBackPath(ctx, prevX, prevYs[1], pathBack);\n        pathBack = [];\n        prevX = NaN;\n\n        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {\n          baseline[point.canvasx] = area.h * point.y_stacked + area.y;\n        }\n\n        continue;\n      }\n\n      if (stackedGraph) {\n        if (!is_first && last_x == point.xval) {\n          continue;\n        } else {\n          is_first = false;\n          last_x = point.xval;\n        }\n\n        currBaseline = baseline[point.canvasx];\n        var lastY;\n\n        if (currBaseline === undefined) {\n          lastY = axisY;\n        } else {\n          if (prevStepPlot) {\n            lastY = currBaseline[0];\n          } else {\n            lastY = currBaseline;\n          }\n        }\n\n        newYs = [point.canvasy, lastY];\n\n        if (stepPlot) {\n          // Step plots must keep track of the top and bottom of\n          // the baseline at each point.\n          if (prevYs[0] === -1) {\n            baseline[point.canvasx] = [point.canvasy, axisY];\n          } else {\n            baseline[point.canvasx] = [point.canvasy, prevYs[0]];\n          }\n        } else {\n          baseline[point.canvasx] = point.canvasy;\n        }\n      } else {\n        if (isNaN(point.canvasy) && stepPlot) {\n          newYs = [area.y + area.h, axisY];\n        } else {\n          newYs = [point.canvasy, axisY];\n        }\n      }\n\n      if (!isNaN(prevX)) {\n        // Move to top fill point\n        if (stepPlot) {\n          ctx.lineTo(point.canvasx, prevYs[0]);\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } else {\n          ctx.lineTo(point.canvasx, newYs[0]);\n        } // Record the baseline for the reverse path.\n\n\n        if (stackedGraph) {\n          pathBack.push([prevX, prevYs[1]]);\n\n          if (prevStepPlot && currBaseline) {\n            // Draw to the bottom of the baseline\n            pathBack.push([point.canvasx, currBaseline[1]]);\n          } else {\n            pathBack.push([point.canvasx, newYs[1]]);\n          }\n        }\n      } else {\n        ctx.moveTo(point.canvasx, newYs[1]);\n        ctx.lineTo(point.canvasx, newYs[0]);\n      }\n\n      prevYs = newYs;\n      prevX = point.canvasx;\n    }\n\n    prevStepPlot = stepPlot;\n\n    if (newYs && point) {\n      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);\n      pathBack = [];\n    }\n\n    ctx.fill();\n  }\n};\n\nexports['default'] = DygraphCanvasRenderer;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}