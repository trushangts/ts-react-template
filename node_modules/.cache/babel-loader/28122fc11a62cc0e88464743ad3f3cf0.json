{"ast":null,"code":"/**\n*\n* jquery.sparkline.js\n*\n* v@VERSION@\n* (c) Splunk, Inc\n* Contact: Gareth Watts (gareth@splunk.com)\n* http://omnipotent.net/jquery.sparkline/\n*\n* Generates inline sparkline charts from data supplied either to the method\n* or inline in HTML\n*\n* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag\n* (Firefox 2.0+, Safari, Opera, etc)\n*\n* License: New BSD License\n*\n* Copyright (c) 2012, Splunk Inc.\n* All rights reserved.\n*\n* Redistribution and use in source and binary forms, with or without modification,\n* are permitted provided that the following conditions are met:\n*\n*     * Redistributions of source code must retain the above copyright notice,\n*       this list of conditions and the following disclaimer.\n*     * Redistributions in binary form must reproduce the above copyright notice,\n*       this list of conditions and the following disclaimer in the documentation\n*       and/or other materials provided with the distribution.\n*     * Neither the name of Splunk Inc nor the names of its contributors may\n*       be used to endorse or promote products derived from this software without\n*       specific prior written permission.\n*\n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT\n* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*\n*\n* Usage:\n*  $(selector).sparkline(values, options)\n*\n* If values is undefined or set to 'html' then the data values are read from the specified tag:\n*   <p>Sparkline: <span class=\"sparkline\">1,4,6,6,8,5,3,5</span></p>\n*   $('.sparkline').sparkline();\n* There must be no spaces in the enclosed data set\n*\n* Otherwise values must be an array of numbers or null values\n*    <p>Sparkline: <span id=\"sparkline1\">This text replaced if the browser is compatible</span></p>\n*    $('#sparkline1').sparkline([1,4,6,6,8,5,3,5])\n*    $('#sparkline2').sparkline([1,4,6,null,null,5,3,5])\n*\n* Values can also be specified in an HTML comment, or as a values attribute:\n*    <p>Sparkline: <span class=\"sparkline\"><!--1,4,6,6,8,5,3,5 --></span></p>\n*    <p>Sparkline: <span class=\"sparkline\" values=\"1,4,6,6,8,5,3,5\"></span></p>\n*    $('.sparkline').sparkline();\n*\n* For line charts, x values can also be specified:\n*   <p>Sparkline: <span class=\"sparkline\">1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5</span></p>\n*    $('#sparkline1').sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])\n*\n* By default, options should be passed in as the second argument to the sparkline function:\n*   $('.sparkline').sparkline([1,2,3,4], {type: 'bar'})\n*\n* Options can also be set by passing them on the tag itself.  This feature is disabled by default though\n* as there's a slight performance overhead:\n*   $('.sparkline').sparkline([1,2,3,4], {enableTagOptions: true})\n*   <p>Sparkline: <span class=\"sparkline\" sparkType=\"bar\" sparkBarColor=\"red\">loading</span></p>\n* Prefix all options supplied as tag attribute with \"spark\" (configurable by setting tagOptionsPrefix)\n*\n* Supported options:\n*   lineColor - Color of the line used for the chart\n*   fillColor - Color used to fill in the chart - Set to '' or false for a transparent chart\n*   width - Width of the chart - Defaults to 3 times the number of values in pixels\n*   height - Height of the chart - Defaults to the height of the containing element\n*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied\n*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied\n*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax\n*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied\n*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied\n*   composite - If true then don't erase any existing chart attached to the tag, but draw\n*           another chart over the top - Note that width and height are ignored if an\n*           existing chart is detected.\n*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to 'values'\n*   enableTagOptions - Whether to check tags for sparkline options\n*   tagOptionsPrefix - Prefix used for options supplied as tag attributes - Defaults to 'spark'\n*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a\n*           hidden dom element, avoding a browser reflow\n*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,\n*       making the plugin perform much like it did in 1.x\n*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)\n*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled\n*       defaults to false (highlights enabled)\n*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase\n*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body\n*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied\n*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis\n*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis\n*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip\n*       callback is given arguments of (sparkline, options, fields)\n*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title\n*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)\n*       to control the format of the tooltip\n*   tooltipPrefix - A string to prepend to each field displayed in a tooltip\n*   tooltipSuffix - A string to append to each field displayed in a tooltip\n*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)\n*   tooltipValueLookups - An object or range map to map field values to tooltip strings\n*       (eg. to map -1 to \"Lost\", 0 to \"Draw\", and 1 to \"Win\")\n*   numberFormatter - Optional callback for formatting numbers in tooltips\n*   numberDigitGroupSep - Character to use for group separator in numbers \"1,234\" - Defaults to \",\"\n*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to \".\"\n*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3\n*\n* There are 7 types of sparkline, selected by supplying a \"type\" option of 'line' (default),\n* 'bar', 'tristate', 'bullet', 'discrete', 'pie' or 'box'\n*    line - Line chart.  Options:\n*       spotColor - Set to '' to not end each line in a circular spot\n*       minSpotColor - If set, color of spot at minimum value\n*       maxSpotColor - If set, color of spot at maximum value\n*       spotRadius - Radius in pixels\n*       lineWidth - Width of line in pixels\n*       normalRangeMin\n*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the \"normal\"\n*                      or expected range of values\n*       normalRangeColor - Color to use for the above bar\n*       drawNormalOnTop - Draw the normal range above the chart fill color if true\n*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart\n*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable\n*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable\n*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map\n*\n*   bar - Bar chart.  Options:\n*       barColor - Color of bars for postive values\n*       negBarColor - Color of bars for negative values\n*       zeroColor - Color of bars with zero values\n*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely\n*       barWidth - Width of bars in pixels\n*       colorMap - Optional mappnig of values to colors to override the *BarColor values above\n*                  can be an Array of values to control the color of individual bars or a range map\n*                  to specify colors for individual ranges of values\n*       barSpacing - Gap between bars in pixels\n*       zeroAxis - Centers the y-axis around zero if true\n*\n*   tristate - Charts values of win (>0), lose (<0) or draw (=0)\n*       posBarColor - Color of win values\n*       negBarColor - Color of lose values\n*       zeroBarColor - Color of draw values\n*       barWidth - Width of bars in pixels\n*       barSpacing - Gap between bars in pixels\n*       colorMap - Optional mappnig of values to colors to override the *BarColor values above\n*                  can be an Array of values to control the color of individual bars or a range map\n*                  to specify colors for individual ranges of values\n*\n*   discrete - Options:\n*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height\n*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor\n*       thresholdColor\n*\n*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...\n*       options:\n*       targetColor - The color of the vertical target marker\n*       targetWidth - The width of the target marker in pixels\n*       performanceColor - The color of the performance measure horizontal bar\n*       rangeColors - Colors to use for each qualitative range background color\n*\n*   pie - Pie chart. Options:\n*       sliceColors - An array of colors to use for pie slices\n*       offset - Angle in degrees to offset the first slice - Try -90 or +90\n*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)\n*       borderColor - Color to use for the pie chart border - Defaults to #000\n*\n*   box - Box plot. Options:\n*       raw - Set to true to supply pre-computed plot points as values\n*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier\n*             When set to false you can supply any number of values and the box plot will\n*             be computed for you.  Default is false.\n*       showOutliers - Set to true (default) to display outliers as circles\n*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5\n*       boxLineColor - Outline color of the box\n*       boxFillColor - Fill color for the box\n*       whiskerColor - Line color used for whiskers\n*       outlierLineColor - Outline color of outlier circles\n*       outlierFillColor - Fill color of the outlier circles\n*       spotRadius - Radius of outlier circles\n*       medianColor - Line color of the median line\n*       target - Draw a target cross hair at the supplied value (default undefined)\n*\n*\n*\n*   Examples:\n*   $('#sparkline1').sparkline(myvalues, { lineColor: '#f00', fillColor: false });\n*   $('.barsparks').sparkline('html', { type:'bar', height:'40px', barWidth:5 });\n*   $('#tristate').sparkline([1,1,-1,1,0,0,-1], { type:'tristate' }):\n*   $('#discrete').sparkline([1,3,4,5,5,3,4,5], { type:'discrete' });\n*   $('#bullet').sparkline([10,12,12,9,7], { type:'bullet' });\n*   $('#pie').sparkline([1,1,2], { type:'pie' });\n*/\n\n/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */\n(function (document, Math, undefined) {\n  // performance/minified-size optimization\n  (function (factory) {\n    if (typeof define === 'function' && define.amd) {\n      define(['jquery'], factory);\n    } else if (jQuery && !jQuery.fn.sparkline) {\n      factory(jQuery);\n    }\n  })(function ($) {\n    'use strict';\n\n    var UNSET_OPTION = {},\n        getDefaults,\n        createClass,\n        SPFormat,\n        clipval,\n        quartile,\n        normalizeValue,\n        normalizeValues,\n        remove,\n        isNumber,\n        all,\n        sum,\n        addCSS,\n        ensureArray,\n        formatNumber,\n        RangeMap,\n        MouseHandler,\n        Tooltip,\n        barHighlightMixin,\n        line,\n        bar,\n        tristate,\n        discrete,\n        bullet,\n        pie,\n        box,\n        defaultStyles,\n        initStyles,\n        VShape,\n        VCanvas_base,\n        VCanvas_canvas,\n        VCanvas_vml,\n        pending,\n        shapeCount = 0;\n    /**\n     * Default configuration settings\n     */\n\n    getDefaults = function getDefaults() {\n      return {\n        // Settings common to most/all chart types\n        common: {\n          type: 'line',\n          lineColor: '#00f',\n          fillColor: '#cdf',\n          defaultPixelsPerValue: 3,\n          width: 'auto',\n          height: 'auto',\n          composite: false,\n          tagValuesAttribute: 'values',\n          tagOptionsPrefix: 'spark',\n          enableTagOptions: false,\n          enableHighlight: true,\n          highlightLighten: 1.4,\n          tooltipSkipNull: true,\n          tooltipPrefix: '',\n          tooltipSuffix: '',\n          disableHiddenCheck: false,\n          numberFormatter: false,\n          numberDigitGroupCount: 3,\n          numberDigitGroupSep: ',',\n          numberDecimalMark: '.',\n          disableTooltips: false,\n          disableInteraction: false\n        },\n        // Defaults for line charts\n        line: {\n          spotColor: '#f80',\n          highlightSpotColor: '#5f5',\n          highlightLineColor: '#f22',\n          spotRadius: 1.5,\n          minSpotColor: '#f80',\n          maxSpotColor: '#f80',\n          lineWidth: 1,\n          normalRangeMin: undefined,\n          normalRangeMax: undefined,\n          normalRangeColor: '#ccc',\n          drawNormalOnTop: false,\n          chartRangeMin: undefined,\n          chartRangeMax: undefined,\n          chartRangeMinX: undefined,\n          chartRangeMaxX: undefined,\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{y}}{{suffix}}')\n        },\n        // Defaults for bar charts\n        bar: {\n          barColor: '#3366cc',\n          negBarColor: '#f44',\n          stackedBarColor: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],\n          zeroColor: undefined,\n          nullColor: undefined,\n          zeroAxis: true,\n          barWidth: 4,\n          barSpacing: 1,\n          chartRangeMax: undefined,\n          chartRangeMin: undefined,\n          chartRangeClip: false,\n          colorMap: undefined,\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{prefix}}{{value}}{{suffix}}')\n        },\n        // Defaults for tristate charts\n        tristate: {\n          barWidth: 4,\n          barSpacing: 1,\n          posBarColor: '#6f6',\n          negBarColor: '#f44',\n          zeroBarColor: '#999',\n          colorMap: {},\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value:map}}'),\n          tooltipValueLookups: {\n            map: {\n              '-1': 'Loss',\n              '0': 'Draw',\n              '1': 'Win'\n            }\n          }\n        },\n        // Defaults for discrete charts\n        discrete: {\n          lineHeight: 'auto',\n          thresholdColor: undefined,\n          thresholdValue: 0,\n          chartRangeMax: undefined,\n          chartRangeMin: undefined,\n          chartRangeClip: false,\n          tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')\n        },\n        // Defaults for bullet charts\n        bullet: {\n          targetColor: '#f33',\n          targetWidth: 3,\n          // width of the target bar in pixels\n          performanceColor: '#33f',\n          rangeColors: ['#d3dafe', '#a8b6ff', '#7f94ff'],\n          base: undefined,\n          // set this to a number to change the base start number\n          tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),\n          tooltipValueLookups: {\n            fields: {\n              r: 'Range',\n              p: 'Performance',\n              t: 'Target'\n            }\n          }\n        },\n        // Defaults for pie charts\n        pie: {\n          offset: 0,\n          sliceColors: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],\n          borderWidth: 0,\n          borderColor: '#000',\n          tooltipFormat: new SPFormat('<span style=\"color: {{color}}\">&#9679;</span> {{value}} ({{percent.1}}%)')\n        },\n        // Defaults for box plots\n        box: {\n          raw: false,\n          boxLineColor: '#000',\n          boxFillColor: '#cdf',\n          whiskerColor: '#000',\n          outlierLineColor: '#333',\n          outlierFillColor: '#fff',\n          medianColor: '#f00',\n          showOutliers: true,\n          outlierIQR: 1.5,\n          spotRadius: 1.5,\n          target: undefined,\n          targetColor: '#4a2',\n          chartRangeMax: undefined,\n          chartRangeMin: undefined,\n          tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),\n          tooltipFormatFieldlistKey: 'field',\n          tooltipValueLookups: {\n            fields: {\n              lq: 'Lower Quartile',\n              med: 'Median',\n              uq: 'Upper Quartile',\n              lo: 'Left Outlier',\n              ro: 'Right Outlier',\n              lw: 'Left Whisker',\n              rw: 'Right Whisker'\n            }\n          }\n        }\n      };\n    }; // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname\n\n\n    defaultStyles = '.jqstooltip { ' + 'position: absolute;' + 'left: 0px;' + 'top: 0px;' + 'visibility: hidden;' + 'background: rgb(0, 0, 0) transparent;' + 'background-color: rgba(0,0,0,0.6);' + 'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);' + '-ms-filter: \"progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)\";' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + 'white-space: nowrap;' + 'padding: 5px;' + 'border: 1px solid white;' + 'box-sizing: content-box;' + 'z-index: 10000;' + '}' + '.jqsfield { ' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + '}';\n    /**\n     * Utilities\n     */\n\n    createClass = function createClass()\n    /* [baseclass, [mixin, ...]], definition */\n    {\n      var Class, args;\n\n      Class = function Class() {\n        this.init.apply(this, arguments);\n      };\n\n      if (arguments.length > 1) {\n        if (arguments[0]) {\n          Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);\n          Class._super = arguments[0].prototype;\n        } else {\n          Class.prototype = arguments[arguments.length - 1];\n        }\n\n        if (arguments.length > 2) {\n          args = Array.prototype.slice.call(arguments, 1, -1);\n          args.unshift(Class.prototype);\n          $.extend.apply($, args);\n        }\n      } else {\n        Class.prototype = arguments[0];\n      }\n\n      Class.prototype.cls = Class;\n      return Class;\n    };\n    /**\n     * Wraps a format string for tooltips\n     * {{x}}\n     * {{x.2}\n     * {{x:months}}\n     */\n\n\n    $.SPFormatClass = SPFormat = createClass({\n      fre: /\\{\\{([\\w.]+?)(:(.+?))?\\}\\}/g,\n      precre: /(\\w+)\\.(\\d+)/,\n      init: function init(format, fclass) {\n        this.format = format;\n        this.fclass = fclass;\n      },\n      render: function render(fieldset, lookups, options) {\n        var self = this,\n            fields = fieldset,\n            match,\n            token,\n            lookupkey,\n            fieldvalue,\n            prec;\n        return this.format.replace(this.fre, function () {\n          var lookup;\n          token = arguments[1];\n          lookupkey = arguments[3];\n          match = self.precre.exec(token);\n\n          if (match) {\n            prec = match[2];\n            token = match[1];\n          } else {\n            prec = false;\n          }\n\n          fieldvalue = fields[token];\n\n          if (fieldvalue === undefined) {\n            return '';\n          }\n\n          if (lookupkey && lookups && lookups[lookupkey]) {\n            lookup = lookups[lookupkey];\n\n            if (lookup.get) {\n              // RangeMap\n              return lookups[lookupkey].get(fieldvalue) || fieldvalue;\n            } else {\n              return lookups[lookupkey][fieldvalue] || fieldvalue;\n            }\n          }\n\n          if (isNumber(fieldvalue)) {\n            if (options.get('numberFormatter')) {\n              fieldvalue = options.get('numberFormatter')(fieldvalue);\n            } else {\n              fieldvalue = formatNumber(fieldvalue, prec, options.get('numberDigitGroupCount'), options.get('numberDigitGroupSep'), options.get('numberDecimalMark'));\n            }\n          }\n\n          return fieldvalue;\n        });\n      }\n    }); // convience method to avoid needing the new operator\n\n    $.spformat = function (format, fclass) {\n      return new SPFormat(format, fclass);\n    };\n\n    clipval = function clipval(val, min, max) {\n      if (val < min) {\n        return min;\n      }\n\n      if (val > max) {\n        return max;\n      }\n\n      return val;\n    };\n\n    quartile = function quartile(values, q) {\n      var vl;\n\n      if (q === 2) {\n        vl = Math.floor(values.length / 2);\n        return values.length % 2 ? values[vl] : (values[vl - 1] + values[vl]) / 2;\n      } else {\n        if (values.length % 2) {\n          // odd\n          vl = (values.length * q + q) / 4;\n          return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];\n        } else {\n          //even\n          vl = (values.length * q + 2) / 4;\n          return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];\n        }\n      }\n    };\n\n    normalizeValue = function normalizeValue(val) {\n      var nf;\n\n      switch (val) {\n        case 'undefined':\n          val = undefined;\n          break;\n\n        case 'null':\n          val = null;\n          break;\n\n        case 'true':\n          val = true;\n          break;\n\n        case 'false':\n          val = false;\n          break;\n\n        default:\n          nf = parseFloat(val);\n\n          if (val == nf) {\n            val = nf;\n          }\n\n      }\n\n      return val;\n    };\n\n    normalizeValues = function normalizeValues(vals) {\n      var i,\n          result = [];\n\n      for (i = vals.length; i--;) {\n        result[i] = normalizeValue(vals[i]);\n      }\n\n      return result;\n    };\n\n    remove = function remove(vals, filter) {\n      var i,\n          vl,\n          result = [];\n\n      for (i = 0, vl = vals.length; i < vl; i++) {\n        if (vals[i] !== filter) {\n          result.push(vals[i]);\n        }\n      }\n\n      return result;\n    };\n\n    isNumber = function isNumber(num) {\n      return !isNaN(parseFloat(num)) && isFinite(num);\n    };\n\n    formatNumber = function formatNumber(num, prec, groupsize, groupsep, decsep) {\n      var p, i;\n      num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');\n      p = (p = $.inArray('.', num)) < 0 ? num.length : p;\n\n      if (p < num.length) {\n        num[p] = decsep;\n      }\n\n      for (i = p - groupsize; i > 0; i -= groupsize) {\n        num.splice(i, 0, groupsep);\n      }\n\n      return num.join('');\n    }; // determine if all values of an array match a value\n    // returns true if the array is empty\n\n\n    all = function all(val, arr, ignoreNull) {\n      var i;\n\n      for (i = arr.length; i--;) {\n        if (ignoreNull && arr[i] === null) continue;\n\n        if (arr[i] !== val) {\n          return false;\n        }\n      }\n\n      return true;\n    }; // sums the numeric values in an array, ignoring other values\n\n\n    sum = function sum(vals) {\n      var total = 0,\n          i;\n\n      for (i = vals.length; i--;) {\n        total += typeof vals[i] === 'number' ? vals[i] : 0;\n      }\n\n      return total;\n    };\n\n    ensureArray = function ensureArray(val) {\n      return $.isArray(val) ? val : [val];\n    }; // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/\n\n\n    addCSS = function addCSS(css) {\n      var tag, iefail;\n\n      if (document.createStyleSheet) {\n        try {\n          document.createStyleSheet().cssText = css;\n          return;\n        } catch (e) {\n          // IE <= 9 maxes out at 31 stylesheets; inject into page instead.\n          iefail = true;\n        }\n      }\n\n      tag = document.createElement('style');\n      tag.type = 'text/css';\n      document.getElementsByTagName('head')[0].appendChild(tag);\n\n      if (iefail) {\n        document.styleSheets[document.styleSheets.length - 1].cssText = css;\n      } else {\n        tag[typeof document.body.style.WebkitAppearance == 'string' ?\n        /* webkit only */\n        'innerText' : 'innerHTML'] = css;\n      }\n    }; // Provide a cross-browser interface to a few simple drawing primitives\n\n\n    $.fn.simpledraw = function (width, height, useExisting, interact) {\n      var target, mhandler;\n\n      if (useExisting && (target = this.data('_jqs_vcanvas'))) {\n        return target;\n      }\n\n      if ($.fn.sparkline.canvas === false) {\n        // We've already determined that neither Canvas nor VML are available\n        return false;\n      } else if ($.fn.sparkline.canvas === undefined) {\n        // No function defined yet -- need to see if we support Canvas or VML\n        var el = document.createElement('canvas');\n\n        if (!!(el.getContext && el.getContext('2d'))) {\n          // Canvas is available\n          $.fn.sparkline.canvas = function (width, height, target, interact) {\n            return new VCanvas_canvas(width, height, target, interact);\n          };\n        } else if (document.namespaces && !document.namespaces.v) {\n          // VML is available\n          document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');\n\n          $.fn.sparkline.canvas = function (width, height, target, interact) {\n            return new VCanvas_vml(width, height, target);\n          };\n        } else {\n          // Neither Canvas nor VML are available\n          $.fn.sparkline.canvas = false;\n          return false;\n        }\n      }\n\n      if (width === undefined) {\n        width = $(this).innerWidth();\n      }\n\n      if (height === undefined) {\n        height = $(this).innerHeight();\n      }\n\n      target = $.fn.sparkline.canvas(width, height, this, interact);\n      mhandler = $(this).data('_jqs_mhandler');\n\n      if (mhandler) {\n        mhandler.registerCanvas(target);\n      }\n\n      return target;\n    };\n\n    $.fn.cleardraw = function () {\n      var target = this.data('_jqs_vcanvas');\n\n      if (target) {\n        target.reset();\n      }\n    };\n\n    $.RangeMapClass = RangeMap = createClass({\n      init: function init(map) {\n        var key,\n            range,\n            rangelist = [];\n\n        for (key in map) {\n          if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {\n            range = key.split(':');\n            range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);\n            range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);\n            range[2] = map[key];\n            rangelist.push(range);\n          }\n        }\n\n        this.map = map;\n        this.rangelist = rangelist || false;\n      },\n      get: function get(value) {\n        var rangelist = this.rangelist,\n            i,\n            range,\n            result;\n\n        if ((result = this.map[value]) !== undefined) {\n          return result;\n        }\n\n        if (rangelist) {\n          for (i = rangelist.length; i--;) {\n            range = rangelist[i];\n\n            if (range[0] <= value && range[1] >= value) {\n              return range[2];\n            }\n          }\n        }\n\n        return undefined;\n      }\n    }); // Convenience function\n\n    $.range_map = function (map) {\n      return new RangeMap(map);\n    };\n\n    MouseHandler = createClass({\n      init: function init(el, options) {\n        var $el = $(el);\n        this.$el = $el;\n        this.options = options;\n        this.currentPageX = 0;\n        this.currentPageY = 0;\n        this.el = el;\n        this.splist = [];\n        this.tooltip = null;\n        this.over = false;\n        this.displayTooltips = !options.get('disableTooltips');\n        this.highlightEnabled = !options.get('disableHighlight');\n      },\n      registerSparkline: function registerSparkline(sp) {\n        this.splist.push(sp);\n\n        if (this.over) {\n          this.updateDisplay();\n        }\n      },\n      registerCanvas: function registerCanvas(canvas) {\n        var $canvas = $(canvas.canvas);\n        this.canvas = canvas;\n        this.$canvas = $canvas;\n        $canvas.mouseenter($.proxy(this.mouseenter, this));\n        $canvas.mouseleave($.proxy(this.mouseleave, this));\n        $canvas.click($.proxy(this.mouseclick, this));\n      },\n      reset: function reset(removeTooltip) {\n        this.splist = [];\n\n        if (this.tooltip && removeTooltip) {\n          this.tooltip.remove();\n          this.tooltip = undefined;\n        }\n      },\n      mouseclick: function mouseclick(e) {\n        var clickEvent = $.Event('sparklineClick');\n        clickEvent.originalEvent = e;\n        clickEvent.sparklines = this.splist;\n        this.$el.trigger(clickEvent);\n      },\n      mouseenter: function mouseenter(e) {\n        $(document.body).unbind('mousemove.jqs');\n        $(document.body).bind('mousemove.jqs', $.proxy(this.mousemove, this));\n        this.over = true;\n        this.currentPageX = e.pageX;\n        this.currentPageY = e.pageY;\n        this.currentEl = e.target;\n\n        if (!this.tooltip && this.displayTooltips) {\n          this.tooltip = new Tooltip(this.options);\n          this.tooltip.updatePosition(e.pageX, e.pageY);\n        }\n\n        this.updateDisplay();\n      },\n      mouseleave: function mouseleave() {\n        $(document.body).unbind('mousemove.jqs');\n        var splist = this.splist,\n            spcount = splist.length,\n            needsRefresh = false,\n            sp,\n            i;\n        this.over = false;\n        this.currentEl = null;\n\n        if (this.tooltip) {\n          this.tooltip.remove();\n          this.tooltip = null;\n        }\n\n        for (i = 0; i < spcount; i++) {\n          sp = splist[i];\n\n          if (sp.clearRegionHighlight()) {\n            needsRefresh = true;\n          }\n        }\n\n        if (needsRefresh) {\n          this.canvas.render();\n        }\n      },\n      mousemove: function mousemove(e) {\n        this.currentPageX = e.pageX;\n        this.currentPageY = e.pageY;\n        this.currentEl = e.target;\n\n        if (this.tooltip) {\n          this.tooltip.updatePosition(e.pageX, e.pageY);\n        }\n\n        this.updateDisplay();\n      },\n      updateDisplay: function updateDisplay() {\n        var splist = this.splist,\n            spcount = splist.length,\n            needsRefresh = false,\n            offset = this.$canvas.offset(),\n            localX = this.currentPageX - offset.left,\n            localY = this.currentPageY - offset.top,\n            tooltiphtml,\n            sp,\n            i,\n            result,\n            changeEvent;\n\n        if (!this.over) {\n          return;\n        }\n\n        for (i = 0; i < spcount; i++) {\n          sp = splist[i];\n          result = sp.setRegionHighlight(this.currentEl, localX, localY);\n\n          if (result) {\n            needsRefresh = true;\n          }\n        }\n\n        if (needsRefresh) {\n          changeEvent = $.Event('sparklineRegionChange');\n          changeEvent.sparklines = this.splist;\n          this.$el.trigger(changeEvent);\n\n          if (this.tooltip) {\n            tooltiphtml = '';\n\n            for (i = 0; i < spcount; i++) {\n              sp = splist[i];\n              tooltiphtml += sp.getCurrentRegionTooltip();\n            }\n\n            this.tooltip.setContent(tooltiphtml);\n          }\n\n          if (!this.disableHighlight) {\n            this.canvas.render();\n          }\n        }\n\n        if (result === null) {\n          this.mouseleave();\n        }\n      }\n    });\n    Tooltip = createClass({\n      sizeStyle: 'position: static !important;' + 'display: block !important;' + 'visibility: hidden !important;' + 'float: left !important;',\n      init: function init(options) {\n        var tooltipClassname = options.get('tooltipClassname', 'jqstooltip'),\n            sizetipStyle = this.sizeStyle,\n            offset;\n        this.container = options.get('tooltipContainer') || document.body;\n        this.tooltipOffsetX = options.get('tooltipOffsetX', 10);\n        this.tooltipOffsetY = options.get('tooltipOffsetY', 12); // remove any previous lingering tooltip\n\n        $('#jqssizetip').remove();\n        $('#jqstooltip').remove();\n        this.sizetip = $('<div/>', {\n          id: 'jqssizetip',\n          style: sizetipStyle,\n          'class': tooltipClassname\n        });\n        this.tooltip = $('<div/>', {\n          id: 'jqstooltip',\n          'class': tooltipClassname\n        }).appendTo(this.container); // account for the container's location\n\n        offset = this.tooltip.offset();\n        this.offsetLeft = offset.left;\n        this.offsetTop = offset.top;\n        this.hidden = true;\n        $(window).unbind('resize.jqs scroll.jqs');\n        $(window).bind('resize.jqs scroll.jqs', $.proxy(this.updateWindowDims, this));\n        this.updateWindowDims();\n      },\n      updateWindowDims: function updateWindowDims() {\n        this.scrollTop = $(window).scrollTop();\n        this.scrollLeft = $(window).scrollLeft();\n        this.scrollRight = this.scrollLeft + $(window).width();\n        this.updatePosition();\n      },\n      getSize: function getSize(content) {\n        this.sizetip.html(content).appendTo(this.container);\n        this.width = this.sizetip.width() + 1;\n        this.height = this.sizetip.height();\n        this.sizetip.remove();\n      },\n      setContent: function setContent(content) {\n        if (!content) {\n          this.tooltip.css('visibility', 'hidden');\n          this.hidden = true;\n          return;\n        }\n\n        this.getSize(content);\n        this.tooltip.html(content).css({\n          'width': this.width,\n          'height': this.height,\n          'visibility': 'visible'\n        });\n\n        if (this.hidden) {\n          this.hidden = false;\n          this.updatePosition();\n        }\n      },\n      updatePosition: function updatePosition(x, y) {\n        if (x === undefined) {\n          if (this.mousex === undefined) {\n            return;\n          }\n\n          x = this.mousex - this.offsetLeft;\n          y = this.mousey - this.offsetTop;\n        } else {\n          this.mousex = x = x - this.offsetLeft;\n          this.mousey = y = y - this.offsetTop;\n        }\n\n        if (!this.height || !this.width || this.hidden) {\n          return;\n        }\n\n        y -= this.height + this.tooltipOffsetY;\n        x += this.tooltipOffsetX;\n\n        if (y < this.scrollTop) {\n          y = this.scrollTop;\n        }\n\n        if (x < this.scrollLeft) {\n          x = this.scrollLeft;\n        } else if (x + this.width > this.scrollRight) {\n          x = this.scrollRight - this.width;\n        }\n\n        this.tooltip.css({\n          'left': x,\n          'top': y\n        });\n      },\n      remove: function remove() {\n        this.tooltip.remove();\n        this.sizetip.remove();\n        this.sizetip = this.tooltip = undefined;\n        $(window).unbind('resize.jqs scroll.jqs');\n      }\n    });\n\n    initStyles = function initStyles() {\n      addCSS(defaultStyles);\n    };\n\n    $(initStyles);\n    pending = [];\n\n    $.fn.sparkline = function (userValues, userOptions) {\n      return this.each(function () {\n        var options = new $.fn.sparkline.options(this, userOptions),\n            $this = $(this),\n            render,\n            i;\n\n        render = function render() {\n          var values, width, height, tmp, mhandler, sp, vals;\n\n          if (userValues === 'html' || userValues === undefined) {\n            vals = this.getAttribute(options.get('tagValuesAttribute'));\n\n            if (vals === undefined || vals === null) {\n              vals = $this.html();\n            }\n\n            values = vals.replace(/(^\\s*<!--)|(-->\\s*$)|\\s+/g, '').split(',');\n          } else {\n            values = userValues;\n          }\n\n          width = options.get('width') === 'auto' ? values.length * options.get('defaultPixelsPerValue') : options.get('width');\n\n          if (options.get('height') === 'auto') {\n            if (!options.get('composite') || !$.data(this, '_jqs_vcanvas')) {\n              // must be a better way to get the line height\n              tmp = document.createElement('span');\n              tmp.innerHTML = 'a';\n              $this.html(tmp);\n              height = $(tmp).innerHeight() || $(tmp).height();\n              $(tmp).remove();\n              tmp = null;\n            }\n          } else {\n            height = options.get('height');\n          }\n\n          if (!options.get('disableInteraction')) {\n            mhandler = $.data(this, '_jqs_mhandler');\n\n            if (!mhandler) {\n              mhandler = new MouseHandler(this, options);\n              $.data(this, '_jqs_mhandler', mhandler);\n            } else if (!options.get('composite')) {\n              mhandler.reset();\n            }\n          } else {\n            mhandler = false;\n          }\n\n          if (options.get('composite') && !$.data(this, '_jqs_vcanvas')) {\n            if (!$.data(this, '_jqs_errnotify')) {\n              alert('Attempted to attach a composite sparkline to an element with no existing sparkline');\n              $.data(this, '_jqs_errnotify', true);\n            }\n\n            return;\n          }\n\n          sp = new $.fn.sparkline[options.get('type')](this, values, options, width, height);\n          sp.render();\n\n          if (mhandler) {\n            mhandler.registerSparkline(sp);\n          }\n        };\n\n        if ($(this).html() && !options.get('disableHiddenCheck') && $(this).is(':hidden') || !$(this).parents('body').length) {\n          if (!options.get('composite') && $.data(this, '_jqs_pending')) {\n            // remove any existing references to the element\n            for (i = pending.length; i; i--) {\n              if (pending[i - 1][0] == this) {\n                pending.splice(i - 1, 1);\n              }\n            }\n          }\n\n          pending.push([this, render]);\n          $.data(this, '_jqs_pending', true);\n        } else {\n          render.call(this);\n        }\n      });\n    };\n\n    $.fn.sparkline.defaults = getDefaults();\n\n    $.sparkline_display_visible = function () {\n      var el, i, pl;\n      var done = [];\n\n      for (i = 0, pl = pending.length; i < pl; i++) {\n        el = pending[i][0];\n\n        if ($(el).is(':visible') && !$(el).parents().is(':hidden')) {\n          pending[i][1].call(el);\n          $.data(pending[i][0], '_jqs_pending', false);\n          done.push(i);\n        } else if (!$(el).closest('html').length && !$.data(el, '_jqs_pending')) {\n          // element has been inserted and removed from the DOM\n          // If it was not yet inserted into the dom then the .data request\n          // will return true.\n          // removing from the dom causes the data to be removed.\n          $.data(pending[i][0], '_jqs_pending', false);\n          done.push(i);\n        }\n      }\n\n      for (i = done.length; i; i--) {\n        pending.splice(done[i - 1], 1);\n      }\n    };\n    /**\n     * User option handler\n     */\n\n\n    $.fn.sparkline.options = createClass({\n      init: function init(tag, userOptions) {\n        var extendedOptions, defaults, base, tagOptionType;\n        this.userOptions = userOptions = userOptions || {};\n        this.tag = tag;\n        this.tagValCache = {};\n        defaults = $.fn.sparkline.defaults;\n        base = defaults.common;\n        this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);\n        tagOptionType = this.getTagSetting('type');\n\n        if (tagOptionType === UNSET_OPTION) {\n          extendedOptions = defaults[userOptions.type || base.type];\n        } else {\n          extendedOptions = defaults[tagOptionType];\n        }\n\n        this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);\n      },\n      getTagSetting: function getTagSetting(key) {\n        var prefix = this.tagOptionsPrefix,\n            val,\n            i,\n            pairs,\n            keyval;\n\n        if (prefix === false || prefix === undefined) {\n          return UNSET_OPTION;\n        }\n\n        if (this.tagValCache.hasOwnProperty(key)) {\n          val = this.tagValCache.key;\n        } else {\n          val = this.tag.getAttribute(prefix + key);\n\n          if (val === undefined || val === null) {\n            val = UNSET_OPTION;\n          } else if (val.substr(0, 1) === '[') {\n            val = val.substr(1, val.length - 2).split(',');\n\n            for (i = val.length; i--;) {\n              val[i] = normalizeValue(val[i].replace(/(^\\s*)|(\\s*$)/g, ''));\n            }\n          } else if (val.substr(0, 1) === '{') {\n            pairs = val.substr(1, val.length - 2).split(',');\n            val = {};\n\n            for (i = pairs.length; i--;) {\n              keyval = pairs[i].split(':', 2);\n              val[keyval[0].replace(/(^\\s*)|(\\s*$)/g, '')] = normalizeValue(keyval[1].replace(/(^\\s*)|(\\s*$)/g, ''));\n            }\n          } else {\n            val = normalizeValue(val);\n          }\n\n          this.tagValCache.key = val;\n        }\n\n        return val;\n      },\n      get: function get(key, defaultval) {\n        var tagOption = this.getTagSetting(key),\n            result;\n\n        if (tagOption !== UNSET_OPTION) {\n          return tagOption;\n        }\n\n        return (result = this.mergedOptions[key]) === undefined ? defaultval : result;\n      }\n    });\n    $.fn.sparkline._base = createClass({\n      disabled: false,\n      init: function init(el, values, options, width, height) {\n        this.el = el;\n        this.$el = $(el);\n        this.values = values;\n        this.options = options;\n        this.width = width;\n        this.height = height;\n        this.currentRegion = undefined;\n      },\n\n      /**\n       * Setup the canvas\n       */\n      initTarget: function initTarget() {\n        var interactive = !this.options.get('disableInteraction');\n\n        if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get('composite'), interactive))) {\n          this.disabled = true;\n        } else {\n          this.canvasWidth = this.target.pixelWidth;\n          this.canvasHeight = this.target.pixelHeight;\n        }\n      },\n\n      /**\n       * Actually render the chart to the canvas\n       */\n      render: function render() {\n        if (this.disabled) {\n          this.el.innerHTML = '';\n          return false;\n        }\n\n        return true;\n      },\n\n      /**\n       * Return a region id for a given x/y co-ordinate\n       */\n      getRegion: function getRegion(x, y) {},\n\n      /**\n       * Highlight an item based on the moused-over x,y co-ordinate\n       */\n      setRegionHighlight: function setRegionHighlight(el, x, y) {\n        var currentRegion = this.currentRegion,\n            highlightEnabled = !this.options.get('disableHighlight'),\n            newRegion;\n\n        if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {\n          return null;\n        }\n\n        newRegion = this.getRegion(el, x, y);\n\n        if (currentRegion !== newRegion) {\n          if (currentRegion !== undefined && highlightEnabled) {\n            this.removeHighlight();\n          }\n\n          this.currentRegion = newRegion;\n\n          if (newRegion !== undefined && highlightEnabled) {\n            this.renderHighlight();\n          }\n\n          return true;\n        }\n\n        return false;\n      },\n\n      /**\n       * Reset any currently highlighted item\n       */\n      clearRegionHighlight: function clearRegionHighlight() {\n        if (this.currentRegion !== undefined) {\n          this.removeHighlight();\n          this.currentRegion = undefined;\n          return true;\n        }\n\n        return false;\n      },\n      renderHighlight: function renderHighlight() {\n        this.changeHighlight(true);\n      },\n      removeHighlight: function removeHighlight() {\n        this.changeHighlight(false);\n      },\n      changeHighlight: function changeHighlight(highlight) {},\n\n      /**\n       * Fetch the HTML to display as a tooltip\n       */\n      getCurrentRegionTooltip: function getCurrentRegionTooltip() {\n        var options = this.options,\n            header = '',\n            entries = [],\n            fields,\n            formats,\n            formatlen,\n            fclass,\n            text,\n            i,\n            showFields,\n            showFieldsKey,\n            newFields,\n            fv,\n            formatter,\n            format,\n            fieldlen,\n            j;\n\n        if (this.currentRegion === undefined) {\n          return '';\n        }\n\n        fields = this.getCurrentRegionFields();\n        formatter = options.get('tooltipFormatter');\n\n        if (formatter) {\n          return formatter(this, options, fields);\n        }\n\n        if (options.get('tooltipChartTitle')) {\n          header += '<div class=\"jqs jqstitle\">' + options.get('tooltipChartTitle') + '</div>\\n';\n        }\n\n        formats = this.options.get('tooltipFormat');\n\n        if (!formats) {\n          return '';\n        }\n\n        if (!$.isArray(formats)) {\n          formats = [formats];\n        }\n\n        if (!$.isArray(fields)) {\n          fields = [fields];\n        }\n\n        showFields = this.options.get('tooltipFormatFieldlist');\n        showFieldsKey = this.options.get('tooltipFormatFieldlistKey');\n\n        if (showFields && showFieldsKey) {\n          // user-selected ordering of fields\n          newFields = [];\n\n          for (i = fields.length; i--;) {\n            fv = fields[i][showFieldsKey];\n\n            if ((j = $.inArray(fv, showFields)) != -1) {\n              newFields[j] = fields[i];\n            }\n          }\n\n          fields = newFields;\n        }\n\n        formatlen = formats.length;\n        fieldlen = fields.length;\n\n        for (i = 0; i < formatlen; i++) {\n          format = formats[i];\n\n          if (typeof format === 'string') {\n            format = new SPFormat(format);\n          }\n\n          fclass = format.fclass || 'jqsfield';\n\n          for (j = 0; j < fieldlen; j++) {\n            if (!fields[j].isNull || !options.get('tooltipSkipNull')) {\n              $.extend(fields[j], {\n                prefix: options.get('tooltipPrefix'),\n                suffix: options.get('tooltipSuffix')\n              });\n              text = format.render(fields[j], options.get('tooltipValueLookups'), options);\n              entries.push('<div class=\"' + fclass + '\">' + text + '</div>');\n            }\n          }\n        }\n\n        if (entries.length) {\n          return header + entries.join('\\n');\n        }\n\n        return '';\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {},\n      calcHighlightColor: function calcHighlightColor(color, options) {\n        var highlightColor = options.get('highlightColor'),\n            lighten = options.get('highlightLighten'),\n            parse,\n            mult,\n            rgbnew,\n            i;\n\n        if (highlightColor) {\n          return highlightColor;\n        }\n\n        if (lighten) {\n          // extract RGB values\n          parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);\n\n          if (parse) {\n            rgbnew = [];\n            mult = color.length === 4 ? 16 : 1;\n\n            for (i = 0; i < 3; i++) {\n              rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);\n            }\n\n            return 'rgb(' + rgbnew.join(',') + ')';\n          }\n        }\n\n        return color;\n      }\n    });\n    barHighlightMixin = {\n      changeHighlight: function changeHighlight(highlight) {\n        var currentRegion = this.currentRegion,\n            target = this.target,\n            shapeids = this.regionShapes[currentRegion],\n            newShapes; // will be null if the region value was null\n\n        if (shapeids) {\n          newShapes = this.renderRegion(currentRegion, highlight);\n\n          if ($.isArray(newShapes) || $.isArray(shapeids)) {\n            target.replaceWithShapes(shapeids, newShapes);\n            this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {\n              return newShape.id;\n            });\n          } else {\n            target.replaceWithShape(shapeids, newShapes);\n            this.regionShapes[currentRegion] = newShapes.id;\n          }\n        }\n      },\n      render: function render() {\n        var values = this.values,\n            target = this.target,\n            regionShapes = this.regionShapes,\n            shapes,\n            ids,\n            i,\n            j;\n\n        if (!this.cls._super.render.call(this)) {\n          return;\n        }\n\n        for (i = values.length; i--;) {\n          shapes = this.renderRegion(i);\n\n          if (shapes) {\n            if ($.isArray(shapes)) {\n              ids = [];\n\n              for (j = shapes.length; j--;) {\n                shapes[j].append();\n                ids.push(shapes[j].id);\n              }\n\n              regionShapes[i] = ids;\n            } else {\n              shapes.append();\n              regionShapes[i] = shapes.id; // store just the shapeid\n            }\n          } else {\n            // null value\n            regionShapes[i] = null;\n          }\n        }\n\n        target.render();\n      }\n    };\n    /**\n     * Line charts\n     */\n\n    $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {\n      type: 'line',\n      init: function init(el, values, options, width, height) {\n        line._super.init.call(this, el, values, options, width, height);\n\n        this.vertices = [];\n        this.regionMap = [];\n        this.xvalues = [];\n        this.yvalues = [];\n        this.yminmax = [];\n        this.hightlightSpotId = null;\n        this.lastShapeId = null;\n        this.initTarget();\n      },\n      getRegion: function getRegion(el, x, y) {\n        var i,\n            regionMap = this.regionMap; // maps regions to value positions\n\n        for (i = regionMap.length; i--;) {\n          if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {\n            return regionMap[i][2];\n          }\n        }\n\n        return undefined;\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.yvalues[currentRegion] === null,\n          x: this.xvalues[currentRegion],\n          y: this.yvalues[currentRegion],\n          color: this.options.get('lineColor'),\n          fillColor: this.options.get('fillColor'),\n          offset: currentRegion\n        };\n      },\n      renderHighlight: function renderHighlight() {\n        var currentRegion = this.currentRegion,\n            target = this.target,\n            vertex = this.vertices[currentRegion],\n            options = this.options,\n            spotRadius = options.get('spotRadius'),\n            highlightSpotColor = options.get('highlightSpotColor'),\n            highlightLineColor = options.get('highlightLineColor'),\n            highlightSpot,\n            highlightLine;\n\n        if (!vertex) {\n          return;\n        }\n\n        if (spotRadius && highlightSpotColor) {\n          highlightSpot = target.drawCircle(vertex[0], vertex[1], spotRadius, undefined, highlightSpotColor);\n          this.highlightSpotId = highlightSpot.id;\n          target.insertAfterShape(this.lastShapeId, highlightSpot);\n        }\n\n        if (highlightLineColor) {\n          highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0], this.canvasTop + this.canvasHeight, highlightLineColor);\n          this.highlightLineId = highlightLine.id;\n          target.insertAfterShape(this.lastShapeId, highlightLine);\n        }\n      },\n      removeHighlight: function removeHighlight() {\n        var target = this.target;\n\n        if (this.highlightSpotId) {\n          target.removeShapeId(this.highlightSpotId);\n          this.highlightSpotId = null;\n        }\n\n        if (this.highlightLineId) {\n          target.removeShapeId(this.highlightLineId);\n          this.highlightLineId = null;\n        }\n      },\n      scanValues: function scanValues() {\n        var values = this.values,\n            valcount = values.length,\n            xvalues = this.xvalues,\n            yvalues = this.yvalues,\n            yminmax = this.yminmax,\n            i,\n            val,\n            isStr,\n            isArray,\n            sp;\n\n        for (i = 0; i < valcount; i++) {\n          val = values[i];\n          isStr = typeof values[i] === 'string';\n          isArray = typeof values[i] === 'object' && values[i] instanceof Array;\n          sp = isStr && values[i].split(':');\n\n          if (isStr && sp.length === 2) {\n            // x:y\n            xvalues.push(Number(sp[0]));\n            yvalues.push(Number(sp[1]));\n            yminmax.push(Number(sp[1]));\n          } else if (isArray) {\n            xvalues.push(val[0]);\n            yvalues.push(val[1]);\n            yminmax.push(val[1]);\n          } else {\n            xvalues.push(i);\n\n            if (values[i] === null || values[i] === 'null') {\n              yvalues.push(null);\n            } else {\n              yvalues.push(Number(val));\n              yminmax.push(Number(val));\n            }\n          }\n        }\n\n        if (this.options.get('xvalues')) {\n          xvalues = this.options.get('xvalues');\n        }\n\n        this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);\n        this.miny = this.minyorg = Math.min.apply(Math, yminmax);\n        this.maxx = Math.max.apply(Math, xvalues);\n        this.minx = Math.min.apply(Math, xvalues);\n        this.xvalues = xvalues;\n        this.yvalues = yvalues;\n        this.yminmax = yminmax;\n      },\n      processRangeOptions: function processRangeOptions() {\n        var options = this.options,\n            normalRangeMin = options.get('normalRangeMin'),\n            normalRangeMax = options.get('normalRangeMax');\n\n        if (normalRangeMin !== undefined) {\n          if (normalRangeMin < this.miny) {\n            this.miny = normalRangeMin;\n          }\n\n          if (normalRangeMax > this.maxy) {\n            this.maxy = normalRangeMax;\n          }\n        }\n\n        if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {\n          this.miny = options.get('chartRangeMin');\n        }\n\n        if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {\n          this.maxy = options.get('chartRangeMax');\n        }\n\n        if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {\n          this.minx = options.get('chartRangeMinX');\n        }\n\n        if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {\n          this.maxx = options.get('chartRangeMaxX');\n        }\n      },\n      drawNormalRange: function drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {\n        var normalRangeMin = this.options.get('normalRangeMin'),\n            normalRangeMax = this.options.get('normalRangeMax'),\n            ytop = canvasTop + Math.round(canvasHeight - canvasHeight * ((normalRangeMax - this.miny) / rangey)),\n            height = Math.round(canvasHeight * (normalRangeMax - normalRangeMin) / rangey);\n        this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();\n      },\n      render: function render() {\n        var options = this.options,\n            target = this.target,\n            canvasWidth = this.canvasWidth,\n            canvasHeight = this.canvasHeight,\n            vertices = this.vertices,\n            spotRadius = options.get('spotRadius'),\n            regionMap = this.regionMap,\n            rangex,\n            rangey,\n            yvallast,\n            canvasTop,\n            canvasLeft,\n            vertex,\n            path,\n            paths,\n            x,\n            y,\n            xnext,\n            xpos,\n            xposnext,\n            last,\n            next,\n            yvalcount,\n            lineShapes,\n            fillShapes,\n            plen,\n            valueSpots,\n            hlSpotsEnabled,\n            color,\n            xvalues,\n            yvalues,\n            i;\n\n        if (!line._super.render.call(this)) {\n          return;\n        }\n\n        this.scanValues();\n        this.processRangeOptions();\n        xvalues = this.xvalues;\n        yvalues = this.yvalues;\n\n        if (!this.yminmax.length || this.yvalues.length < 2) {\n          // empty or all null valuess\n          return;\n        }\n\n        canvasTop = canvasLeft = 0;\n        rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;\n        rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;\n        yvallast = this.yvalues.length - 1;\n\n        if (spotRadius && (canvasWidth < spotRadius * 4 || canvasHeight < spotRadius * 4)) {\n          spotRadius = 0;\n        }\n\n        if (spotRadius) {\n          // adjust the canvas size as required so that spots will fit\n          hlSpotsEnabled = options.get('highlightSpotColor') && !options.get('disableInteraction');\n\n          if (hlSpotsEnabled || options.get('minSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.miny) {\n            canvasHeight -= Math.ceil(spotRadius);\n          }\n\n          if (hlSpotsEnabled || options.get('maxSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.maxy) {\n            canvasHeight -= Math.ceil(spotRadius);\n            canvasTop += Math.ceil(spotRadius);\n          }\n\n          if (hlSpotsEnabled || (options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy)) {\n            canvasLeft += Math.ceil(spotRadius);\n            canvasWidth -= Math.ceil(spotRadius);\n          }\n\n          if (hlSpotsEnabled || options.get('spotColor') || options.get('minSpotColor') || options.get('maxSpotColor') && (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy)) {\n            canvasWidth -= Math.ceil(spotRadius);\n          }\n        }\n\n        canvasHeight--;\n\n        if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {\n          this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n        }\n\n        path = [];\n        paths = [path];\n        last = next = null;\n        yvalcount = yvalues.length;\n\n        for (i = 0; i < yvalcount; i++) {\n          x = xvalues[i];\n          xnext = xvalues[i + 1];\n          y = yvalues[i];\n          xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));\n          xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;\n          next = xpos + (xposnext - xpos) / 2;\n          regionMap[i] = [last || 0, next, i];\n          last = next;\n\n          if (y === null) {\n            if (i) {\n              if (yvalues[i - 1] !== null) {\n                path = [];\n                paths.push(path);\n              }\n\n              vertices.push(null);\n            }\n          } else {\n            if (y < this.miny) {\n              y = this.miny;\n            }\n\n            if (y > this.maxy) {\n              y = this.maxy;\n            }\n\n            if (!path.length) {\n              // previous value was null\n              path.push([xpos, canvasTop + canvasHeight]);\n            }\n\n            vertex = [xpos, canvasTop + Math.round(canvasHeight - canvasHeight * ((y - this.miny) / rangey))];\n            path.push(vertex);\n            vertices.push(vertex);\n          }\n        }\n\n        lineShapes = [];\n        fillShapes = [];\n        plen = paths.length;\n\n        for (i = 0; i < plen; i++) {\n          path = paths[i];\n\n          if (path.length) {\n            if (options.get('fillColor')) {\n              path.push([path[path.length - 1][0], canvasTop + canvasHeight]);\n              fillShapes.push(path.slice(0));\n              path.pop();\n            } // if there's only a single point in this path, then we want to display it\n            // as a vertical line which means we keep path[0]  as is\n\n\n            if (path.length > 2) {\n              // else we want the first value\n              path[0] = [path[0][0], path[1][1]];\n            }\n\n            lineShapes.push(path);\n          }\n        } // draw the fill first, then optionally the normal range, then the line on top of that\n\n\n        plen = fillShapes.length;\n\n        for (i = 0; i < plen; i++) {\n          target.drawShape(fillShapes[i], options.get('fillColor'), options.get('fillColor')).append();\n        }\n\n        if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {\n          this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);\n        }\n\n        plen = lineShapes.length;\n\n        for (i = 0; i < plen; i++) {\n          target.drawShape(lineShapes[i], options.get('lineColor'), undefined, options.get('lineWidth')).append();\n        }\n\n        if (spotRadius && options.get('valueSpots')) {\n          valueSpots = options.get('valueSpots');\n\n          if (valueSpots.get === undefined) {\n            valueSpots = new RangeMap(valueSpots);\n          }\n\n          for (i = 0; i < yvalcount; i++) {\n            color = valueSpots.get(yvalues[i]);\n\n            if (color) {\n              target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[i] - this.miny) / rangey)), spotRadius, undefined, color).append();\n            }\n          }\n        }\n\n        if (spotRadius && options.get('spotColor') && yvalues[yvallast] !== null) {\n          target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[yvallast] - this.miny) / rangey)), spotRadius, undefined, options.get('spotColor')).append();\n        }\n\n        if (this.maxy !== this.minyorg) {\n          if (spotRadius && options.get('minSpotColor')) {\n            x = xvalues[$.inArray(this.minyorg, yvalues)];\n            target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.minyorg - this.miny) / rangey)), spotRadius, undefined, options.get('minSpotColor')).append();\n          }\n\n          if (spotRadius && options.get('maxSpotColor')) {\n            x = xvalues[$.inArray(this.maxyorg, yvalues)];\n            target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.maxyorg - this.miny) / rangey)), spotRadius, undefined, options.get('maxSpotColor')).append();\n          }\n        }\n\n        this.lastShapeId = target.getLastShapeId();\n        this.canvasTop = canvasTop;\n        target.render();\n      }\n    });\n    /**\n     * Bar charts\n     */\n\n    $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {\n      type: 'bar',\n      init: function init(el, values, options, width, height) {\n        var barWidth = parseInt(options.get('barWidth'), 10),\n            barSpacing = parseInt(options.get('barSpacing'), 10),\n            chartRangeMin = options.get('chartRangeMin'),\n            chartRangeMax = options.get('chartRangeMax'),\n            chartRangeClip = options.get('chartRangeClip'),\n            stackMin = Infinity,\n            stackMax = -Infinity,\n            isStackString,\n            groupMin,\n            groupMax,\n            stackRanges,\n            numValues,\n            i,\n            vlen,\n            range,\n            zeroAxis,\n            xaxisOffset,\n            min,\n            max,\n            clipMin,\n            clipMax,\n            stacked,\n            vlist,\n            j,\n            slen,\n            svals,\n            val,\n            yoffset,\n            yMaxCalc,\n            canvasHeightEf;\n\n        bar._super.init.call(this, el, values, options, width, height); // scan values to determine whether to stack bars\n\n\n        for (i = 0, vlen = values.length; i < vlen; i++) {\n          val = values[i];\n          isStackString = typeof val === 'string' && val.indexOf(':') > -1;\n\n          if (isStackString || $.isArray(val)) {\n            stacked = true;\n\n            if (isStackString) {\n              val = values[i] = normalizeValues(val.split(':'));\n            }\n\n            val = remove(val, null); // min/max will treat null as zero\n\n            groupMin = Math.min.apply(Math, val);\n            groupMax = Math.max.apply(Math, val);\n\n            if (groupMin < stackMin) {\n              stackMin = groupMin;\n            }\n\n            if (groupMax > stackMax) {\n              stackMax = groupMax;\n            }\n          }\n        }\n\n        this.stacked = stacked;\n        this.regionShapes = {};\n        this.barWidth = barWidth;\n        this.barSpacing = barSpacing;\n        this.totalBarWidth = barWidth + barSpacing;\n        this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;\n        this.initTarget();\n\n        if (chartRangeClip) {\n          clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;\n          clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;\n        }\n\n        numValues = [];\n        stackRanges = stacked ? [] : numValues;\n        var stackTotals = [];\n        var stackRangesNeg = [];\n\n        for (i = 0, vlen = values.length; i < vlen; i++) {\n          if (stacked) {\n            vlist = values[i];\n            values[i] = svals = [];\n            stackTotals[i] = 0;\n            stackRanges[i] = stackRangesNeg[i] = 0;\n\n            for (j = 0, slen = vlist.length; j < slen; j++) {\n              val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];\n\n              if (val !== null) {\n                if (val > 0) {\n                  stackTotals[i] += val;\n                }\n\n                if (stackMin < 0 && stackMax > 0) {\n                  if (val < 0) {\n                    stackRangesNeg[i] += Math.abs(val);\n                  } else {\n                    stackRanges[i] += val;\n                  }\n                } else {\n                  stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));\n                }\n\n                numValues.push(val);\n              }\n            }\n          } else {\n            val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];\n            val = values[i] = normalizeValue(val);\n\n            if (val !== null) {\n              numValues.push(val);\n            }\n          }\n        }\n\n        this.max = max = Math.max.apply(Math, numValues);\n        this.min = min = Math.min.apply(Math, numValues);\n        this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;\n        this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;\n\n        if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {\n          min = options.get('chartRangeMin');\n        }\n\n        if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {\n          max = options.get('chartRangeMax');\n        }\n\n        this.zeroAxis = zeroAxis = options.get('zeroAxis', true);\n\n        if (min <= 0 && max >= 0 && zeroAxis) {\n          xaxisOffset = 0;\n        } else if (zeroAxis == false) {\n          xaxisOffset = min;\n        } else if (min > 0) {\n          xaxisOffset = min;\n        } else {\n          xaxisOffset = max;\n        }\n\n        this.xaxisOffset = xaxisOffset;\n        range = stacked ? Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg) : max - min; // as we plot zero/min values a single pixel line, we add a pixel to all other\n        // values - Reduce the effective canvas size to suit\n\n        this.canvasHeightEf = zeroAxis && min < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1;\n\n        if (min < xaxisOffset) {\n          yMaxCalc = stacked && max >= 0 ? stackMax : max;\n          yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;\n\n          if (yoffset !== Math.ceil(yoffset)) {\n            this.canvasHeightEf -= 2;\n            yoffset = Math.ceil(yoffset);\n          }\n        } else {\n          yoffset = this.canvasHeight;\n        }\n\n        this.yoffset = yoffset;\n\n        if ($.isArray(options.get('colorMap'))) {\n          this.colorMapByIndex = options.get('colorMap');\n          this.colorMapByValue = null;\n        } else {\n          this.colorMapByIndex = null;\n          this.colorMapByValue = options.get('colorMap');\n\n          if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n            this.colorMapByValue = new RangeMap(this.colorMapByValue);\n          }\n        }\n\n        this.range = range;\n      },\n      getRegion: function getRegion(el, x, y) {\n        var result = Math.floor(x / this.totalBarWidth);\n        return result < 0 || result >= this.values.length ? undefined : result;\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {\n        var currentRegion = this.currentRegion,\n            values = ensureArray(this.values[currentRegion]),\n            result = [],\n            value,\n            i;\n\n        for (i = values.length; i--;) {\n          value = values[i];\n          result.push({\n            isNull: value === null,\n            value: value,\n            color: this.calcColor(i, value, currentRegion),\n            offset: currentRegion\n          });\n        }\n\n        return result;\n      },\n      calcColor: function calcColor(stacknum, value, valuenum) {\n        var colorMapByIndex = this.colorMapByIndex,\n            colorMapByValue = this.colorMapByValue,\n            options = this.options,\n            color,\n            newColor;\n\n        if (this.stacked) {\n          color = options.get('stackedBarColor');\n        } else {\n          color = value < 0 ? options.get('negBarColor') : options.get('barColor');\n        }\n\n        if (value === 0 && options.get('zeroColor') !== undefined) {\n          color = options.get('zeroColor');\n        }\n\n        if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n          color = newColor;\n        } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n          color = colorMapByIndex[valuenum];\n        }\n\n        return $.isArray(color) ? color[stacknum % color.length] : color;\n      },\n\n      /**\n       * Render bar(s) for a region\n       */\n      renderRegion: function renderRegion(valuenum, highlight) {\n        var vals = this.values[valuenum],\n            options = this.options,\n            xaxisOffset = this.xaxisOffset,\n            result = [],\n            range = this.range,\n            stacked = this.stacked,\n            target = this.target,\n            x = valuenum * this.totalBarWidth,\n            canvasHeightEf = this.canvasHeightEf,\n            yoffset = this.yoffset,\n            y,\n            height,\n            color,\n            isNull,\n            yoffsetNeg,\n            i,\n            valcount,\n            val,\n            minPlotted,\n            allMin;\n        vals = $.isArray(vals) ? vals : [vals];\n        valcount = vals.length;\n        val = vals[0];\n        isNull = all(null, vals);\n        allMin = all(xaxisOffset, vals, true);\n\n        if (isNull) {\n          if (options.get('nullColor')) {\n            color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);\n            y = yoffset > 0 ? yoffset - 1 : yoffset;\n            return target.drawRect(x, y, this.barWidth - 1, 0, color, color);\n          } else {\n            return undefined;\n          }\n        }\n\n        yoffsetNeg = yoffset;\n\n        for (i = 0; i < valcount; i++) {\n          val = vals[i];\n\n          if (stacked && val === xaxisOffset) {\n            if (!allMin || minPlotted) {\n              continue;\n            }\n\n            minPlotted = true;\n          }\n\n          if (range > 0) {\n            height = Math.floor(canvasHeightEf * (Math.abs(val - xaxisOffset) / range)) + 1;\n          } else {\n            height = 1;\n          }\n\n          if (val < xaxisOffset || val === xaxisOffset && yoffset === 0) {\n            y = yoffsetNeg;\n            yoffsetNeg += height;\n          } else {\n            y = yoffset - height;\n            yoffset -= height;\n          }\n\n          color = this.calcColor(i, val, valuenum);\n\n          if (highlight) {\n            color = this.calcHighlightColor(color, options);\n          }\n\n          result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));\n        }\n\n        if (result.length === 1) {\n          return result[0];\n        }\n\n        return result;\n      }\n    });\n    /**\n     * Tristate charts\n     */\n\n    $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {\n      type: 'tristate',\n      init: function init(el, values, options, width, height) {\n        var barWidth = parseInt(options.get('barWidth'), 10),\n            barSpacing = parseInt(options.get('barSpacing'), 10);\n\n        tristate._super.init.call(this, el, values, options, width, height);\n\n        this.regionShapes = {};\n        this.barWidth = barWidth;\n        this.barSpacing = barSpacing;\n        this.totalBarWidth = barWidth + barSpacing;\n        this.values = $.map(values, Number);\n        this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;\n\n        if ($.isArray(options.get('colorMap'))) {\n          this.colorMapByIndex = options.get('colorMap');\n          this.colorMapByValue = null;\n        } else {\n          this.colorMapByIndex = null;\n          this.colorMapByValue = options.get('colorMap');\n\n          if (this.colorMapByValue && this.colorMapByValue.get === undefined) {\n            this.colorMapByValue = new RangeMap(this.colorMapByValue);\n          }\n        }\n\n        this.initTarget();\n      },\n      getRegion: function getRegion(el, x, y) {\n        return Math.floor(x / this.totalBarWidth);\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.values[currentRegion] === undefined,\n          value: this.values[currentRegion],\n          color: this.calcColor(this.values[currentRegion], currentRegion),\n          offset: currentRegion\n        };\n      },\n      calcColor: function calcColor(value, valuenum) {\n        var values = this.values,\n            options = this.options,\n            colorMapByIndex = this.colorMapByIndex,\n            colorMapByValue = this.colorMapByValue,\n            color,\n            newColor;\n\n        if (colorMapByValue && (newColor = colorMapByValue.get(value))) {\n          color = newColor;\n        } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {\n          color = colorMapByIndex[valuenum];\n        } else if (values[valuenum] < 0) {\n          color = options.get('negBarColor');\n        } else if (values[valuenum] > 0) {\n          color = options.get('posBarColor');\n        } else {\n          color = options.get('zeroBarColor');\n        }\n\n        return color;\n      },\n      renderRegion: function renderRegion(valuenum, highlight) {\n        var values = this.values,\n            options = this.options,\n            target = this.target,\n            canvasHeight,\n            height,\n            halfHeight,\n            x,\n            y,\n            color;\n        canvasHeight = target.pixelHeight;\n        halfHeight = Math.round(canvasHeight / 2);\n        x = valuenum * this.totalBarWidth;\n\n        if (values[valuenum] < 0) {\n          y = halfHeight;\n          height = halfHeight - 1;\n        } else if (values[valuenum] > 0) {\n          y = 0;\n          height = halfHeight - 1;\n        } else {\n          y = halfHeight - 1;\n          height = 2;\n        }\n\n        color = this.calcColor(values[valuenum], valuenum);\n\n        if (color === null) {\n          return;\n        }\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, options);\n        }\n\n        return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);\n      }\n    });\n    /**\n     * Discrete charts\n     */\n\n    $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {\n      type: 'discrete',\n      init: function init(el, values, options, width, height) {\n        discrete._super.init.call(this, el, values, options, width, height);\n\n        this.regionShapes = {};\n        this.values = values = $.map(values, Number);\n        this.min = Math.min.apply(Math, values);\n        this.max = Math.max.apply(Math, values);\n        this.range = this.max - this.min;\n        this.width = width = options.get('width') === 'auto' ? values.length * 2 : this.width;\n        this.interval = Math.floor(width / values.length);\n        this.itemWidth = width / values.length;\n\n        if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {\n          this.min = options.get('chartRangeMin');\n        }\n\n        if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {\n          this.max = options.get('chartRangeMax');\n        }\n\n        this.initTarget();\n\n        if (this.target) {\n          this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');\n        }\n      },\n      getRegion: function getRegion(el, x, y) {\n        return Math.floor(x / this.itemWidth);\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.values[currentRegion] === undefined,\n          value: this.values[currentRegion],\n          offset: currentRegion\n        };\n      },\n      renderRegion: function renderRegion(valuenum, highlight) {\n        var values = this.values,\n            options = this.options,\n            min = this.min,\n            max = this.max,\n            range = this.range,\n            interval = this.interval,\n            target = this.target,\n            canvasHeight = this.canvasHeight,\n            lineHeight = this.lineHeight,\n            pheight = canvasHeight - lineHeight,\n            ytop,\n            val,\n            color,\n            x;\n        val = clipval(values[valuenum], min, max);\n        x = valuenum * interval;\n        ytop = Math.round(pheight - pheight * ((val - min) / range));\n        color = options.get('thresholdColor') && val < options.get('thresholdValue') ? options.get('thresholdColor') : options.get('lineColor');\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, options);\n        }\n\n        return target.drawLine(x, ytop, x, ytop + lineHeight, color);\n      }\n    });\n    /**\n     * Bullet charts\n     */\n\n    $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {\n      type: 'bullet',\n      init: function init(el, values, options, width, height) {\n        var min, max, vals;\n\n        bullet._super.init.call(this, el, values, options, width, height); // values: target, performance, range1, range2, range3\n\n\n        this.values = values = normalizeValues(values); // target or performance could be null\n\n        vals = values.slice();\n        vals[0] = vals[0] === null ? vals[2] : vals[0];\n        vals[1] = values[1] === null ? vals[2] : vals[1];\n        min = Math.min.apply(Math, values);\n        max = Math.max.apply(Math, values);\n\n        if (options.get('base') === undefined) {\n          min = min < 0 ? min : 0;\n        } else {\n          min = options.get('base');\n        }\n\n        this.min = min;\n        this.max = max;\n        this.range = max - min;\n        this.shapes = {};\n        this.valueShapes = {};\n        this.regiondata = {};\n        this.width = width = options.get('width') === 'auto' ? '4.0em' : width;\n        this.target = this.$el.simpledraw(width, height, options.get('composite'));\n\n        if (!values.length) {\n          this.disabled = true;\n        }\n\n        this.initTarget();\n      },\n      getRegion: function getRegion(el, x, y) {\n        var shapeid = this.target.getShapeAt(el, x, y);\n        return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {\n        var currentRegion = this.currentRegion;\n        return {\n          fieldkey: currentRegion.substr(0, 1),\n          value: this.values[currentRegion.substr(1)],\n          region: currentRegion\n        };\n      },\n      changeHighlight: function changeHighlight(highlight) {\n        var currentRegion = this.currentRegion,\n            shapeid = this.valueShapes[currentRegion],\n            shape;\n        delete this.shapes[shapeid];\n\n        switch (currentRegion.substr(0, 1)) {\n          case 'r':\n            shape = this.renderRange(currentRegion.substr(1), highlight);\n            break;\n\n          case 'p':\n            shape = this.renderPerformance(highlight);\n            break;\n\n          case 't':\n            shape = this.renderTarget(highlight);\n            break;\n        }\n\n        this.valueShapes[currentRegion] = shape.id;\n        this.shapes[shape.id] = currentRegion;\n        this.target.replaceWithShape(shapeid, shape);\n      },\n      renderRange: function renderRange(rn, highlight) {\n        var rangeval = this.values[rn],\n            rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),\n            color = this.options.get('rangeColors')[rn - 2];\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, this.options);\n        }\n\n        return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);\n      },\n      renderPerformance: function renderPerformance(highlight) {\n        var perfval = this.values[1],\n            perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),\n            color = this.options.get('performanceColor');\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, this.options);\n        }\n\n        return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1, Math.round(this.canvasHeight * 0.4) - 1, color, color);\n      },\n      renderTarget: function renderTarget(highlight) {\n        var targetval = this.values[0],\n            x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - this.options.get('targetWidth') / 2),\n            targettop = Math.round(this.canvasHeight * 0.10),\n            targetheight = this.canvasHeight - targettop * 2,\n            color = this.options.get('targetColor');\n\n        if (highlight) {\n          color = this.calcHighlightColor(color, this.options);\n        }\n\n        return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);\n      },\n      render: function render() {\n        var vlen = this.values.length,\n            target = this.target,\n            i,\n            shape;\n\n        if (!bullet._super.render.call(this)) {\n          return;\n        }\n\n        for (i = 2; i < vlen; i++) {\n          shape = this.renderRange(i).append();\n          this.shapes[shape.id] = 'r' + i;\n          this.valueShapes['r' + i] = shape.id;\n        }\n\n        if (this.values[1] !== null) {\n          shape = this.renderPerformance().append();\n          this.shapes[shape.id] = 'p1';\n          this.valueShapes.p1 = shape.id;\n        }\n\n        if (this.values[0] !== null) {\n          shape = this.renderTarget().append();\n          this.shapes[shape.id] = 't0';\n          this.valueShapes.t0 = shape.id;\n        }\n\n        target.render();\n      }\n    });\n    /**\n     * Pie charts\n     */\n\n    $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {\n      type: 'pie',\n      init: function init(el, values, options, width, height) {\n        var total = 0,\n            i;\n\n        pie._super.init.call(this, el, values, options, width, height);\n\n        this.shapes = {}; // map shape ids to value offsets\n\n        this.valueShapes = {}; // maps value offsets to shape ids\n\n        this.values = values = $.map(values, Number);\n\n        if (options.get('width') === 'auto') {\n          this.width = this.height;\n        }\n\n        if (values.length > 0) {\n          for (i = values.length; i--;) {\n            total += values[i];\n          }\n        }\n\n        this.total = total;\n        this.initTarget();\n        this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);\n      },\n      getRegion: function getRegion(el, x, y) {\n        var shapeid = this.target.getShapeAt(el, x, y);\n        return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {\n        var currentRegion = this.currentRegion;\n        return {\n          isNull: this.values[currentRegion] === undefined,\n          value: this.values[currentRegion],\n          percent: this.values[currentRegion] / this.total * 100,\n          color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],\n          offset: currentRegion\n        };\n      },\n      changeHighlight: function changeHighlight(highlight) {\n        var currentRegion = this.currentRegion,\n            newslice = this.renderSlice(currentRegion, highlight),\n            shapeid = this.valueShapes[currentRegion];\n        delete this.shapes[shapeid];\n        this.target.replaceWithShape(shapeid, newslice);\n        this.valueShapes[currentRegion] = newslice.id;\n        this.shapes[newslice.id] = currentRegion;\n      },\n      renderSlice: function renderSlice(valuenum, highlight) {\n        var target = this.target,\n            options = this.options,\n            radius = this.radius,\n            borderWidth = options.get('borderWidth'),\n            offset = options.get('offset'),\n            circle = 2 * Math.PI,\n            values = this.values,\n            total = this.total,\n            next = offset ? 2 * Math.PI * (offset / 360) : 0,\n            start,\n            end,\n            i,\n            vlen,\n            color;\n        vlen = values.length;\n\n        for (i = 0; i < vlen; i++) {\n          start = next;\n          end = next;\n\n          if (total > 0) {\n            // avoid divide by zero\n            end = next + circle * (values[i] / total);\n          }\n\n          if (valuenum === i) {\n            color = options.get('sliceColors')[i % options.get('sliceColors').length];\n\n            if (highlight) {\n              color = this.calcHighlightColor(color, options);\n            }\n\n            return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);\n          }\n\n          next = end;\n        }\n      },\n      render: function render() {\n        var target = this.target,\n            values = this.values,\n            options = this.options,\n            radius = this.radius,\n            borderWidth = options.get('borderWidth'),\n            shape,\n            i;\n\n        if (!pie._super.render.call(this)) {\n          return;\n        }\n\n        if (borderWidth) {\n          target.drawCircle(radius, radius, Math.floor(radius - borderWidth / 2), options.get('borderColor'), undefined, borderWidth).append();\n        }\n\n        for (i = values.length; i--;) {\n          if (values[i]) {\n            // don't render zero values\n            shape = this.renderSlice(i).append();\n            this.valueShapes[i] = shape.id; // store just the shapeid\n\n            this.shapes[shape.id] = i;\n          }\n        }\n\n        target.render();\n      }\n    });\n    /**\n     * Box plots\n     */\n\n    $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {\n      type: 'box',\n      init: function init(el, values, options, width, height) {\n        box._super.init.call(this, el, values, options, width, height);\n\n        this.values = $.map(values, Number);\n        this.width = options.get('width') === 'auto' ? '4.0em' : width;\n        this.initTarget();\n\n        if (!this.values.length) {\n          this.disabled = 1;\n        }\n      },\n\n      /**\n       * Simulate a single region\n       */\n      getRegion: function getRegion() {\n        return 1;\n      },\n      getCurrentRegionFields: function getCurrentRegionFields() {\n        var result = [{\n          field: 'lq',\n          value: this.quartiles[0]\n        }, {\n          field: 'med',\n          value: this.quartiles[1]\n        }, {\n          field: 'uq',\n          value: this.quartiles[2]\n        }];\n\n        if (this.loutlier !== undefined) {\n          result.push({\n            field: 'lo',\n            value: this.loutlier\n          });\n        }\n\n        if (this.routlier !== undefined) {\n          result.push({\n            field: 'ro',\n            value: this.routlier\n          });\n        }\n\n        if (this.lwhisker !== undefined) {\n          result.push({\n            field: 'lw',\n            value: this.lwhisker\n          });\n        }\n\n        if (this.rwhisker !== undefined) {\n          result.push({\n            field: 'rw',\n            value: this.rwhisker\n          });\n        }\n\n        return result;\n      },\n      render: function render() {\n        var target = this.target,\n            values = this.values,\n            vlen = values.length,\n            options = this.options,\n            canvasWidth = this.canvasWidth,\n            canvasHeight = this.canvasHeight,\n            minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'),\n            maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'),\n            canvasLeft = 0,\n            lwhisker,\n            loutlier,\n            iqr,\n            q1,\n            q2,\n            q3,\n            rwhisker,\n            routlier,\n            i,\n            size,\n            unitSize;\n\n        if (!box._super.render.call(this)) {\n          return;\n        }\n\n        if (options.get('raw')) {\n          if (options.get('showOutliers') && values.length > 5) {\n            loutlier = values[0];\n            lwhisker = values[1];\n            q1 = values[2];\n            q2 = values[3];\n            q3 = values[4];\n            rwhisker = values[5];\n            routlier = values[6];\n          } else {\n            lwhisker = values[0];\n            q1 = values[1];\n            q2 = values[2];\n            q3 = values[3];\n            rwhisker = values[4];\n          }\n        } else {\n          values.sort(function (a, b) {\n            return a - b;\n          });\n          q1 = quartile(values, 1);\n          q2 = quartile(values, 2);\n          q3 = quartile(values, 3);\n          iqr = q3 - q1;\n\n          if (options.get('showOutliers')) {\n            lwhisker = rwhisker = undefined;\n\n            for (i = 0; i < vlen; i++) {\n              if (lwhisker === undefined && values[i] > q1 - iqr * options.get('outlierIQR')) {\n                lwhisker = values[i];\n              }\n\n              if (values[i] < q3 + iqr * options.get('outlierIQR')) {\n                rwhisker = values[i];\n              }\n            }\n\n            loutlier = values[0];\n            routlier = values[vlen - 1];\n          } else {\n            lwhisker = values[0];\n            rwhisker = values[vlen - 1];\n          }\n        }\n\n        this.quartiles = [q1, q2, q3];\n        this.lwhisker = lwhisker;\n        this.rwhisker = rwhisker;\n        this.loutlier = loutlier;\n        this.routlier = routlier;\n        unitSize = canvasWidth / (maxValue - minValue + 1);\n\n        if (options.get('showOutliers')) {\n          canvasLeft = Math.ceil(options.get('spotRadius'));\n          canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));\n          unitSize = canvasWidth / (maxValue - minValue + 1);\n\n          if (loutlier < lwhisker) {\n            target.drawCircle((loutlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();\n          }\n\n          if (routlier > rwhisker) {\n            target.drawCircle((routlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();\n          }\n        } // box\n\n\n        target.drawRect(Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q3 - q1) * unitSize), Math.round(canvasHeight * 0.8), options.get('boxLineColor'), options.get('boxFillColor')).append(); // left whisker\n\n        target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();\n        target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append(); // right whisker\n\n        target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q3 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();\n        target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append(); // median line\n\n        target.drawLine(Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.9), options.get('medianColor')).append();\n\n        if (options.get('target')) {\n          size = Math.ceil(options.get('spotRadius'));\n          target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 - size), Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 + size), options.get('targetColor')).append();\n          target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size), Math.round(canvasHeight / 2), Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size), Math.round(canvasHeight / 2), options.get('targetColor')).append();\n        }\n\n        target.render();\n      }\n    }); // Setup a very simple \"virtual canvas\" to make drawing the few shapes we need easier\n    // This is accessible as $(foo).simpledraw()\n\n    VShape = createClass({\n      init: function init(target, id, type, args) {\n        this.target = target;\n        this.id = id;\n        this.type = type;\n        this.args = args;\n      },\n      append: function append() {\n        this.target.appendShape(this);\n        return this;\n      }\n    });\n    VCanvas_base = createClass({\n      _pxregex: /(\\d+)(px)?\\s*$/i,\n      init: function init(width, height, target) {\n        if (!width) {\n          return;\n        }\n\n        this.width = width;\n        this.height = height;\n        this.target = target;\n        this.lastShapeId = null;\n\n        if (target[0]) {\n          target = target[0];\n        }\n\n        $.data(target, '_jqs_vcanvas', this);\n      },\n      drawLine: function drawLine(x1, y1, x2, y2, lineColor, lineWidth) {\n        return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);\n      },\n      drawShape: function drawShape(path, lineColor, fillColor, lineWidth) {\n        return this._genShape('Shape', [path, lineColor, fillColor, lineWidth]);\n      },\n      drawCircle: function drawCircle(x, y, radius, lineColor, fillColor, lineWidth) {\n        return this._genShape('Circle', [x, y, radius, lineColor, fillColor, lineWidth]);\n      },\n      drawPieSlice: function drawPieSlice(x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n        return this._genShape('PieSlice', [x, y, radius, startAngle, endAngle, lineColor, fillColor]);\n      },\n      drawRect: function drawRect(x, y, width, height, lineColor, fillColor) {\n        return this._genShape('Rect', [x, y, width, height, lineColor, fillColor]);\n      },\n      getElement: function getElement() {\n        return this.canvas;\n      },\n\n      /**\n       * Return the most recently inserted shape id\n       */\n      getLastShapeId: function getLastShapeId() {\n        return this.lastShapeId;\n      },\n\n      /**\n       * Clear and reset the canvas\n       */\n      reset: function reset() {\n        alert('reset not implemented');\n      },\n      _insert: function _insert(el, target) {\n        $(target).html(el);\n      },\n\n      /**\n       * Calculate the pixel dimensions of the canvas\n       */\n      _calculatePixelDims: function _calculatePixelDims(width, height, canvas) {\n        // XXX This should probably be a configurable option\n        var match;\n        match = this._pxregex.exec(height);\n\n        if (match) {\n          this.pixelHeight = match[1];\n        } else {\n          this.pixelHeight = $(canvas).height();\n        }\n\n        match = this._pxregex.exec(width);\n\n        if (match) {\n          this.pixelWidth = match[1];\n        } else {\n          this.pixelWidth = $(canvas).width();\n        }\n      },\n\n      /**\n       * Generate a shape object and id for later rendering\n       */\n      _genShape: function _genShape(shapetype, shapeargs) {\n        var id = shapeCount++;\n        shapeargs.unshift(id);\n        return new VShape(this, id, shapetype, shapeargs);\n      },\n\n      /**\n       * Add a shape to the end of the render queue\n       */\n      appendShape: function appendShape(shape) {\n        alert('appendShape not implemented');\n      },\n\n      /**\n       * Replace one shape with another\n       */\n      replaceWithShape: function replaceWithShape(shapeid, shape) {\n        alert('replaceWithShape not implemented');\n      },\n\n      /**\n       * Insert one shape after another in the render queue\n       */\n      insertAfterShape: function insertAfterShape(shapeid, shape) {\n        alert('insertAfterShape not implemented');\n      },\n\n      /**\n       * Remove a shape from the queue\n       */\n      removeShapeId: function removeShapeId(shapeid) {\n        alert('removeShapeId not implemented');\n      },\n\n      /**\n       * Find a shape at the specified x/y co-ordinates\n       */\n      getShapeAt: function getShapeAt(el, x, y) {\n        alert('getShapeAt not implemented');\n      },\n\n      /**\n       * Render all queued shapes onto the canvas\n       */\n      render: function render() {\n        alert('render not implemented');\n      }\n    });\n    VCanvas_canvas = createClass(VCanvas_base, {\n      init: function init(width, height, target, interact) {\n        VCanvas_canvas._super.init.call(this, width, height, target);\n\n        this.canvas = document.createElement('canvas');\n\n        if (target[0]) {\n          target = target[0];\n        }\n\n        $.data(target, '_jqs_vcanvas', this);\n        $(this.canvas).css({\n          display: 'inline-block',\n          width: width,\n          height: height,\n          verticalAlign: 'top'\n        });\n\n        this._insert(this.canvas, target);\n\n        this._calculatePixelDims(width, height, this.canvas);\n\n        this.canvas.width = this.pixelWidth;\n        this.canvas.height = this.pixelHeight;\n        this.interact = interact;\n        this.shapes = {};\n        this.shapeseq = [];\n        this.currentTargetShapeId = undefined;\n        $(this.canvas).css({\n          width: this.pixelWidth,\n          height: this.pixelHeight\n        });\n      },\n      _getContext: function _getContext(lineColor, fillColor, lineWidth) {\n        var context = this.canvas.getContext('2d');\n\n        if (lineColor !== undefined) {\n          context.strokeStyle = lineColor;\n        }\n\n        context.lineWidth = lineWidth === undefined ? 1 : lineWidth;\n\n        if (fillColor !== undefined) {\n          context.fillStyle = fillColor;\n        }\n\n        return context;\n      },\n      reset: function reset() {\n        var context = this._getContext();\n\n        context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);\n        this.shapes = {};\n        this.shapeseq = [];\n        this.currentTargetShapeId = undefined;\n      },\n      _drawShape: function _drawShape(shapeid, path, lineColor, fillColor, lineWidth) {\n        var context = this._getContext(lineColor, fillColor, lineWidth),\n            i,\n            plen;\n\n        context.beginPath();\n        context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);\n\n        for (i = 1, plen = path.length; i < plen; i++) {\n          context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines\n        }\n\n        if (lineColor !== undefined) {\n          context.stroke();\n        }\n\n        if (fillColor !== undefined) {\n          context.fill();\n        }\n\n        if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {\n          this.currentTargetShapeId = shapeid;\n        }\n      },\n      _drawCircle: function _drawCircle(shapeid, x, y, radius, lineColor, fillColor, lineWidth) {\n        var context = this._getContext(lineColor, fillColor, lineWidth);\n\n        context.beginPath();\n        context.arc(x, y, radius, 0, 2 * Math.PI, false);\n\n        if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {\n          this.currentTargetShapeId = shapeid;\n        }\n\n        if (lineColor !== undefined) {\n          context.stroke();\n        }\n\n        if (fillColor !== undefined) {\n          context.fill();\n        }\n      },\n      _drawPieSlice: function _drawPieSlice(shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n        var context = this._getContext(lineColor, fillColor);\n\n        context.beginPath();\n        context.moveTo(x, y);\n        context.arc(x, y, radius, startAngle, endAngle, false);\n        context.lineTo(x, y);\n        context.closePath();\n\n        if (lineColor !== undefined) {\n          context.stroke();\n        }\n\n        if (fillColor) {\n          context.fill();\n        }\n\n        if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {\n          this.currentTargetShapeId = shapeid;\n        }\n      },\n      _drawRect: function _drawRect(shapeid, x, y, width, height, lineColor, fillColor) {\n        return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);\n      },\n      appendShape: function appendShape(shape) {\n        this.shapes[shape.id] = shape;\n        this.shapeseq.push(shape.id);\n        this.lastShapeId = shape.id;\n        return shape.id;\n      },\n      replaceWithShape: function replaceWithShape(shapeid, shape) {\n        var shapeseq = this.shapeseq,\n            i;\n        this.shapes[shape.id] = shape;\n\n        for (i = shapeseq.length; i--;) {\n          if (shapeseq[i] == shapeid) {\n            shapeseq[i] = shape.id;\n          }\n        }\n\n        delete this.shapes[shapeid];\n      },\n      replaceWithShapes: function replaceWithShapes(shapeids, shapes) {\n        var shapeseq = this.shapeseq,\n            shapemap = {},\n            sid,\n            i,\n            first;\n\n        for (i = shapeids.length; i--;) {\n          shapemap[shapeids[i]] = true;\n        }\n\n        for (i = shapeseq.length; i--;) {\n          sid = shapeseq[i];\n\n          if (shapemap[sid]) {\n            shapeseq.splice(i, 1);\n            delete this.shapes[sid];\n            first = i;\n          }\n        }\n\n        for (i = shapes.length; i--;) {\n          shapeseq.splice(first, 0, shapes[i].id);\n          this.shapes[shapes[i].id] = shapes[i];\n        }\n      },\n      insertAfterShape: function insertAfterShape(shapeid, shape) {\n        var shapeseq = this.shapeseq,\n            i;\n\n        for (i = shapeseq.length; i--;) {\n          if (shapeseq[i] === shapeid) {\n            shapeseq.splice(i + 1, 0, shape.id);\n            this.shapes[shape.id] = shape;\n            return;\n          }\n        }\n      },\n      removeShapeId: function removeShapeId(shapeid) {\n        var shapeseq = this.shapeseq,\n            i;\n\n        for (i = shapeseq.length; i--;) {\n          if (shapeseq[i] === shapeid) {\n            shapeseq.splice(i, 1);\n            break;\n          }\n        }\n\n        delete this.shapes[shapeid];\n      },\n      getShapeAt: function getShapeAt(el, x, y) {\n        this.targetX = x;\n        this.targetY = y;\n        this.render();\n        return this.currentTargetShapeId;\n      },\n      render: function render() {\n        var shapeseq = this.shapeseq,\n            shapes = this.shapes,\n            shapeCount = shapeseq.length,\n            context = this._getContext(),\n            shapeid,\n            shape,\n            i;\n\n        context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);\n\n        for (i = 0; i < shapeCount; i++) {\n          shapeid = shapeseq[i];\n          shape = shapes[shapeid];\n          this['_draw' + shape.type].apply(this, shape.args);\n        }\n\n        if (!this.interact) {\n          // not interactive so no need to keep the shapes array\n          this.shapes = {};\n          this.shapeseq = [];\n        }\n      }\n    });\n    VCanvas_vml = createClass(VCanvas_base, {\n      init: function init(width, height, target) {\n        var groupel;\n\n        VCanvas_vml._super.init.call(this, width, height, target);\n\n        if (target[0]) {\n          target = target[0];\n        }\n\n        $.data(target, '_jqs_vcanvas', this);\n        this.canvas = document.createElement('span');\n        $(this.canvas).css({\n          display: 'inline-block',\n          position: 'relative',\n          overflow: 'hidden',\n          width: width,\n          height: height,\n          margin: '0px',\n          padding: '0px',\n          verticalAlign: 'top'\n        });\n\n        this._insert(this.canvas, target);\n\n        this._calculatePixelDims(width, height, this.canvas);\n\n        this.canvas.width = this.pixelWidth;\n        this.canvas.height = this.pixelHeight;\n        groupel = '<v:group coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + ' ' + this.pixelHeight + '\"' + ' style=\"position:absolute;top:0;left:0;width:' + this.pixelWidth + 'px;height=' + this.pixelHeight + 'px;\"></v:group>';\n        this.canvas.insertAdjacentHTML('beforeEnd', groupel);\n        this.group = $(this.canvas).children()[0];\n        this.rendered = false;\n        this.prerender = '';\n      },\n      _drawShape: function _drawShape(shapeid, path, lineColor, fillColor, lineWidth) {\n        var vpath = [],\n            initial,\n            stroke,\n            fill,\n            closed,\n            vel,\n            plen,\n            i;\n\n        for (i = 0, plen = path.length; i < plen; i++) {\n          vpath[i] = '' + path[i][0] + ',' + path[i][1];\n        }\n\n        initial = vpath.splice(0, 1);\n        lineWidth = lineWidth === undefined ? 1 : lineWidth;\n        stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"' + lineWidth + 'px\" strokeColor=\"' + lineColor + '\" ';\n        fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n        closed = vpath[0] === vpath[vpath.length - 1] ? 'x ' : '';\n        vel = '<v:shape coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + ' ' + this.pixelHeight + '\" ' + ' id=\"jqsshape' + shapeid + '\" ' + stroke + fill + ' style=\"position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;\" ' + ' path=\"m ' + initial + ' l ' + vpath.join(', ') + ' ' + closed + 'e\">' + ' </v:shape>';\n        return vel;\n      },\n      _drawCircle: function _drawCircle(shapeid, x, y, radius, lineColor, fillColor, lineWidth) {\n        var stroke, fill, vel;\n        x -= radius;\n        y -= radius;\n        stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"' + lineWidth + 'px\" strokeColor=\"' + lineColor + '\" ';\n        fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n        vel = '<v:oval ' + ' id=\"jqsshape' + shapeid + '\" ' + stroke + fill + ' style=\"position:absolute;top:' + y + 'px; left:' + x + 'px; width:' + radius * 2 + 'px; height:' + radius * 2 + 'px\"></v:oval>';\n        return vel;\n      },\n      _drawPieSlice: function _drawPieSlice(shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {\n        var vpath, startx, starty, endx, endy, stroke, fill, vel;\n\n        if (startAngle === endAngle) {\n          return ''; // VML seems to have problem when start angle equals end angle.\n        }\n\n        if (endAngle - startAngle === 2 * Math.PI) {\n          startAngle = 0.0; // VML seems to have a problem when drawing a full circle that doesn't start 0\n\n          endAngle = 2 * Math.PI;\n        }\n\n        startx = x + Math.round(Math.cos(startAngle) * radius);\n        starty = y + Math.round(Math.sin(startAngle) * radius);\n        endx = x + Math.round(Math.cos(endAngle) * radius);\n        endy = y + Math.round(Math.sin(endAngle) * radius);\n\n        if (startx === endx && starty === endy) {\n          if (endAngle - startAngle < Math.PI) {\n            // Prevent very small slices from being mistaken as a whole pie\n            return '';\n          } // essentially going to be the entire circle, so ignore startAngle\n\n\n          startx = endx = x + radius;\n          starty = endy = y;\n        }\n\n        if (startx === endx && starty === endy && endAngle - startAngle < Math.PI) {\n          return '';\n        }\n\n        vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];\n        stroke = lineColor === undefined ? ' stroked=\"false\" ' : ' strokeWeight=\"1px\" strokeColor=\"' + lineColor + '\" ';\n        fill = fillColor === undefined ? ' filled=\"false\"' : ' fillColor=\"' + fillColor + '\" filled=\"true\" ';\n        vel = '<v:shape coordorigin=\"0 0\" coordsize=\"' + this.pixelWidth + ' ' + this.pixelHeight + '\" ' + ' id=\"jqsshape' + shapeid + '\" ' + stroke + fill + ' style=\"position:absolute;left:0px;top:0px;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0px;margin:0px;\" ' + ' path=\"m ' + x + ',' + y + ' wa ' + vpath.join(', ') + ' x e\">' + ' </v:shape>';\n        return vel;\n      },\n      _drawRect: function _drawRect(shapeid, x, y, width, height, lineColor, fillColor) {\n        return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);\n      },\n      reset: function reset() {\n        this.group.innerHTML = '';\n      },\n      appendShape: function appendShape(shape) {\n        var vel = this['_draw' + shape.type].apply(this, shape.args);\n\n        if (this.rendered) {\n          this.group.insertAdjacentHTML('beforeEnd', vel);\n        } else {\n          this.prerender += vel;\n        }\n\n        this.lastShapeId = shape.id;\n        return shape.id;\n      },\n      replaceWithShape: function replaceWithShape(shapeid, shape) {\n        var existing = $('#jqsshape' + shapeid),\n            vel = this['_draw' + shape.type].apply(this, shape.args);\n        existing[0].outerHTML = vel;\n      },\n      replaceWithShapes: function replaceWithShapes(shapeids, shapes) {\n        // replace the first shapeid with all the new shapes then toast the remaining old shapes\n        var existing = $('#jqsshape' + shapeids[0]),\n            replace = '',\n            slen = shapes.length,\n            i;\n\n        for (i = 0; i < slen; i++) {\n          replace += this['_draw' + shapes[i].type].apply(this, shapes[i].args);\n        }\n\n        existing[0].outerHTML = replace;\n\n        for (i = 1; i < shapeids.length; i++) {\n          $('#jqsshape' + shapeids[i]).remove();\n        }\n      },\n      insertAfterShape: function insertAfterShape(shapeid, shape) {\n        var existing = $('#jqsshape' + shapeid),\n            vel = this['_draw' + shape.type].apply(this, shape.args);\n        existing[0].insertAdjacentHTML('afterEnd', vel);\n      },\n      removeShapeId: function removeShapeId(shapeid) {\n        var existing = $('#jqsshape' + shapeid);\n        this.group.removeChild(existing[0]);\n      },\n      getShapeAt: function getShapeAt(el, x, y) {\n        var shapeid = el.id.substr(8);\n        return shapeid;\n      },\n      render: function render() {\n        if (!this.rendered) {\n          // batch the intial render into a single repaint\n          this.group.innerHTML = this.prerender;\n          this.rendered = true;\n        }\n      }\n    });\n  });\n})(document, Math);","map":null,"metadata":{},"sourceType":"script"}