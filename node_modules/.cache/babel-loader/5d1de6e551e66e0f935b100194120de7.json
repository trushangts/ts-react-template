{"ast":null,"code":"import jQuery from \"jquery\";\n!function (t) {\n  t.color = {}, t.color.make = function (i, e, o, n) {\n    var a = {};\n    return a.r = i || 0, a.g = e || 0, a.b = o || 0, a.a = null != n ? n : 1, a.add = function (t, i) {\n      for (var e = 0; e < t.length; ++e) {\n        a[t.charAt(e)] += i;\n      }\n\n      return a.normalize();\n    }, a.scale = function (t, i) {\n      for (var e = 0; e < t.length; ++e) {\n        a[t.charAt(e)] *= i;\n      }\n\n      return a.normalize();\n    }, a.toString = function () {\n      return a.a >= 1 ? \"rgb(\" + [a.r, a.g, a.b].join(\",\") + \")\" : \"rgba(\" + [a.r, a.g, a.b, a.a].join(\",\") + \")\";\n    }, a.normalize = function () {\n      function t(t, i, e) {\n        return t > i ? t : i > e ? e : i;\n      }\n\n      return a.r = t(0, parseInt(a.r), 255), a.g = t(0, parseInt(a.g), 255), a.b = t(0, parseInt(a.b), 255), a.a = t(0, a.a, 1), a;\n    }, a.clone = function () {\n      return t.color.make(a.r, a.b, a.g, a.a);\n    }, a.normalize();\n  }, t.color.extract = function (i, e) {\n    var o;\n\n    do {\n      if (o = i.css(e).toLowerCase(), \"\" != o && \"transparent\" != o) break;\n      i = i.parent();\n    } while (i.length && !t.nodeName(i.get(0), \"body\"));\n\n    return \"rgba(0, 0, 0, 0)\" == o && (o = \"transparent\"), t.color.parse(o);\n  }, t.color.parse = function (e) {\n    var o,\n        n = t.color.make;\n    if (o = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(e)) return n(parseInt(o[1], 10), parseInt(o[2], 10), parseInt(o[3], 10));\n    if (o = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(e)) return n(parseInt(o[1], 10), parseInt(o[2], 10), parseInt(o[3], 10), parseFloat(o[4]));\n    if (o = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(e)) return n(2.55 * parseFloat(o[1]), 2.55 * parseFloat(o[2]), 2.55 * parseFloat(o[3]));\n    if (o = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(e)) return n(2.55 * parseFloat(o[1]), 2.55 * parseFloat(o[2]), 2.55 * parseFloat(o[3]), parseFloat(o[4]));\n    if (o = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(e)) return n(parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16));\n    if (o = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(e)) return n(parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16));\n    var a = t.trim(e).toLowerCase();\n    return \"transparent\" == a ? n(255, 255, 255, 0) : (o = i[a] || [0, 0, 0], n(o[0], o[1], o[2]));\n  };\n  var i = {\n    aqua: [0, 255, 255],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    black: [0, 0, 0],\n    blue: [0, 0, 255],\n    brown: [165, 42, 42],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgrey: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkviolet: [148, 0, 211],\n    fuchsia: [255, 0, 255],\n    gold: [255, 215, 0],\n    green: [0, 128, 0],\n    indigo: [75, 0, 130],\n    khaki: [240, 230, 140],\n    lightblue: [173, 216, 230],\n    lightcyan: [224, 255, 255],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    navy: [0, 0, 128],\n    olive: [128, 128, 0],\n    orange: [255, 165, 0],\n    pink: [255, 192, 203],\n    purple: [128, 0, 128],\n    violet: [128, 0, 128],\n    red: [255, 0, 0],\n    silver: [192, 192, 192],\n    white: [255, 255, 255],\n    yellow: [255, 255, 0]\n  };\n}(jQuery), function (t) {\n  function i(i, e) {\n    var o = e.children(\".\" + i)[0];\n\n    if (null == o && (o = document.createElement(\"canvas\"), o.className = i, t(o).css({\n      direction: \"ltr\",\n      position: \"absolute\",\n      left: 0,\n      top: 0\n    }).appendTo(e), !o.getContext)) {\n      if (!window.G_vmlCanvasManager) throw new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n      o = window.G_vmlCanvasManager.initElement(o);\n    }\n\n    this.element = o;\n    var n = this.context = o.getContext(\"2d\"),\n        a = window.devicePixelRatio || 1,\n        r = n.webkitBackingStorePixelRatio || n.mozBackingStorePixelRatio || n.msBackingStorePixelRatio || n.oBackingStorePixelRatio || n.backingStorePixelRatio || 1;\n    this.pixelRatio = a / r, this.resize(e.width(), e.height()), this.textContainer = null, this.text = {}, this._textCache = {};\n  }\n\n  function e(e, n, a, r) {\n    function l(t, i) {\n      i = [gt].concat(i);\n\n      for (var e = 0; e < t.length; ++e) {\n        t[e].apply(this, i);\n      }\n    }\n\n    function s() {\n      for (var e = {\n        Canvas: i\n      }, o = 0; o < r.length; ++o) {\n        var n = r[o];\n        n.init(gt, e), n.options && t.extend(!0, nt, n.options);\n      }\n    }\n\n    function c(i) {\n      t.extend(!0, nt, i), i && i.colors && (nt.colors = i.colors), null == nt.xaxis.color && (nt.xaxis.color = t.color.parse(nt.grid.color).scale(\"a\", 0.22).toString()), null == nt.yaxis.color && (nt.yaxis.color = t.color.parse(nt.grid.color).scale(\"a\", 0.22).toString()), null == nt.xaxis.tickColor && (nt.xaxis.tickColor = nt.grid.tickColor || nt.xaxis.color), null == nt.yaxis.tickColor && (nt.yaxis.tickColor = nt.grid.tickColor || nt.yaxis.color), null == nt.grid.borderColor && (nt.grid.borderColor = nt.grid.color), null == nt.grid.tickColor && (nt.grid.tickColor = t.color.parse(nt.grid.color).scale(\"a\", 0.22).toString());\n      var o,\n          n,\n          a,\n          r = e.css(\"font-size\"),\n          s = r ? +r.replace(\"px\", \"\") : 13,\n          c = {\n        style: e.css(\"font-style\"),\n        size: Math.round(0.8 * s),\n        variant: e.css(\"font-variant\"),\n        weight: e.css(\"font-weight\"),\n        family: e.css(\"font-family\")\n      };\n\n      for (a = nt.xaxes.length || 1, o = 0; a > o; ++o) {\n        n = nt.xaxes[o], n && !n.tickColor && (n.tickColor = n.color), n = t.extend(!0, {}, nt.xaxis, n), nt.xaxes[o] = n, n.font && (n.font = t.extend({}, c, n.font), n.font.color || (n.font.color = n.color), n.font.lineHeight || (n.font.lineHeight = Math.round(1.15 * n.font.size)));\n      }\n\n      for (a = nt.yaxes.length || 1, o = 0; a > o; ++o) {\n        n = nt.yaxes[o], n && !n.tickColor && (n.tickColor = n.color), n = t.extend(!0, {}, nt.yaxis, n), nt.yaxes[o] = n, n.font && (n.font = t.extend({}, c, n.font), n.font.color || (n.font.color = n.color), n.font.lineHeight || (n.font.lineHeight = Math.round(1.15 * n.font.size)));\n      }\n\n      for (nt.xaxis.noTicks && null == nt.xaxis.ticks && (nt.xaxis.ticks = nt.xaxis.noTicks), nt.yaxis.noTicks && null == nt.yaxis.ticks && (nt.yaxis.ticks = nt.yaxis.noTicks), nt.x2axis && (nt.xaxes[1] = t.extend(!0, {}, nt.xaxis, nt.x2axis), nt.xaxes[1].position = \"top\", null == nt.x2axis.min && (nt.xaxes[1].min = null), null == nt.x2axis.max && (nt.xaxes[1].max = null)), nt.y2axis && (nt.yaxes[1] = t.extend(!0, {}, nt.yaxis, nt.y2axis), nt.yaxes[1].position = \"right\", null == nt.y2axis.min && (nt.yaxes[1].min = null), null == nt.y2axis.max && (nt.yaxes[1].max = null)), nt.grid.coloredAreas && (nt.grid.markings = nt.grid.coloredAreas), nt.grid.coloredAreasColor && (nt.grid.markingsColor = nt.grid.coloredAreasColor), nt.lines && t.extend(!0, nt.series.lines, nt.lines), nt.points && t.extend(!0, nt.series.points, nt.points), nt.bars && t.extend(!0, nt.series.bars, nt.bars), null != nt.shadowSize && (nt.series.shadowSize = nt.shadowSize), null != nt.highlightColor && (nt.series.highlightColor = nt.highlightColor), o = 0; o < nt.xaxes.length; ++o) {\n        g(ht, o + 1).options = nt.xaxes[o];\n      }\n\n      for (o = 0; o < nt.yaxes.length; ++o) {\n        g(ft, o + 1).options = nt.yaxes[o];\n      }\n\n      for (var h in mt) {\n        nt.hooks[h] && nt.hooks[h].length && (mt[h] = mt[h].concat(nt.hooks[h]));\n      }\n\n      l(mt.processOptions, [nt]);\n    }\n\n    function h(t) {\n      ot = f(t), x(), b();\n    }\n\n    function f(i) {\n      for (var e = [], o = 0; o < i.length; ++o) {\n        var n = t.extend(!0, {}, nt.series);\n        null != i[o].data ? (n.data = i[o].data, delete i[o].data, t.extend(!0, n, i[o]), i[o].data = n.data) : n.data = i[o], e.push(n);\n      }\n\n      return e;\n    }\n\n    function u(t, i) {\n      var e = t[i + \"axis\"];\n      return \"object\" == typeof e && (e = e.n), \"number\" != typeof e && (e = 1), e;\n    }\n\n    function d() {\n      return t.grep(ht.concat(ft), function (t) {\n        return t;\n      });\n    }\n\n    function p(t) {\n      var i,\n          e,\n          o = {};\n\n      for (i = 0; i < ht.length; ++i) {\n        e = ht[i], e && e.used && (o[\"x\" + e.n] = e.c2p(t.left));\n      }\n\n      for (i = 0; i < ft.length; ++i) {\n        e = ft[i], e && e.used && (o[\"y\" + e.n] = e.c2p(t.top));\n      }\n\n      return void 0 !== o.x1 && (o.x = o.x1), void 0 !== o.y1 && (o.y = o.y1), o;\n    }\n\n    function m(t) {\n      var i,\n          e,\n          o,\n          n = {};\n\n      for (i = 0; i < ht.length; ++i) {\n        if (e = ht[i], e && e.used && (o = \"x\" + e.n, null == t[o] && 1 == e.n && (o = \"x\"), null != t[o])) {\n          n.left = e.p2c(t[o]);\n          break;\n        }\n      }\n\n      for (i = 0; i < ft.length; ++i) {\n        if (e = ft[i], e && e.used && (o = \"y\" + e.n, null == t[o] && 1 == e.n && (o = \"y\"), null != t[o])) {\n          n.top = e.p2c(t[o]);\n          break;\n        }\n      }\n\n      return n;\n    }\n\n    function g(i, e) {\n      return i[e - 1] || (i[e - 1] = {\n        n: e,\n        direction: i == ht ? \"x\" : \"y\",\n        options: t.extend(!0, {}, i == ht ? nt.xaxis : nt.yaxis)\n      }), i[e - 1];\n    }\n\n    function x() {\n      var i,\n          e = ot.length,\n          o = -1;\n\n      for (i = 0; i < ot.length; ++i) {\n        var n = ot[i].color;\n        null != n && (e--, \"number\" == typeof n && n > o && (o = n));\n      }\n\n      o >= e && (e = o + 1);\n      var a,\n          r = [],\n          l = nt.colors,\n          s = l.length,\n          c = 0;\n\n      for (i = 0; e > i; i++) {\n        a = t.color.parse(l[i % s] || \"#666\"), i % s == 0 && i && (c = c >= 0 ? 0.5 > c ? -c - 0.2 : 0 : -c), r[i] = a.scale(\"rgb\", 1 + c);\n      }\n\n      var h,\n          f = 0;\n\n      for (i = 0; i < ot.length; ++i) {\n        if (h = ot[i], null == h.color ? (h.color = r[f].toString(), ++f) : \"number\" == typeof h.color && (h.color = r[h.color].toString()), null == h.lines.show) {\n          var d,\n              p = !0;\n\n          for (d in h) {\n            if (h[d] && h[d].show) {\n              p = !1;\n              break;\n            }\n          }\n\n          p && (h.lines.show = !0);\n        }\n\n        null == h.lines.zero && (h.lines.zero = !!h.lines.fill), h.xaxis = g(ht, u(h, \"x\")), h.yaxis = g(ft, u(h, \"y\"));\n      }\n    }\n\n    function b() {\n      function i(t, i, e) {\n        i < t.datamin && i != -b && (t.datamin = i), e > t.datamax && e != b && (t.datamax = e);\n      }\n\n      var e,\n          o,\n          n,\n          a,\n          r,\n          s,\n          c,\n          h,\n          f,\n          u,\n          p,\n          m,\n          g = Number.POSITIVE_INFINITY,\n          x = Number.NEGATIVE_INFINITY,\n          b = Number.MAX_VALUE;\n\n      for (t.each(d(), function (t, i) {\n        i.datamin = g, i.datamax = x, i.used = !1;\n      }), e = 0; e < ot.length; ++e) {\n        r = ot[e], r.datapoints = {\n          points: []\n        }, l(mt.processRawData, [r, r.data, r.datapoints]);\n      }\n\n      for (e = 0; e < ot.length; ++e) {\n        if (r = ot[e], p = r.data, m = r.datapoints.format, !m) {\n          if (m = [], m.push({\n            x: !0,\n            number: !0,\n            required: !0\n          }), m.push({\n            y: !0,\n            number: !0,\n            required: !0\n          }), r.bars.show || r.lines.show && r.lines.fill) {\n            var v = !!(r.bars.show && r.bars.zero || r.lines.show && r.lines.zero);\n            m.push({\n              y: !0,\n              number: !0,\n              required: !1,\n              defaultValue: 0,\n              autoscale: v\n            }), r.bars.horizontal && (delete m[m.length - 1].y, m[m.length - 1].x = !0);\n          }\n\n          r.datapoints.format = m;\n        }\n\n        if (null == r.datapoints.pointsize) {\n          r.datapoints.pointsize = m.length, c = r.datapoints.pointsize, s = r.datapoints.points;\n          var k = r.lines.show && r.lines.steps;\n\n          for (r.xaxis.used = r.yaxis.used = !0, o = n = 0; o < p.length; ++o, n += c) {\n            u = p[o];\n            var y = null == u;\n            if (!y) for (a = 0; c > a; ++a) {\n              h = u[a], f = m[a], f && (f.number && null != h && (h = +h, isNaN(h) ? h = null : 1 / 0 == h ? h = b : h == -1 / 0 && (h = -b)), null == h && (f.required && (y = !0), null != f.defaultValue && (h = f.defaultValue))), s[n + a] = h;\n            }\n            if (y) for (a = 0; c > a; ++a) {\n              h = s[n + a], null != h && (f = m[a], f.autoscale !== !1 && (f.x && i(r.xaxis, h, h), f.y && i(r.yaxis, h, h))), s[n + a] = null;\n            } else if (k && n > 0 && null != s[n - c] && s[n - c] != s[n] && s[n - c + 1] != s[n + 1]) {\n              for (a = 0; c > a; ++a) {\n                s[n + c + a] = s[n + a];\n              }\n\n              s[n + 1] = s[n - c + 1], n += c;\n            }\n          }\n        }\n      }\n\n      for (e = 0; e < ot.length; ++e) {\n        r = ot[e], l(mt.processDatapoints, [r, r.datapoints]);\n      }\n\n      for (e = 0; e < ot.length; ++e) {\n        r = ot[e], s = r.datapoints.points, c = r.datapoints.pointsize, m = r.datapoints.format;\n        var w = g,\n            M = g,\n            C = x,\n            T = x;\n\n        for (o = 0; o < s.length; o += c) {\n          if (null != s[o]) for (a = 0; c > a; ++a) {\n            h = s[o + a], f = m[a], f && f.autoscale !== !1 && h != b && h != -b && (f.x && (w > h && (w = h), h > C && (C = h)), f.y && (M > h && (M = h), h > T && (T = h)));\n          }\n        }\n\n        if (r.bars.show) {\n          var W;\n\n          switch (r.bars.align) {\n            case \"left\":\n              W = 0;\n              break;\n\n            case \"right\":\n              W = -r.bars.barWidth;\n              break;\n\n            default:\n              W = -r.bars.barWidth / 2;\n          }\n\n          r.bars.horizontal ? (M += W, T += W + r.bars.barWidth) : (w += W, C += W + r.bars.barWidth);\n        }\n\n        i(r.xaxis, w, C), i(r.yaxis, M, T);\n      }\n\n      t.each(d(), function (t, i) {\n        i.datamin == g && (i.datamin = null), i.datamax == x && (i.datamax = null);\n      });\n    }\n\n    function v() {\n      e.css(\"padding\", 0).children().filter(function () {\n        return !t(this).hasClass(\"flot-overlay\") && !t(this).hasClass(\"flot-base\");\n      }).remove(), \"static\" == e.css(\"position\") && e.css(\"position\", \"relative\"), at = new i(\"flot-base\", e), rt = new i(\"flot-overlay\", e), st = at.context, ct = rt.context, lt = t(rt.element).unbind();\n      var o = e.data(\"plot\");\n      o && (o.shutdown(), rt.clear()), e.data(\"plot\", gt);\n    }\n\n    function k() {\n      nt.grid.hoverable && (lt.mousemove(X), lt.bind(\"mouseleave\", Y)), nt.grid.clickable && lt.click(q), l(mt.bindEvents, [lt]);\n    }\n\n    function y() {\n      bt && clearTimeout(bt), lt.unbind(\"mousemove\", X), lt.unbind(\"mouseleave\", Y), lt.unbind(\"click\", q), l(mt.shutdown, [lt]);\n    }\n\n    function w(t) {\n      function i(t) {\n        return t;\n      }\n\n      var e,\n          o,\n          n = t.options.transform || i,\n          a = t.options.inverseTransform;\n      \"x\" == t.direction ? (e = t.scale = dt / Math.abs(n(t.max) - n(t.min)), o = Math.min(n(t.max), n(t.min))) : (e = t.scale = pt / Math.abs(n(t.max) - n(t.min)), e = -e, o = Math.max(n(t.max), n(t.min))), t.p2c = n == i ? function (t) {\n        return (t - o) * e;\n      } : function (t) {\n        return (n(t) - o) * e;\n      }, t.c2p = a ? function (t) {\n        return a(o + t / e);\n      } : function (t) {\n        return o + t / e;\n      };\n    }\n\n    function M(t) {\n      for (var i = t.options, e = t.ticks || [], o = i.labelWidth || 0, n = i.labelHeight || 0, a = o || (\"x\" == t.direction ? Math.floor(at.width / (e.length || 1)) : null), r = t.direction + \"Axis \" + t.direction + t.n + \"Axis\", l = \"flot-\" + t.direction + \"-axis flot-\" + t.direction + t.n + \"-axis \" + r, s = i.font || \"flot-tick-label tickLabel\", c = 0; c < e.length; ++c) {\n        var h = e[c];\n\n        if (h.label) {\n          var f = at.getTextInfo(l, h.label, s, null, a);\n          o = Math.max(o, f.width), n = Math.max(n, f.height);\n        }\n      }\n\n      t.labelWidth = i.labelWidth || o, t.labelHeight = i.labelHeight || n;\n    }\n\n    function C(i) {\n      var e = i.labelWidth,\n          o = i.labelHeight,\n          n = i.options.position,\n          a = \"x\" === i.direction,\n          r = i.options.tickLength,\n          l = nt.grid.axisMargin,\n          s = nt.grid.labelMargin,\n          c = !0,\n          h = !0,\n          f = !0,\n          u = !1;\n      t.each(a ? ht : ft, function (t, e) {\n        e && (e.show || e.reserveSpace) && (e === i ? u = !0 : e.options.position === n && (u ? h = !1 : c = !1), u || (f = !1));\n      }), h && (l = 0), null == r && (r = f ? \"full\" : 5), isNaN(+r) || (s += +r), a ? (o += s, \"bottom\" == n ? (ut.bottom += o + l, i.box = {\n        top: at.height - ut.bottom,\n        height: o\n      }) : (i.box = {\n        top: ut.top + l,\n        height: o\n      }, ut.top += o + l)) : (e += s, \"left\" == n ? (i.box = {\n        left: ut.left + l,\n        width: e\n      }, ut.left += e + l) : (ut.right += e + l, i.box = {\n        left: at.width - ut.right,\n        width: e\n      })), i.position = n, i.tickLength = r, i.box.padding = s, i.innermost = c;\n    }\n\n    function T(t) {\n      \"x\" == t.direction ? (t.box.left = ut.left - t.labelWidth / 2, t.box.width = at.width - ut.left - ut.right + t.labelWidth) : (t.box.top = ut.top - t.labelHeight / 2, t.box.height = at.height - ut.bottom - ut.top + t.labelHeight);\n    }\n\n    function W() {\n      var i,\n          e = nt.grid.minBorderMargin;\n      if (null == e) for (e = 0, i = 0; i < ot.length; ++i) {\n        e = Math.max(e, 2 * (ot[i].points.radius + ot[i].points.lineWidth / 2));\n      }\n      var o = {\n        left: e,\n        right: e,\n        top: e,\n        bottom: e\n      };\n      t.each(d(), function (t, i) {\n        i.reserveSpace && i.ticks && i.ticks.length && (\"x\" === i.direction ? (o.left = Math.max(o.left, i.labelWidth / 2), o.right = Math.max(o.right, i.labelWidth / 2)) : (o.bottom = Math.max(o.bottom, i.labelHeight / 2), o.top = Math.max(o.top, i.labelHeight / 2)));\n      }), ut.left = Math.ceil(Math.max(o.left, ut.left)), ut.right = Math.ceil(Math.max(o.right, ut.right)), ut.top = Math.ceil(Math.max(o.top, ut.top)), ut.bottom = Math.ceil(Math.max(o.bottom, ut.bottom));\n    }\n\n    function S() {\n      var i,\n          e = d(),\n          o = nt.grid.show;\n\n      for (var n in ut) {\n        var a = nt.grid.margin || 0;\n        ut[n] = \"number\" == typeof a ? a : a[n] || 0;\n      }\n\n      l(mt.processOffset, [ut]);\n\n      for (var n in ut) {\n        ut[n] += \"object\" == typeof nt.grid.borderWidth ? o ? nt.grid.borderWidth[n] : 0 : o ? nt.grid.borderWidth : 0;\n      }\n\n      if (t.each(e, function (t, i) {\n        var e = i.options;\n        i.show = null == e.show ? i.used : e.show, i.reserveSpace = null == e.reserveSpace ? i.show : e.reserveSpace, z(i);\n      }), o) {\n        var r = t.grep(e, function (t) {\n          return t.show || t.reserveSpace;\n        });\n\n        for (t.each(r, function (t, i) {\n          I(i), A(i), _(i, i.ticks), M(i);\n        }), i = r.length - 1; i >= 0; --i) {\n          C(r[i]);\n        }\n\n        W(), t.each(r, function (t, i) {\n          T(i);\n        });\n      }\n\n      dt = at.width - ut.left - ut.right, pt = at.height - ut.bottom - ut.top, t.each(e, function (t, i) {\n        w(i);\n      }), o && O(), G();\n    }\n\n    function z(t) {\n      var i = t.options,\n          e = +(null != i.min ? i.min : t.datamin),\n          o = +(null != i.max ? i.max : t.datamax),\n          n = o - e;\n\n      if (0 == n) {\n        var a = 0 == o ? 1 : 0.01;\n        null == i.min && (e -= a), (null == i.max || null != i.min) && (o += a);\n      } else {\n        var r = i.autoscaleMargin;\n        null != r && (null == i.min && (e -= n * r, 0 > e && null != t.datamin && t.datamin >= 0 && (e = 0)), null == i.max && (o += n * r, o > 0 && null != t.datamax && t.datamax <= 0 && (o = 0)));\n      }\n\n      t.min = e, t.max = o;\n    }\n\n    function I(i) {\n      var e,\n          n = i.options;\n      e = \"number\" == typeof n.ticks && n.ticks > 0 ? n.ticks : 0.3 * Math.sqrt(\"x\" == i.direction ? at.width : at.height);\n      var a = (i.max - i.min) / e,\n          r = -Math.floor(Math.log(a) / Math.LN10),\n          l = n.tickDecimals;\n      null != l && r > l && (r = l);\n      var s,\n          c = Math.pow(10, -r),\n          h = a / c;\n      if (1.5 > h ? s = 1 : 3 > h ? (s = 2, h > 2.25 && (null == l || l >= r + 1) && (s = 2.5, ++r)) : s = 7.5 > h ? 5 : 10, s *= c, null != n.minTickSize && s < n.minTickSize && (s = n.minTickSize), i.delta = a, i.tickDecimals = Math.max(0, null != l ? l : r), i.tickSize = n.tickSize || s, \"time\" == n.mode && !i.tickGenerator) throw new Error(\"Time mode requires the flot.time plugin.\");\n\n      if (i.tickGenerator || (i.tickGenerator = function (t) {\n        var i,\n            e = [],\n            n = o(t.min, t.tickSize),\n            a = 0,\n            r = Number.NaN;\n\n        do {\n          i = r, r = n + a * t.tickSize, e.push(r), ++a;\n        } while (r < t.max && r != i);\n\n        return e;\n      }, i.tickFormatter = function (t, i) {\n        var e = i.tickDecimals ? Math.pow(10, i.tickDecimals) : 1,\n            o = \"\" + Math.round(t * e) / e;\n\n        if (null != i.tickDecimals) {\n          var n = o.indexOf(\".\"),\n              a = -1 == n ? 0 : o.length - n - 1;\n          if (a < i.tickDecimals) return (a ? o : o + \".\") + (\"\" + e).substr(1, i.tickDecimals - a);\n        }\n\n        return o;\n      }), t.isFunction(n.tickFormatter) && (i.tickFormatter = function (t, i) {\n        return \"\" + n.tickFormatter(t, i);\n      }), null != n.alignTicksWithAxis) {\n        var f = (\"x\" == i.direction ? ht : ft)[n.alignTicksWithAxis - 1];\n\n        if (f && f.used && f != i) {\n          var u = i.tickGenerator(i);\n\n          if (u.length > 0 && (null == n.min && (i.min = Math.min(i.min, u[0])), null == n.max && u.length > 1 && (i.max = Math.max(i.max, u[u.length - 1]))), i.tickGenerator = function (t) {\n            var i,\n                e,\n                o = [];\n\n            for (e = 0; e < f.ticks.length; ++e) {\n              i = (f.ticks[e].v - f.min) / (f.max - f.min), i = t.min + i * (t.max - t.min), o.push(i);\n            }\n\n            return o;\n          }, !i.mode && null == n.tickDecimals) {\n            var d = Math.max(0, -Math.floor(Math.log(i.delta) / Math.LN10) + 1),\n                p = i.tickGenerator(i);\n            p.length > 1 && /\\..*0$/.test((p[1] - p[0]).toFixed(d)) || (i.tickDecimals = d);\n          }\n        }\n      }\n    }\n\n    function A(i) {\n      var e = i.options.ticks,\n          o = [];\n      null == e || \"number\" == typeof e && e > 0 ? o = i.tickGenerator(i) : e && (o = t.isFunction(e) ? e(i) : e);\n      var n, a;\n\n      for (i.ticks = [], n = 0; n < o.length; ++n) {\n        var r = null,\n            l = o[n];\n        \"object\" == typeof l ? (a = +l[0], l.length > 1 && (r = l[1])) : a = +l, null == r && (r = i.tickFormatter(a, i)), isNaN(a) || i.ticks.push({\n          v: a,\n          label: r\n        });\n      }\n    }\n\n    function _(t, i) {\n      t.options.autoscaleMargin && i.length > 0 && (null == t.options.min && (t.min = Math.min(t.min, i[0].v)), null == t.options.max && i.length > 1 && (t.max = Math.max(t.max, i[i.length - 1].v)));\n    }\n\n    function F() {\n      at.clear(), l(mt.drawBackground, [st]);\n      var t = nt.grid;\n      t.show && t.backgroundColor && N(), t.show && !t.aboveData && D();\n\n      for (var i = 0; i < ot.length; ++i) {\n        l(mt.drawSeries, [st, ot[i]]), L(ot[i]);\n      }\n\n      l(mt.draw, [st]), t.show && t.aboveData && D(), at.render(), U();\n    }\n\n    function P(t, i) {\n      for (var e, o, n, a, r = d(), l = 0; l < r.length; ++l) {\n        if (e = r[l], e.direction == i && (a = i + e.n + \"axis\", t[a] || 1 != e.n || (a = i + \"axis\"), t[a])) {\n          o = t[a].from, n = t[a].to;\n          break;\n        }\n      }\n\n      if (t[a] || (e = \"x\" == i ? ht[0] : ft[0], o = t[i + \"1\"], n = t[i + \"2\"]), null != o && null != n && o > n) {\n        var s = o;\n        o = n, n = s;\n      }\n\n      return {\n        from: o,\n        to: n,\n        axis: e\n      };\n    }\n\n    function N() {\n      st.save(), st.translate(ut.left, ut.top), st.fillStyle = et(nt.grid.backgroundColor, pt, 0, \"rgba(255, 255, 255, 0)\"), st.fillRect(0, 0, dt, pt), st.restore();\n    }\n\n    function D() {\n      var i, e, o, n;\n      st.save(), st.translate(ut.left, ut.top);\n      var a = nt.grid.markings;\n      if (a) for (t.isFunction(a) && (e = gt.getAxes(), e.xmin = e.xaxis.min, e.xmax = e.xaxis.max, e.ymin = e.yaxis.min, e.ymax = e.yaxis.max, a = a(e)), i = 0; i < a.length; ++i) {\n        var r = a[i],\n            l = P(r, \"x\"),\n            s = P(r, \"y\");\n\n        if (null == l.from && (l.from = l.axis.min), null == l.to && (l.to = l.axis.max), null == s.from && (s.from = s.axis.min), null == s.to && (s.to = s.axis.max), !(l.to < l.axis.min || l.from > l.axis.max || s.to < s.axis.min || s.from > s.axis.max)) {\n          l.from = Math.max(l.from, l.axis.min), l.to = Math.min(l.to, l.axis.max), s.from = Math.max(s.from, s.axis.min), s.to = Math.min(s.to, s.axis.max);\n          var c = l.from === l.to,\n              h = s.from === s.to;\n          if (!c || !h) if (l.from = Math.floor(l.axis.p2c(l.from)), l.to = Math.floor(l.axis.p2c(l.to)), s.from = Math.floor(s.axis.p2c(s.from)), s.to = Math.floor(s.axis.p2c(s.to)), c || h) {\n            var f = r.lineWidth || nt.grid.markingsLineWidth,\n                u = f % 2 ? 0.5 : 0;\n            st.beginPath(), st.strokeStyle = r.color || nt.grid.markingsColor, st.lineWidth = f, c ? (st.moveTo(l.to + u, s.from), st.lineTo(l.to + u, s.to)) : (st.moveTo(l.from, s.to + u), st.lineTo(l.to, s.to + u)), st.stroke();\n          } else st.fillStyle = r.color || nt.grid.markingsColor, st.fillRect(l.from, s.to, l.to - l.from, s.from - s.to);\n        }\n      }\n      e = d(), o = nt.grid.borderWidth;\n\n      for (var p = 0; p < e.length; ++p) {\n        var m,\n            g,\n            x,\n            b,\n            v = e[p],\n            k = v.box,\n            y = v.tickLength;\n\n        if (v.show && 0 != v.ticks.length) {\n          for (st.lineWidth = 1, \"x\" == v.direction ? (m = 0, g = \"full\" == y ? \"top\" == v.position ? 0 : pt : k.top - ut.top + (\"top\" == v.position ? k.height : 0)) : (g = 0, m = \"full\" == y ? \"left\" == v.position ? 0 : dt : k.left - ut.left + (\"left\" == v.position ? k.width : 0)), v.innermost || (st.strokeStyle = v.options.color, st.beginPath(), x = b = 0, \"x\" == v.direction ? x = dt + 1 : b = pt + 1, 1 == st.lineWidth && (\"x\" == v.direction ? g = Math.floor(g) + 0.5 : m = Math.floor(m) + 0.5), st.moveTo(m, g), st.lineTo(m + x, g + b), st.stroke()), st.strokeStyle = v.options.tickColor, st.beginPath(), i = 0; i < v.ticks.length; ++i) {\n            var w = v.ticks[i].v;\n            x = b = 0, isNaN(w) || w < v.min || w > v.max || \"full\" == y && (\"object\" == typeof o && o[v.position] > 0 || o > 0) && (w == v.min || w == v.max) || (\"x\" == v.direction ? (m = v.p2c(w), b = \"full\" == y ? -pt : y, \"top\" == v.position && (b = -b)) : (g = v.p2c(w), x = \"full\" == y ? -dt : y, \"left\" == v.position && (x = -x)), 1 == st.lineWidth && (\"x\" == v.direction ? m = Math.floor(m) + 0.5 : g = Math.floor(g) + 0.5), st.moveTo(m, g), st.lineTo(m + x, g + b));\n          }\n\n          st.stroke();\n        }\n      }\n\n      o && (n = nt.grid.borderColor, \"object\" == typeof o || \"object\" == typeof n ? (\"object\" != typeof o && (o = {\n        top: o,\n        right: o,\n        bottom: o,\n        left: o\n      }), \"object\" != typeof n && (n = {\n        top: n,\n        right: n,\n        bottom: n,\n        left: n\n      }), o.top > 0 && (st.strokeStyle = n.top, st.lineWidth = o.top, st.beginPath(), st.moveTo(0 - o.left, 0 - o.top / 2), st.lineTo(dt, 0 - o.top / 2), st.stroke()), o.right > 0 && (st.strokeStyle = n.right, st.lineWidth = o.right, st.beginPath(), st.moveTo(dt + o.right / 2, 0 - o.top), st.lineTo(dt + o.right / 2, pt), st.stroke()), o.bottom > 0 && (st.strokeStyle = n.bottom, st.lineWidth = o.bottom, st.beginPath(), st.moveTo(dt + o.right, pt + o.bottom / 2), st.lineTo(0, pt + o.bottom / 2), st.stroke()), o.left > 0 && (st.strokeStyle = n.left, st.lineWidth = o.left, st.beginPath(), st.moveTo(0 - o.left / 2, pt + o.bottom), st.lineTo(0 - o.left / 2, 0), st.stroke())) : (st.lineWidth = o, st.strokeStyle = nt.grid.borderColor, st.strokeRect(-o / 2, -o / 2, dt + o, pt + o))), st.restore();\n    }\n\n    function O() {\n      t.each(d(), function (t, i) {\n        var e,\n            o,\n            n,\n            a,\n            r,\n            l = i.box,\n            s = i.direction + \"Axis \" + i.direction + i.n + \"Axis\",\n            c = \"flot-\" + i.direction + \"-axis flot-\" + i.direction + i.n + \"-axis \" + s,\n            h = i.options.font || \"flot-tick-label tickLabel\";\n        if (at.removeText(c), i.show && 0 != i.ticks.length) for (var f = 0; f < i.ticks.length; ++f) {\n          e = i.ticks[f], !e.label || e.v < i.min || e.v > i.max || (\"x\" == i.direction ? (a = \"center\", o = ut.left + i.p2c(e.v), \"bottom\" == i.position ? n = l.top + l.padding : (n = l.top + l.height - l.padding, r = \"bottom\")) : (r = \"middle\", n = ut.top + i.p2c(e.v), \"left\" == i.position ? (o = l.left + l.width - l.padding, a = \"right\") : o = l.left + l.padding), at.addText(c, o, n, e.label, h, null, null, a, r));\n        }\n      });\n    }\n\n    function L(t) {\n      t.lines.show && R(t), t.bars.show && j(t), t.points.show && B(t);\n    }\n\n    function R(t) {\n      function i(t, i, e, o, n) {\n        var a = t.points,\n            r = t.pointsize,\n            l = null,\n            s = null;\n        st.beginPath();\n\n        for (var c = r; c < a.length; c += r) {\n          var h = a[c - r],\n              f = a[c - r + 1],\n              u = a[c],\n              d = a[c + 1];\n\n          if (null != h && null != u) {\n            if (d >= f && f < n.min) {\n              if (d < n.min) continue;\n              h = (n.min - f) / (d - f) * (u - h) + h, f = n.min;\n            } else if (f >= d && d < n.min) {\n              if (f < n.min) continue;\n              u = (n.min - f) / (d - f) * (u - h) + h, d = n.min;\n            }\n\n            if (f >= d && f > n.max) {\n              if (d > n.max) continue;\n              h = (n.max - f) / (d - f) * (u - h) + h, f = n.max;\n            } else if (d >= f && d > n.max) {\n              if (f > n.max) continue;\n              u = (n.max - f) / (d - f) * (u - h) + h, d = n.max;\n            }\n\n            if (u >= h && h < o.min) {\n              if (u < o.min) continue;\n              f = (o.min - h) / (u - h) * (d - f) + f, h = o.min;\n            } else if (h >= u && u < o.min) {\n              if (h < o.min) continue;\n              d = (o.min - h) / (u - h) * (d - f) + f, u = o.min;\n            }\n\n            if (h >= u && h > o.max) {\n              if (u > o.max) continue;\n              f = (o.max - h) / (u - h) * (d - f) + f, h = o.max;\n            } else if (u >= h && u > o.max) {\n              if (h > o.max) continue;\n              d = (o.max - h) / (u - h) * (d - f) + f, u = o.max;\n            }\n\n            (h != l || f != s) && st.moveTo(o.p2c(h) + i, n.p2c(f) + e), l = u, s = d, st.lineTo(o.p2c(u) + i, n.p2c(d) + e);\n          }\n        }\n\n        st.stroke();\n      }\n\n      function e(t, i, e) {\n        for (var o = t.points, n = t.pointsize, a = Math.min(Math.max(0, e.min), e.max), r = 0, l = !1, s = 1, c = 0, h = 0; !(n > 0 && r > o.length + n);) {\n          r += n;\n          var f = o[r - n],\n              u = o[r - n + s],\n              d = o[r],\n              p = o[r + s];\n\n          if (l) {\n            if (n > 0 && null != f && null == d) {\n              h = r, n = -n, s = 2;\n              continue;\n            }\n\n            if (0 > n && r == c + n) {\n              st.fill(), l = !1, n = -n, s = 1, r = c = h + n;\n              continue;\n            }\n          }\n\n          if (null != f && null != d) {\n            if (d >= f && f < i.min) {\n              if (d < i.min) continue;\n              u = (i.min - f) / (d - f) * (p - u) + u, f = i.min;\n            } else if (f >= d && d < i.min) {\n              if (f < i.min) continue;\n              p = (i.min - f) / (d - f) * (p - u) + u, d = i.min;\n            }\n\n            if (f >= d && f > i.max) {\n              if (d > i.max) continue;\n              u = (i.max - f) / (d - f) * (p - u) + u, f = i.max;\n            } else if (d >= f && d > i.max) {\n              if (f > i.max) continue;\n              p = (i.max - f) / (d - f) * (p - u) + u, d = i.max;\n            }\n\n            if (l || (st.beginPath(), st.moveTo(i.p2c(f), e.p2c(a)), l = !0), u >= e.max && p >= e.max) st.lineTo(i.p2c(f), e.p2c(e.max)), st.lineTo(i.p2c(d), e.p2c(e.max));else if (u <= e.min && p <= e.min) st.lineTo(i.p2c(f), e.p2c(e.min)), st.lineTo(i.p2c(d), e.p2c(e.min));else {\n              var m = f,\n                  g = d;\n              p >= u && u < e.min && p >= e.min ? (f = (e.min - u) / (p - u) * (d - f) + f, u = e.min) : u >= p && p < e.min && u >= e.min && (d = (e.min - u) / (p - u) * (d - f) + f, p = e.min), u >= p && u > e.max && p <= e.max ? (f = (e.max - u) / (p - u) * (d - f) + f, u = e.max) : p >= u && p > e.max && u <= e.max && (d = (e.max - u) / (p - u) * (d - f) + f, p = e.max), f != m && st.lineTo(i.p2c(m), e.p2c(u)), st.lineTo(i.p2c(f), e.p2c(u)), st.lineTo(i.p2c(d), e.p2c(p)), d != g && (st.lineTo(i.p2c(d), e.p2c(p)), st.lineTo(i.p2c(g), e.p2c(p)));\n            }\n          }\n        }\n      }\n\n      st.save(), st.translate(ut.left, ut.top), st.lineJoin = \"round\";\n      var o = t.lines.lineWidth,\n          n = t.shadowSize;\n\n      if (o > 0 && n > 0) {\n        st.lineWidth = n, st.strokeStyle = \"rgba(0,0,0,0.1)\";\n        var a = Math.PI / 18;\n        i(t.datapoints, Math.sin(a) * (o / 2 + n / 2), Math.cos(a) * (o / 2 + n / 2), t.xaxis, t.yaxis), st.lineWidth = n / 2, i(t.datapoints, Math.sin(a) * (o / 2 + n / 4), Math.cos(a) * (o / 2 + n / 4), t.xaxis, t.yaxis);\n      }\n\n      st.lineWidth = o, st.strokeStyle = t.color;\n      var r = E(t.lines, t.color, 0, pt);\n      r && (st.fillStyle = r, e(t.datapoints, t.xaxis, t.yaxis)), o > 0 && i(t.datapoints, 0, 0, t.xaxis, t.yaxis), st.restore();\n    }\n\n    function B(t) {\n      function i(t, i, e, o, n, a, r, l) {\n        for (var s = t.points, c = t.pointsize, h = 0; h < s.length; h += c) {\n          var f = s[h],\n              u = s[h + 1];\n          null == f || f < a.min || f > a.max || u < r.min || u > r.max || (st.beginPath(), f = a.p2c(f), u = r.p2c(u) + o, \"circle\" == l ? st.arc(f, u, i, 0, n ? Math.PI : 2 * Math.PI, !1) : l(st, f, u, i, n), st.closePath(), e && (st.fillStyle = e, st.fill()), st.stroke());\n        }\n      }\n\n      st.save(), st.translate(ut.left, ut.top);\n      var e = t.points.lineWidth,\n          o = t.shadowSize,\n          n = t.points.radius,\n          a = t.points.symbol;\n\n      if (0 == e && (e = 1e-4), e > 0 && o > 0) {\n        var r = o / 2;\n        st.lineWidth = r, st.strokeStyle = \"rgba(0,0,0,0.1)\", i(t.datapoints, n, null, r + r / 2, !0, t.xaxis, t.yaxis, a), st.strokeStyle = \"rgba(0,0,0,0.2)\", i(t.datapoints, n, null, r / 2, !0, t.xaxis, t.yaxis, a);\n      }\n\n      st.lineWidth = e, st.strokeStyle = t.color, i(t.datapoints, n, E(t.points, t.color), 0, !1, t.xaxis, t.yaxis, a), st.restore();\n    }\n\n    function H(t, i, e, o, n, a, r, l, s, c, h) {\n      var f, u, d, p, m, g, x, b, v;\n      c ? (b = g = x = !0, m = !1, f = e, u = t, p = i + o, d = i + n, f > u && (v = u, u = f, f = v, m = !0, g = !1)) : (m = g = x = !0, b = !1, f = t + o, u = t + n, d = e, p = i, d > p && (v = p, p = d, d = v, b = !0, x = !1)), u < r.min || f > r.max || p < l.min || d > l.max || (f < r.min && (f = r.min, m = !1), u > r.max && (u = r.max, g = !1), d < l.min && (d = l.min, b = !1), p > l.max && (p = l.max, x = !1), f = r.p2c(f), d = l.p2c(d), u = r.p2c(u), p = l.p2c(p), a && (s.fillStyle = a(d, p), s.fillRect(f, p, u - f, d - p)), h > 0 && (m || g || x || b) && (s.beginPath(), s.moveTo(f, d), m ? s.lineTo(f, p) : s.moveTo(f, p), x ? s.lineTo(u, p) : s.moveTo(u, p), g ? s.lineTo(u, d) : s.moveTo(u, d), b ? s.lineTo(f, d) : s.moveTo(f, d), s.stroke()));\n    }\n\n    function j(t) {\n      function i(i, e, o, n, a, r) {\n        for (var l = i.points, s = i.pointsize, c = 0; c < l.length; c += s) {\n          null != l[c] && H(l[c], l[c + 1], l[c + 2], e, o, n, a, r, st, t.bars.horizontal, t.bars.lineWidth);\n        }\n      }\n\n      st.save(), st.translate(ut.left, ut.top), st.lineWidth = t.bars.lineWidth, st.strokeStyle = t.color;\n      var e;\n\n      switch (t.bars.align) {\n        case \"left\":\n          e = 0;\n          break;\n\n        case \"right\":\n          e = -t.bars.barWidth;\n          break;\n\n        default:\n          e = -t.bars.barWidth / 2;\n      }\n\n      var o = t.bars.fill ? function (i, e) {\n        return E(t.bars, t.color, i, e);\n      } : null;\n      i(t.datapoints, e, e + t.bars.barWidth, o, t.xaxis, t.yaxis), st.restore();\n    }\n\n    function E(i, e, o, n) {\n      var a = i.fill;\n      if (!a) return null;\n      if (i.fillColor) return et(i.fillColor, o, n, e);\n      var r = t.color.parse(e);\n      return r.a = \"number\" == typeof a ? a : 0.4, r.normalize(), r.toString();\n    }\n\n    function G() {\n      if (null != nt.legend.container ? t(nt.legend.container).html(\"\") : e.find(\".legend\").remove(), nt.legend.show) {\n        for (var i, o, n = [], a = [], r = !1, l = nt.legend.labelFormatter, s = 0; s < ot.length; ++s) {\n          i = ot[s], i.label && (o = l ? l(i.label, i) : i.label, o && a.push({\n            label: o,\n            color: i.color\n          }));\n        }\n\n        if (nt.legend.sorted) if (t.isFunction(nt.legend.sorted)) a.sort(nt.legend.sorted);else if (\"reverse\" == nt.legend.sorted) a.reverse();else {\n          var c = \"descending\" != nt.legend.sorted;\n          a.sort(function (t, i) {\n            return t.label == i.label ? 0 : t.label < i.label != c ? 1 : -1;\n          });\n        }\n\n        for (var s = 0; s < a.length; ++s) {\n          var h = a[s];\n          s % nt.legend.noColumns == 0 && (r && n.push(\"</tr>\"), n.push(\"<tr>\"), r = !0), n.push('<td class=\"legendColorBox\"><div style=\"' + nt.legend.labelBoxBorderColor + '\"><div style=\"border:2px solid ' + h.color + ';overflow:hidden\"></div></div></td><td class=\"legendLabel\"><span>' + h.label + \"</span></td>\");\n        }\n\n        if (r && n.push(\"</tr>\"), 0 != n.length) {\n          var f = '<table style=\"font-size:smaller;color:' + nt.grid.color + '\">' + n.join(\"\") + \"</table>\";\n          if (null != nt.legend.container) t(nt.legend.container).html(f);else {\n            var u = \"\",\n                d = nt.legend.position,\n                p = nt.legend.margin;\n            null == p[0] && (p = [p, p]), \"n\" == d.charAt(0) ? u += \"top:\" + (p[1] + ut.top) + \"px;\" : \"s\" == d.charAt(0) && (u += \"bottom:\" + (p[1] + ut.bottom) + \"px;\"), \"e\" == d.charAt(1) ? u += \"right:\" + (p[0] + ut.right) + \"px;\" : \"w\" == d.charAt(1) && (u += \"left:\" + (p[0] + ut.left) + \"px;\");\n            var m = t('<div class=\"legend\">' + f.replace('style=\"', 'style=\"position:absolute;' + u + \";\") + \"</div>\").appendTo(e);\n\n            if (0 != nt.legend.backgroundOpacity) {\n              var g = nt.legend.backgroundColor;\n              null == g && (g = nt.grid.backgroundColor, g = g && \"string\" == typeof g ? t.color.parse(g) : t.color.extract(m, \"background-color\"), g.a = 1, g = g.toString());\n              var x = m.children();\n              t('<div style=\"position:absolute;width:' + x.width() + \"px;height:\" + x.height() + \"px;\" + u + \"background-color:\" + g + ';\"> </div>').prependTo(m).css(\"opacity\", nt.legend.backgroundOpacity);\n            }\n          }\n        }\n      }\n    }\n\n    function V(t, i, e) {\n      var o,\n          n,\n          a,\n          r = nt.grid.mouseActiveRadius,\n          l = r * r + 1,\n          s = null;\n\n      for (o = ot.length - 1; o >= 0; --o) {\n        if (e(ot[o])) {\n          var c = ot[o],\n              h = c.xaxis,\n              f = c.yaxis,\n              u = c.datapoints.points,\n              d = h.c2p(t),\n              p = f.c2p(i),\n              m = r / h.scale,\n              g = r / f.scale;\n          if (a = c.datapoints.pointsize, h.options.inverseTransform && (m = Number.MAX_VALUE), f.options.inverseTransform && (g = Number.MAX_VALUE), c.lines.show || c.points.show) for (n = 0; n < u.length; n += a) {\n            var x = u[n],\n                b = u[n + 1];\n\n            if (null != x && !(x - d > m || -m > x - d || b - p > g || -g > b - p)) {\n              var v = Math.abs(h.p2c(x) - t),\n                  k = Math.abs(f.p2c(b) - i),\n                  y = v * v + k * k;\n              l > y && (l = y, s = [o, n / a]);\n            }\n          }\n\n          if (c.bars.show && !s) {\n            var w, M;\n\n            switch (c.bars.align) {\n              case \"left\":\n                w = 0;\n                break;\n\n              case \"right\":\n                w = -c.bars.barWidth;\n                break;\n\n              default:\n                w = -c.bars.barWidth / 2;\n            }\n\n            for (M = w + c.bars.barWidth, n = 0; n < u.length; n += a) {\n              var x = u[n],\n                  b = u[n + 1],\n                  C = u[n + 2];\n              null != x && (ot[o].bars.horizontal ? d <= Math.max(C, x) && d >= Math.min(C, x) && p >= b + w && b + M >= p : d >= x + w && x + M >= d && p >= Math.min(C, b) && p <= Math.max(C, b)) && (s = [o, n / a]);\n            }\n          }\n        }\n      }\n\n      return s ? (o = s[0], n = s[1], a = ot[o].datapoints.pointsize, {\n        datapoint: ot[o].datapoints.points.slice(n * a, (n + 1) * a),\n        dataIndex: n,\n        series: ot[o],\n        seriesIndex: o\n      }) : null;\n    }\n\n    function X(t) {\n      nt.grid.hoverable && Q(\"plothover\", t, function (t) {\n        return 0 != t.hoverable;\n      });\n    }\n\n    function Y(t) {\n      nt.grid.hoverable && Q(\"plothover\", t, function () {\n        return !1;\n      });\n    }\n\n    function q(t) {\n      Q(\"plotclick\", t, function (t) {\n        return 0 != t.clickable;\n      });\n    }\n\n    function Q(t, i, o) {\n      var n = lt.offset(),\n          a = i.pageX - n.left - ut.left,\n          r = i.pageY - n.top - ut.top,\n          l = p({\n        left: a,\n        top: r\n      });\n      l.pageX = i.pageX, l.pageY = i.pageY;\n      var s = V(a, r, o);\n\n      if (s && (s.pageX = parseInt(s.series.xaxis.p2c(s.datapoint[0]) + n.left + ut.left, 10), s.pageY = parseInt(s.series.yaxis.p2c(s.datapoint[1]) + n.top + ut.top, 10)), nt.grid.autoHighlight) {\n        for (var c = 0; c < xt.length; ++c) {\n          var h = xt[c];\n          h.auto != t || s && h.series == s.series && h.point[0] == s.datapoint[0] && h.point[1] == s.datapoint[1] || K(h.series, h.point);\n        }\n\n        s && $(s.series, s.datapoint, t);\n      }\n\n      e.trigger(t, [l, s]);\n    }\n\n    function U() {\n      var t = nt.interaction.redrawOverlayInterval;\n      return -1 == t ? void J() : void (bt || (bt = setTimeout(J, t)));\n    }\n\n    function J() {\n      bt = null, ct.save(), rt.clear(), ct.translate(ut.left, ut.top);\n      var t, i;\n\n      for (t = 0; t < xt.length; ++t) {\n        i = xt[t], i.series.bars.show ? it(i.series, i.point) : tt(i.series, i.point);\n      }\n\n      ct.restore(), l(mt.drawOverlay, [ct]);\n    }\n\n    function $(t, i, e) {\n      if (\"number\" == typeof t && (t = ot[t]), \"number\" == typeof i) {\n        var o = t.datapoints.pointsize;\n        i = t.datapoints.points.slice(o * i, o * (i + 1));\n      }\n\n      var n = Z(t, i);\n      -1 == n ? (xt.push({\n        series: t,\n        point: i,\n        auto: e\n      }), U()) : e || (xt[n].auto = !1);\n    }\n\n    function K(t, i) {\n      if (null == t && null == i) return xt = [], void U();\n\n      if (\"number\" == typeof t && (t = ot[t]), \"number\" == typeof i) {\n        var e = t.datapoints.pointsize;\n        i = t.datapoints.points.slice(e * i, e * (i + 1));\n      }\n\n      var o = Z(t, i);\n      -1 != o && (xt.splice(o, 1), U());\n    }\n\n    function Z(t, i) {\n      for (var e = 0; e < xt.length; ++e) {\n        var o = xt[e];\n        if (o.series == t && o.point[0] == i[0] && o.point[1] == i[1]) return e;\n      }\n\n      return -1;\n    }\n\n    function tt(i, e) {\n      var o = e[0],\n          n = e[1],\n          a = i.xaxis,\n          r = i.yaxis,\n          l = \"string\" == typeof i.highlightColor ? i.highlightColor : t.color.parse(i.color).scale(\"a\", 0.5).toString();\n\n      if (!(o < a.min || o > a.max || n < r.min || n > r.max)) {\n        var s = i.points.radius + i.points.lineWidth / 2;\n        ct.lineWidth = s, ct.strokeStyle = l;\n        var c = 1.5 * s;\n        o = a.p2c(o), n = r.p2c(n), ct.beginPath(), \"circle\" == i.points.symbol ? ct.arc(o, n, c, 0, 2 * Math.PI, !1) : i.points.symbol(ct, o, n, c, !1), ct.closePath(), ct.stroke();\n      }\n    }\n\n    function it(i, e) {\n      var o,\n          n = \"string\" == typeof i.highlightColor ? i.highlightColor : t.color.parse(i.color).scale(\"a\", 0.5).toString(),\n          a = n;\n\n      switch (i.bars.align) {\n        case \"left\":\n          o = 0;\n          break;\n\n        case \"right\":\n          o = -i.bars.barWidth;\n          break;\n\n        default:\n          o = -i.bars.barWidth / 2;\n      }\n\n      ct.lineWidth = i.bars.lineWidth, ct.strokeStyle = n, H(e[0], e[1], e[2] || 0, o, o + i.bars.barWidth, function () {\n        return a;\n      }, i.xaxis, i.yaxis, ct, i.bars.horizontal, i.bars.lineWidth);\n    }\n\n    function et(i, e, o, n) {\n      if (\"string\" == typeof i) return i;\n\n      for (var a = st.createLinearGradient(0, o, 0, e), r = 0, l = i.colors.length; l > r; ++r) {\n        var s = i.colors[r];\n\n        if (\"string\" != typeof s) {\n          var c = t.color.parse(n);\n          null != s.brightness && (c = c.scale(\"rgb\", s.brightness)), null != s.opacity && (c.a *= s.opacity), s = c.toString();\n        }\n\n        a.addColorStop(r / (l - 1), s);\n      }\n\n      return a;\n    }\n\n    var ot = [],\n        nt = {\n      colors: t.flot_colors || [\"#931313\", \"#638167\", \"#65596B\", \"#60747C\", \"#B09B5B\"],\n      legend: {\n        show: !0,\n        noColumns: t.flot_noColumns || 0,\n        labelFormatter: null,\n        labelBoxBorderColor: \"\",\n        container: null,\n        position: \"ne\",\n        margin: t.flot_margin || [-5, -32],\n        backgroundColor: t.flot_backgroundColor || \"\",\n        backgroundOpacity: t.flot_backgroundOpacity || 1,\n        sorted: null\n      },\n      xaxis: {\n        show: null,\n        position: \"bottom\",\n        mode: null,\n        font: null,\n        color: null,\n        tickColor: null,\n        transform: null,\n        inverseTransform: null,\n        min: null,\n        max: null,\n        autoscaleMargin: null,\n        ticks: null,\n        tickFormatter: null,\n        labelWidth: null,\n        labelHeight: null,\n        reserveSpace: null,\n        tickLength: null,\n        alignTicksWithAxis: null,\n        tickDecimals: null,\n        tickSize: null,\n        minTickSize: null\n      },\n      yaxis: {\n        autoscaleMargin: 0.02,\n        position: \"left\"\n      },\n      xaxes: [],\n      yaxes: [],\n      series: {\n        points: {\n          show: !1,\n          radius: 3,\n          lineWidth: 2,\n          fill: !0,\n          fillColor: \"#ffffff\",\n          symbol: \"circle\"\n        },\n        lines: {\n          lineWidth: 2,\n          fill: !1,\n          fillColor: null,\n          steps: !1\n        },\n        bars: {\n          show: !1,\n          lineWidth: t.flot_bars_lineWidth || 1,\n          barWidth: 1,\n          fill: !0,\n          fillColor: t.flot_bars_fillColor || {\n            colors: [{\n              opacity: 0.7\n            }, {\n              opacity: 1\n            }]\n          },\n          align: \"left\",\n          horizontal: !1,\n          zero: !0\n        },\n        shadowSize: t.flot_shadowSize || 0,\n        highlightColor: null\n      },\n      grid: {\n        show: !0,\n        aboveData: !1,\n        color: t.flot_grid_color || \"#545454\",\n        backgroundColor: null,\n        borderColor: t.flot_grid_borderColor || \"#efefef\",\n        tickColor: t.flot_grid_tickColor || \"rgba(0,0,0,0.06)\",\n        margin: 0,\n        labelMargin: t.flot_grid_labelMargin || 10,\n        axisMargin: 8,\n        borderWidth: t.flot_grid_borderWidth || 0,\n        minBorderMargin: t.flot_grid_minBorderMargin || 10,\n        markings: null,\n        markingsColor: \"#f4f4f4\",\n        markingsLineWidth: 2,\n        clickable: !1,\n        hoverable: !1,\n        autoHighlight: !0,\n        mouseActiveRadius: t.flot_grid_mouseActiveRadius || 5\n      },\n      interaction: {\n        redrawOverlayInterval: 1e3 / 60\n      },\n      hooks: {}\n    },\n        at = null,\n        rt = null,\n        lt = null,\n        st = null,\n        ct = null,\n        ht = [],\n        ft = [],\n        ut = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n        dt = 0,\n        pt = 0,\n        mt = {\n      processOptions: [],\n      processRawData: [],\n      processDatapoints: [],\n      processOffset: [],\n      drawBackground: [],\n      drawSeries: [],\n      draw: [],\n      bindEvents: [],\n      drawOverlay: [],\n      shutdown: []\n    },\n        gt = this;\n    gt.setData = h, gt.setupGrid = S, gt.draw = F, gt.getPlaceholder = function () {\n      return e;\n    }, gt.getCanvas = function () {\n      return at.element;\n    }, gt.getPlotOffset = function () {\n      return ut;\n    }, gt.width = function () {\n      return dt;\n    }, gt.height = function () {\n      return pt;\n    }, gt.offset = function () {\n      var t = lt.offset();\n      return t.left += ut.left, t.top += ut.top, t;\n    }, gt.getData = function () {\n      return ot;\n    }, gt.getAxes = function () {\n      var i = {};\n      return t.each(ht.concat(ft), function (t, e) {\n        e && (i[e.direction + (1 != e.n ? e.n : \"\") + \"axis\"] = e);\n      }), i;\n    }, gt.getXAxes = function () {\n      return ht;\n    }, gt.getYAxes = function () {\n      return ft;\n    }, gt.c2p = p, gt.p2c = m, gt.getOptions = function () {\n      return nt;\n    }, gt.highlight = $, gt.unhighlight = K, gt.triggerRedrawOverlay = U, gt.pointOffset = function (t) {\n      return {\n        left: parseInt(ht[u(t, \"x\") - 1].p2c(+t.x) + ut.left, 10),\n        top: parseInt(ft[u(t, \"y\") - 1].p2c(+t.y) + ut.top, 10)\n      };\n    }, gt.shutdown = y, gt.destroy = function () {\n      y(), e.removeData(\"plot\").empty(), ot = [], nt = null, at = null, rt = null, lt = null, st = null, ct = null, ht = [], ft = [], mt = null, xt = [], gt = null;\n    }, gt.resize = function () {\n      var t = e.width(),\n          i = e.height();\n      at.resize(t, i), rt.resize(t, i);\n    }, gt.hooks = mt, s(gt), c(a), v(), h(n), S(), F(), k();\n    var xt = [],\n        bt = null;\n  }\n\n  function o(t, i) {\n    return i * Math.floor(t / i);\n  }\n\n  var n = Object.prototype.hasOwnProperty;\n  t.fn.detach || (t.fn.detach = function () {\n    return this.each(function () {\n      this.parentNode && this.parentNode.removeChild(this);\n    });\n  }), i.prototype.resize = function (t, i) {\n    if (0 >= t || 0 >= i) throw new Error(\"Invalid dimensions for plot, width = \" + t + \", height = \" + i);\n    var e = this.element,\n        o = this.context,\n        n = this.pixelRatio;\n    this.width != t && (e.width = t * n, e.style.width = t + \"px\", this.width = t), this.height != i && (e.height = i * n, e.style.height = i + \"px\", this.height = i), o.restore(), o.save(), o.scale(n, n);\n  }, i.prototype.clear = function () {\n    this.context.clearRect(0, 0, this.width, this.height);\n  }, i.prototype.render = function () {\n    var t = this._textCache;\n\n    for (var i in t) {\n      if (n.call(t, i)) {\n        var e = this.getTextLayer(i),\n            o = t[i];\n        e.hide();\n\n        for (var a in o) {\n          if (n.call(o, a)) {\n            var r = o[a];\n\n            for (var l in r) {\n              if (n.call(r, l)) {\n                for (var s, c = r[l].positions, h = 0; s = c[h]; h++) {\n                  s.active ? s.rendered || (e.append(s.element), s.rendered = !0) : (c.splice(h--, 1), s.rendered && s.element.detach());\n                }\n\n                0 == c.length && delete r[l];\n              }\n            }\n          }\n        }\n\n        e.show();\n      }\n    }\n  }, i.prototype.getTextLayer = function (i) {\n    var e = this.text[i];\n    return null == e && (null == this.textContainer && (this.textContainer = t(\"<div class='flot-text'></div>\").css({\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      bottom: 0,\n      right: 0,\n      \"font-size\": \"smaller\",\n      color: \"#545454\"\n    }).insertAfter(this.element)), e = this.text[i] = t(\"<div></div>\").addClass(i).css({\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      bottom: 0,\n      right: 0\n    }).appendTo(this.textContainer)), e;\n  }, i.prototype.getTextInfo = function (i, e, o, n, a) {\n    var r, l, s, c;\n\n    if (e = \"\" + e, r = \"object\" == typeof o ? o.style + \" \" + o.variant + \" \" + o.weight + \" \" + o.size + \"px/\" + o.lineHeight + \"px \" + o.family : o, l = this._textCache[i], null == l && (l = this._textCache[i] = {}), s = l[r], null == s && (s = l[r] = {}), c = s[e], null == c) {\n      var h = t(\"<div></div>\").html(e).css({\n        position: \"absolute\",\n        \"max-width\": a,\n        top: -9999\n      }).appendTo(this.getTextLayer(i));\n      \"object\" == typeof o ? h.css({\n        font: r,\n        color: o.color\n      }) : \"string\" == typeof o && h.addClass(o), c = s[e] = {\n        width: h.outerWidth(!0),\n        height: h.outerHeight(!0),\n        element: h,\n        positions: []\n      }, h.detach();\n    }\n\n    return c;\n  }, i.prototype.addText = function (t, i, e, o, n, a, r, l, s) {\n    var c = this.getTextInfo(t, o, n, a, r),\n        h = c.positions;\n    \"center\" == l ? i -= c.width / 2 : \"right\" == l && (i -= c.width), \"middle\" == s ? e -= c.height / 2 : \"bottom\" == s && (e -= c.height);\n\n    for (var f, u = 0; f = h[u]; u++) {\n      if (f.x == i && f.y == e) return void (f.active = !0);\n    }\n\n    f = {\n      active: !0,\n      rendered: !1,\n      element: h.length ? c.element.clone() : c.element,\n      x: i,\n      y: e\n    }, h.push(f), f.element.css({\n      top: Math.round(e),\n      left: Math.round(i),\n      \"text-align\": l\n    });\n  }, i.prototype.removeText = function (t, i, e, o, a, r) {\n    if (null == o) {\n      var l = this._textCache[t];\n      if (null != l) for (var s in l) {\n        if (n.call(l, s)) {\n          var c = l[s];\n\n          for (var h in c) {\n            if (n.call(c, h)) for (var f, u = c[h].positions, d = 0; f = u[d]; d++) {\n              f.active = !1;\n            }\n          }\n        }\n      }\n    } else for (var f, u = this.getTextInfo(t, o, a, r).positions, d = 0; f = u[d]; d++) {\n      f.x == i && f.y == e && (f.active = !1);\n    }\n  }, t.plot = function (i, o, n) {\n    var a = new e(t(i), o, n, t.plot.plugins);\n    return a;\n  }, t.plot.version = \"0.8.3\", t.plot.plugins = [], t.fn.plot = function (i, e) {\n    return this.each(function () {\n      t.plot(this, i, e);\n    });\n  };\n}(jQuery);\n!function (e, t, n) {\n  \"$:nomunge\";\n\n  function i(n) {\n    u === !0 && (u = n || 1);\n\n    for (var s = r.length - 1; s >= 0; s--) {\n      var c = e(r[s]);\n\n      if (c[0] == t || c.is(\":visible\")) {\n        var d = c.width(),\n            f = c.height(),\n            v = c.data(m);\n        !v || d === v.w && f === v.h || (c.trigger(h, [v.w = d, v.h = f]), u = n || !0);\n      } else v = c.data(m), v.w = 0, v.h = 0;\n    }\n\n    null !== a && (u && (null == n || 1e3 > n - u) ? a = t.requestAnimationFrame(i) : (a = setTimeout(i, o[l]), u = !1));\n  }\n\n  var a,\n      r = [],\n      o = e.resize = e.extend(e.resize, {}),\n      u = !1,\n      s = \"setTimeout\",\n      h = \"resize\",\n      m = h + \"-special-event\",\n      l = \"pendingDelay\",\n      c = \"activeDelay\",\n      d = \"throttleWindow\";\n  o[l] = 200, o[c] = 20, o[d] = !0, e.event.special[h] = {\n    setup: function setup() {\n      if (!o[d] && this[s]) return !1;\n      var t = e(this);\n      r.push(this), t.data(m, {\n        w: t.width(),\n        h: t.height()\n      }), 1 === r.length && (a = n, i());\n    },\n    teardown: function teardown() {\n      if (!o[d] && this[s]) return !1;\n\n      for (var t = e(this), n = r.length - 1; n >= 0; n--) {\n        if (r[n] == this) {\n          r.splice(n, 1);\n          break;\n        }\n      }\n\n      t.removeData(m), r.length || (u ? cancelAnimationFrame(a) : clearTimeout(a), a = null);\n    },\n    add: function add(t) {\n      function i(t, i, r) {\n        var o = e(this),\n            u = o.data(m) || {};\n        u.w = i !== n ? i : o.width(), u.h = r !== n ? r : o.height(), a.apply(this, arguments);\n      }\n\n      if (!o[d] && this[s]) return !1;\n      var a;\n      return e.isFunction(t) ? (a = t, i) : (a = t.handler, void (t.handler = i));\n    }\n  }, t.requestAnimationFrame || (t.requestAnimationFrame = function () {\n    return t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || t.oRequestAnimationFrame || t.msRequestAnimationFrame || function (e) {\n      return t.setTimeout(function () {\n        e(new Date().getTime());\n      }, o[c]);\n    };\n  }()), t.cancelAnimationFrame || (t.cancelAnimationFrame = function () {\n    return t.webkitCancelRequestAnimationFrame || t.mozCancelRequestAnimationFrame || t.oCancelRequestAnimationFrame || t.msCancelRequestAnimationFrame || clearTimeout;\n  }());\n}(jQuery, window), function (e) {\n  function t(e) {\n    function t() {\n      var t = e.getPlaceholder();\n      0 != t.width() && 0 != t.height() && (e.resize(), e.setupGrid(), e.draw());\n    }\n\n    function n(e) {\n      e.getPlaceholder().resize(t);\n    }\n\n    function i(e) {\n      e.getPlaceholder().unbind(\"resize\", t);\n    }\n\n    e.hooks.bindEvents.push(n), e.hooks.shutdown.push(i);\n  }\n\n  var n = {};\n  e.plot.plugins.push({\n    init: t,\n    options: n,\n    name: \"resize\",\n    version: \"1.0\"\n  });\n}(jQuery);\n!function (e) {\n  function n(e) {\n    function n(e, n) {\n      var l;\n\n      for (l = 0; l < n.length; ++l) {\n        if (n[l].id === e.fillBetween) return n[l];\n      }\n\n      return \"number\" == typeof e.fillBetween ? e.fillBetween < 0 || e.fillBetween >= n.length ? null : n[e.fillBetween] : null;\n    }\n\n    function l(e, l, i) {\n      if (null != l.fillBetween) {\n        var t = n(l, e.getData());\n\n        if (t) {\n          for (var s, f, o, u, p, r, h, a, g = i.pointsize, w = i.points, B = t.datapoints.pointsize, c = t.datapoints.points, v = [], d = l.lines.show, m = g > 2 && i.format[2].y, y = d && l.lines.steps, b = !0, z = 0, D = 0; !(z >= w.length);) {\n            if (h = v.length, null == w[z]) {\n              for (a = 0; g > a; ++a) {\n                v.push(w[z + a]);\n              }\n\n              z += g;\n            } else if (D >= c.length) {\n              if (!d) for (a = 0; g > a; ++a) {\n                v.push(w[z + a]);\n              }\n              z += g;\n            } else if (null == c[D]) {\n              for (a = 0; g > a; ++a) {\n                v.push(null);\n              }\n\n              b = !0, D += B;\n            } else {\n              if (s = w[z], f = w[z + 1], u = c[D], p = c[D + 1], r = 0, s === u) {\n                for (a = 0; g > a; ++a) {\n                  v.push(w[z + a]);\n                }\n\n                r = p, z += g, D += B;\n              } else if (s > u) {\n                if (d && z > 0 && null != w[z - g]) {\n                  for (o = f + (w[z - g + 1] - f) * (u - s) / (w[z - g] - s), v.push(u), v.push(o), a = 2; g > a; ++a) {\n                    v.push(w[z + a]);\n                  }\n\n                  r = p;\n                }\n\n                D += B;\n              } else {\n                if (b && d) {\n                  z += g;\n                  continue;\n                }\n\n                for (a = 0; g > a; ++a) {\n                  v.push(w[z + a]);\n                }\n\n                d && D > 0 && null != c[D - B] && (r = p + (c[D - B + 1] - p) * (s - u) / (c[D - B] - u)), z += g;\n              }\n\n              b = !1, h !== v.length && m && (v[h + 2] = r);\n            }\n\n            if (y && h !== v.length && h > 0 && null !== v[h] && v[h] !== v[h - g] && v[h + 1] !== v[h - g + 1]) {\n              for (a = 0; g > a; ++a) {\n                v[h + g + a] = v[h + a];\n              }\n\n              v[h + 1] = v[h - g + 1];\n            }\n          }\n\n          i.points = v;\n        }\n      }\n    }\n\n    e.hooks.processDatapoints.push(l);\n  }\n\n  var l = {\n    series: {\n      fillBetween: null\n    }\n  };\n  e.plot.plugins.push({\n    init: n,\n    options: l,\n    name: \"fillbetween\",\n    version: \"1.0\"\n  });\n}(jQuery);\n!function (r) {\n  function n(r) {\n    function n(r, n, e) {\n      var i = null;\n\n      if (t(n) && (l(n), a(r), o(r), s(n), v >= 2)) {\n        var u = h(n),\n            p = 0,\n            w = f();\n        p = c(u) ? -1 * d(g, u - 1, Math.floor(v / 2) - 1) - w : d(g, Math.ceil(v / 2), u - 2) + w + 2 * W, i = b(e, n, p), e.points = i;\n      }\n\n      return i;\n    }\n\n    function t(r) {\n      return null != r.bars && r.bars.show && null != r.bars.order;\n    }\n\n    function a(r) {\n      var n = D ? r.getPlaceholder().innerHeight() : r.getPlaceholder().innerWidth(),\n          t = D ? e(r.getData(), 1) : e(r.getData(), 0),\n          a = t[1] - t[0];\n      w = a / n;\n    }\n\n    function e(r, n) {\n      for (var t = new Array(), a = 0; a < r.length; a++) {\n        t[0] = r[a].data[0][n], t[1] = r[a].data[r[a].data.length - 1][n];\n      }\n\n      return t;\n    }\n\n    function o(r) {\n      g = i(r.getData()), v = g.length;\n    }\n\n    function i(r) {\n      for (var n = new Array(), t = 0; t < r.length; t++) {\n        null != r[t].bars.order && r[t].bars.show && n.push(r[t]);\n      }\n\n      return n.sort(u);\n    }\n\n    function u(r, n) {\n      var t = r.bars.order,\n          a = n.bars.order;\n      return a > t ? -1 : t > a ? 1 : 0;\n    }\n\n    function s(r) {\n      p = r.bars.lineWidth ? r.bars.lineWidth : 2, W = p * w;\n    }\n\n    function l(r) {\n      r.bars.horizontal && (D = !0);\n    }\n\n    function h(r) {\n      for (var n = 0, t = 0; t < g.length; ++t) {\n        if (r == g[t]) {\n          n = t;\n          break;\n        }\n      }\n\n      return n + 1;\n    }\n\n    function f() {\n      var r = 0;\n      return v % 2 != 0 && (r = g[Math.ceil(v / 2)].bars.barWidth / 2), r;\n    }\n\n    function c(r) {\n      return r <= Math.ceil(v / 2);\n    }\n\n    function d(r, n, t) {\n      for (var a = 0, e = n; t >= e; e++) {\n        a += r[e].bars.barWidth + 2 * W;\n      }\n\n      return a;\n    }\n\n    function b(r, n, t) {\n      for (var a = r.pointsize, e = r.points, o = 0, i = D ? 1 : 0; i < e.length; i += a) {\n        e[i] += t, n.data[o][3] = e[i], o++;\n      }\n\n      return e;\n    }\n\n    var g,\n        v,\n        p,\n        W,\n        w = 1,\n        D = !1;\n    r.hooks.processDatapoints.push(n);\n  }\n\n  var t = {\n    series: {\n      bars: {\n        order: null\n      }\n    }\n  };\n  r.plot.plugins.push({\n    init: n,\n    options: t,\n    name: \"orderBars\",\n    version: \"0.2\"\n  });\n}(jQuery);\n!function (e) {\n  function i(i) {\n    function r(i) {\n      y || (y = !0, b = i.getCanvas(), w = e(b).parent(), k = i.getOptions(), i.setData(a(i.getData())));\n    }\n\n    function a(i) {\n      for (var s = 0, t = 0, r = 0, a = k.series.pie.combine.color, l = [], n = 0; n < i.length; ++n) {\n        var o = i[n].data;\n        e.isArray(o) && 1 == o.length && (o = o[0]), e.isArray(o) ? o[1] = !isNaN(parseFloat(o[1])) && isFinite(o[1]) ? +o[1] : 0 : o = !isNaN(parseFloat(o)) && isFinite(o) ? [1, +o] : [1, 0], i[n].data = [o];\n      }\n\n      for (var n = 0; n < i.length; ++n) {\n        s += i[n].data[0][1];\n      }\n\n      for (var n = 0; n < i.length; ++n) {\n        var o = i[n].data[0][1];\n        o / s <= k.series.pie.combine.threshold && (t += o, r++, a || (a = i[n].color));\n      }\n\n      for (var n = 0; n < i.length; ++n) {\n        var o = i[n].data[0][1];\n        (2 > r || o / s > k.series.pie.combine.threshold) && l.push(e.extend(i[n], {\n          data: [[1, o]],\n          color: i[n].color,\n          label: i[n].label,\n          angle: o * Math.PI * 2 / s,\n          percent: o / (s / 100)\n        }));\n      }\n\n      return r > 1 && l.push({\n        data: [[1, t]],\n        color: a,\n        label: k.series.pie.combine.label,\n        angle: t * Math.PI * 2 / s,\n        percent: t / (s / 100)\n      }), l;\n    }\n\n    function l(i, r) {\n      function a() {\n        m.clearRect(0, 0, p, h), w.children().filter(\".pieLabel, .pieLabelBackground\").remove();\n      }\n\n      function l() {\n        var e = k.series.pie.shadow.left,\n            i = k.series.pie.shadow.top,\n            s = 10,\n            t = k.series.pie.shadow.alpha,\n            r = k.series.pie.radius > 1 ? k.series.pie.radius : M * k.series.pie.radius;\n\n        if (!(r >= p / 2 - e || r * k.series.pie.tilt >= h / 2 - i || s >= r)) {\n          m.save(), m.translate(e, i), m.globalAlpha = t, m.fillStyle = \"#000\", m.translate(P, A), m.scale(1, k.series.pie.tilt);\n\n          for (var a = 1; s >= a; a++) {\n            m.beginPath(), m.arc(0, 0, r, 0, 2 * Math.PI, !1), m.fill(), r -= a;\n          }\n\n          m.restore();\n        }\n      }\n\n      function o() {\n        function i(e, i, s) {\n          0 >= e || isNaN(e) || (s ? m.fillStyle = i : (m.strokeStyle = i, m.lineJoin = \"round\"), m.beginPath(), Math.abs(e - 2 * Math.PI) > 1e-9 && m.moveTo(0, 0), m.arc(0, 0, r, a, a + e / 2, !1), m.arc(0, 0, r, a + e / 2, a + e, !1), m.closePath(), a += e, s ? m.fill() : m.stroke());\n        }\n\n        function s() {\n          function i(i, s, t) {\n            if (0 == i.data[0][1]) return !0;\n            var a,\n                l = k.legend.labelFormatter,\n                n = k.series.pie.label.formatter;\n            a = l ? l(i.label, i) : i.label, n && (a = n(a, i));\n            var o = (s + i.angle + s) / 2,\n                g = P + Math.round(Math.cos(o) * r),\n                c = A + Math.round(Math.sin(o) * r) * k.series.pie.tilt,\n                u = \"<span class='pieLabel' id='pieLabel\" + t + \"' style='position:absolute;top:\" + c + \"px;left:\" + g + \"px;'>\" + a + \"</span>\";\n            w.append(u);\n            var d = w.children(\"#pieLabel\" + t),\n                f = c - d.height() / 2,\n                v = g - d.width() / 2;\n            if (d.css(\"top\", f), d.css(\"left\", v), 0 - f > 0 || 0 - v > 0 || h - (f + d.height()) < 0 || p - (v + d.width()) < 0) return !1;\n\n            if (0 != k.series.pie.label.background.opacity) {\n              var b = k.series.pie.label.background.color;\n              null == b && (b = i.color);\n              var M = \"top:\" + f + \"px;left:\" + v + \"px;\";\n              e(\"<div class='pieLabelBackground' style='position:absolute;width:\" + d.width() + \"px;height:\" + d.height() + \"px;\" + M + \"background-color:\" + b + \";'></div>\").css(\"opacity\", k.series.pie.label.background.opacity).insertBefore(d);\n            }\n\n            return !0;\n          }\n\n          for (var s = t, r = k.series.pie.label.radius > 1 ? k.series.pie.label.radius : M * k.series.pie.label.radius, a = 0; a < c.length; ++a) {\n            if (c[a].percent >= 100 * k.series.pie.label.threshold && !i(c[a], s, a)) return !1;\n            s += c[a].angle;\n          }\n\n          return !0;\n        }\n\n        var t = Math.PI * k.series.pie.startAngle,\n            r = k.series.pie.radius > 1 ? k.series.pie.radius : M * k.series.pie.radius;\n        m.save(), m.translate(P, A), m.scale(1, k.series.pie.tilt), m.save();\n\n        for (var a = t, l = 0; l < c.length; ++l) {\n          c[l].startAngle = a, i(c[l].angle, c[l].color, !0);\n        }\n\n        if (m.restore(), k.series.pie.stroke.width > 0) {\n          m.save(), m.lineWidth = k.series.pie.stroke.width, a = t;\n\n          for (var l = 0; l < c.length; ++l) {\n            i(c[l].angle, k.series.pie.stroke.color, !1);\n          }\n\n          m.restore();\n        }\n\n        return n(m), m.restore(), !k.series.pie.label.show || s();\n      }\n\n      if (w) {\n        var p = i.getPlaceholder().width(),\n            h = i.getPlaceholder().height(),\n            g = w.children().filter(\".legend\").children().width() || 0;\n        m = r, y = !1, M = Math.min(p, h / k.series.pie.tilt) / 2, A = h / 2 + k.series.pie.offset.top, P = p / 2, \"auto\" == k.series.pie.offset.left ? (k.legend.position.match(\"w\") ? P += g / 2 : P -= g / 2, M > P ? P = M : P > p - M && (P = p - M)) : P += k.series.pie.offset.left;\n        var c = i.getData(),\n            u = 0;\n\n        do {\n          u > 0 && (M *= t), u += 1, a(), k.series.pie.tilt <= 0.8 && l();\n        } while (!o() && s > u);\n\n        u >= s && (a(), w.prepend(\"<div class='error'>Could not draw pie with labels contained inside canvas</div>\")), i.setSeries && i.insertLegend && (i.setSeries(c), i.insertLegend());\n      }\n    }\n\n    function n(e) {\n      if (k.series.pie.innerRadius > 0) {\n        e.save();\n        var i = k.series.pie.innerRadius > 1 ? k.series.pie.innerRadius : M * k.series.pie.innerRadius;\n        e.globalCompositeOperation = \"destination-out\", e.beginPath(), e.fillStyle = k.series.pie.stroke.color, e.arc(0, 0, i, 0, 2 * Math.PI, !1), e.fill(), e.closePath(), e.restore(), e.save(), e.beginPath(), e.strokeStyle = k.series.pie.stroke.color, e.arc(0, 0, i, 0, 2 * Math.PI, !1), e.stroke(), e.closePath(), e.restore();\n      }\n    }\n\n    function o(e, i) {\n      for (var s = !1, t = -1, r = e.length, a = r - 1; ++t < r; a = t) {\n        (e[t][1] <= i[1] && i[1] < e[a][1] || e[a][1] <= i[1] && i[1] < e[t][1]) && i[0] < (e[a][0] - e[t][0]) * (i[1] - e[t][1]) / (e[a][1] - e[t][1]) + e[t][0] && (s = !s);\n      }\n\n      return s;\n    }\n\n    function p(e, s) {\n      for (var t, r, a = i.getData(), l = i.getOptions(), n = l.series.pie.radius > 1 ? l.series.pie.radius : M * l.series.pie.radius, p = 0; p < a.length; ++p) {\n        var h = a[p];\n\n        if (h.pie.show) {\n          if (m.save(), m.beginPath(), m.moveTo(0, 0), m.arc(0, 0, n, h.startAngle, h.startAngle + h.angle / 2, !1), m.arc(0, 0, n, h.startAngle + h.angle / 2, h.startAngle + h.angle, !1), m.closePath(), t = e - P, r = s - A, m.isPointInPath) {\n            if (m.isPointInPath(e - P, s - A)) return m.restore(), {\n              datapoint: [h.percent, h.data],\n              dataIndex: 0,\n              series: h,\n              seriesIndex: p\n            };\n          } else {\n            var g = n * Math.cos(h.startAngle),\n                c = n * Math.sin(h.startAngle),\n                u = n * Math.cos(h.startAngle + h.angle / 4),\n                d = n * Math.sin(h.startAngle + h.angle / 4),\n                f = n * Math.cos(h.startAngle + h.angle / 2),\n                v = n * Math.sin(h.startAngle + h.angle / 2),\n                b = n * Math.cos(h.startAngle + h.angle / 1.5),\n                w = n * Math.sin(h.startAngle + h.angle / 1.5),\n                k = n * Math.cos(h.startAngle + h.angle),\n                y = n * Math.sin(h.startAngle + h.angle),\n                I = [[0, 0], [g, c], [u, d], [f, v], [b, w], [k, y]],\n                x = [t, r];\n            if (o(I, x)) return m.restore(), {\n              datapoint: [h.percent, h.data],\n              dataIndex: 0,\n              series: h,\n              seriesIndex: p\n            };\n          }\n\n          m.restore();\n        }\n      }\n\n      return null;\n    }\n\n    function h(e) {\n      c(\"plothover\", e);\n    }\n\n    function g(e) {\n      c(\"plotclick\", e);\n    }\n\n    function c(e, s) {\n      var t = i.offset(),\n          r = parseInt(s.pageX - t.left),\n          a = parseInt(s.pageY - t.top),\n          l = p(r, a);\n      if (k.grid.autoHighlight) for (var n = 0; n < I.length; ++n) {\n        var o = I[n];\n        o.auto != e || l && o.series == l.series || d(o.series);\n      }\n      l && u(l.series, e);\n      var h = {\n        pageX: s.pageX,\n        pageY: s.pageY\n      };\n      w.trigger(e, [h, l]);\n    }\n\n    function u(e, s) {\n      var t = f(e);\n      -1 == t ? (I.push({\n        series: e,\n        auto: s\n      }), i.triggerRedrawOverlay()) : s || (I[t].auto = !1);\n    }\n\n    function d(e) {\n      null == e && (I = [], i.triggerRedrawOverlay());\n      var s = f(e);\n      -1 != s && (I.splice(s, 1), i.triggerRedrawOverlay());\n    }\n\n    function f(e) {\n      for (var i = 0; i < I.length; ++i) {\n        var s = I[i];\n        if (s.series == e) return i;\n      }\n\n      return -1;\n    }\n\n    function v(e, i) {\n      function s(e) {\n        e.angle <= 0 || isNaN(e.angle) || (i.fillStyle = \"rgba(255, 255, 255, \" + t.series.pie.highlight.opacity + \")\", i.beginPath(), Math.abs(e.angle - 2 * Math.PI) > 1e-9 && i.moveTo(0, 0), i.arc(0, 0, r, e.startAngle, e.startAngle + e.angle / 2, !1), i.arc(0, 0, r, e.startAngle + e.angle / 2, e.startAngle + e.angle, !1), i.closePath(), i.fill());\n      }\n\n      var t = e.getOptions(),\n          r = t.series.pie.radius > 1 ? t.series.pie.radius : M * t.series.pie.radius;\n      i.save(), i.translate(P, A), i.scale(1, t.series.pie.tilt);\n\n      for (var a = 0; a < I.length; ++a) {\n        s(I[a].series);\n      }\n\n      n(i), i.restore();\n    }\n\n    var b = null,\n        w = null,\n        k = null,\n        M = null,\n        P = null,\n        A = null,\n        y = !1,\n        m = null,\n        I = [];\n    i.hooks.processOptions.push(function (e, i) {\n      i.series.pie.show && (i.grid.show = !1, \"auto\" == i.series.pie.label.show && (i.series.pie.label.show = !i.legend.show), \"auto\" == i.series.pie.radius && (i.series.pie.radius = i.series.pie.label.show ? 0.75 : 1), i.series.pie.tilt > 1 ? i.series.pie.tilt = 1 : i.series.pie.tilt < 0 && (i.series.pie.tilt = 0));\n    }), i.hooks.bindEvents.push(function (e, i) {\n      var s = e.getOptions();\n      s.series.pie.show && (s.grid.hoverable && i.unbind(\"mousemove\").mousemove(h), s.grid.clickable && i.unbind(\"click\").click(g));\n    }), i.hooks.processDatapoints.push(function (e, i, s, t) {\n      var a = e.getOptions();\n      a.series.pie.show && r(e, i, s, t);\n    }), i.hooks.drawOverlay.push(function (e, i) {\n      var s = e.getOptions();\n      s.series.pie.show && v(e, i);\n    }), i.hooks.draw.push(function (e, i) {\n      var s = e.getOptions();\n      s.series.pie.show && l(e, i);\n    });\n  }\n\n  var s = 10,\n      t = 0.95,\n      r = {\n    series: {\n      pie: {\n        show: !1,\n        radius: \"auto\",\n        innerRadius: 0,\n        startAngle: 1.5,\n        tilt: 1,\n        shadow: {\n          left: 5,\n          top: 15,\n          alpha: 0.02\n        },\n        offset: {\n          top: 0,\n          left: \"auto\"\n        },\n        stroke: {\n          color: \"#fff\",\n          width: 1\n        },\n        label: {\n          show: \"auto\",\n          formatter: function formatter(e, i) {\n            return \"<div style='font-size:x-small;text-align:center;padding:2px;color:\" + i.color + \";'>\" + e + \"<br/>\" + Math.round(i.percent) + \"%</div>\";\n          },\n          radius: 1,\n          background: {\n            color: null,\n            opacity: 0\n          },\n          threshold: 0\n        },\n        combine: {\n          threshold: -1,\n          color: null,\n          label: \"Other\"\n        },\n        highlight: {\n          opacity: 0.5\n        }\n      }\n    }\n  };\n  e.plot.plugins.push({\n    init: i,\n    options: r,\n    name: \"pie\",\n    version: \"1.1\"\n  });\n}(jQuery);\n!function (e) {\n  function t(e, t) {\n    return t * Math.floor(e / t);\n  }\n\n  function n(e, t, n, r) {\n    if (\"function\" == typeof e.strftime) return e.strftime(t);\n\n    var a = function a(e, t) {\n      return e = \"\" + e, t = \"\" + (null == t ? \"0\" : t), 1 == e.length ? t + e : e;\n    },\n        i = [],\n        o = !1,\n        s = e.getHours(),\n        u = 12 > s;\n\n    null == n && (n = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]), null == r && (r = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]);\n    var c;\n    c = s > 12 ? s - 12 : 0 == s ? 12 : s;\n\n    for (var m = 0; m < t.length; ++m) {\n      var l = t.charAt(m);\n\n      if (o) {\n        switch (l) {\n          case \"a\":\n            l = \"\" + r[e.getDay()];\n            break;\n\n          case \"b\":\n            l = \"\" + n[e.getMonth()];\n            break;\n\n          case \"d\":\n            l = a(e.getDate());\n            break;\n\n          case \"e\":\n            l = a(e.getDate(), \" \");\n            break;\n\n          case \"h\":\n          case \"H\":\n            l = a(s);\n            break;\n\n          case \"I\":\n            l = a(c);\n            break;\n\n          case \"l\":\n            l = a(c, \" \");\n            break;\n\n          case \"m\":\n            l = a(e.getMonth() + 1);\n            break;\n\n          case \"M\":\n            l = a(e.getMinutes());\n            break;\n\n          case \"q\":\n            l = \"\" + (Math.floor(e.getMonth() / 3) + 1);\n            break;\n\n          case \"S\":\n            l = a(e.getSeconds());\n            break;\n\n          case \"y\":\n            l = a(e.getFullYear() % 100);\n            break;\n\n          case \"Y\":\n            l = \"\" + e.getFullYear();\n            break;\n\n          case \"p\":\n            l = u ? \"am\" : \"pm\";\n            break;\n\n          case \"P\":\n            l = u ? \"AM\" : \"PM\";\n            break;\n\n          case \"w\":\n            l = \"\" + e.getDay();\n        }\n\n        i.push(l), o = !1;\n      } else \"%\" == l ? o = !0 : i.push(l);\n    }\n\n    return i.join(\"\");\n  }\n\n  function r(e) {\n    function t(e, t, n, r) {\n      e[t] = function () {\n        return n[r].apply(n, arguments);\n      };\n    }\n\n    var n = {\n      date: e\n    };\n    void 0 != e.strftime && t(n, \"strftime\", e, \"strftime\"), t(n, \"getTime\", e, \"getTime\"), t(n, \"setTime\", e, \"setTime\");\n\n    for (var r = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"], a = 0; a < r.length; a++) {\n      t(n, \"get\" + r[a], e, \"getUTC\" + r[a]), t(n, \"set\" + r[a], e, \"setUTC\" + r[a]);\n    }\n\n    return n;\n  }\n\n  function a(e, t) {\n    if (\"browser\" == t.timezone) return new Date(e);\n\n    if (t.timezone && \"utc\" != t.timezone) {\n      if (\"undefined\" != typeof timezoneJS && \"undefined\" != typeof timezoneJS.Date) {\n        var n = new timezoneJS.Date();\n        return n.setTimezone(t.timezone), n.setTime(e), n;\n      }\n\n      return r(new Date(e));\n    }\n\n    return r(new Date(e));\n  }\n\n  function i(r) {\n    r.hooks.processOptions.push(function (r) {\n      e.each(r.getAxes(), function (e, r) {\n        var i = r.options;\n        \"time\" == i.mode && (r.tickGenerator = function (e) {\n          var n = [],\n              r = a(e.min, i),\n              o = 0,\n              u = i.tickSize && \"quarter\" === i.tickSize[1] || i.minTickSize && \"quarter\" === i.minTickSize[1] ? m : c;\n          null != i.minTickSize && (o = \"number\" == typeof i.tickSize ? i.tickSize : i.minTickSize[0] * s[i.minTickSize[1]]);\n\n          for (var l = 0; l < u.length - 1 && !(e.delta < (u[l][0] * s[u[l][1]] + u[l + 1][0] * s[u[l + 1][1]]) / 2 && u[l][0] * s[u[l][1]] >= o); ++l) {\n            ;\n          }\n\n          var h = u[l][0],\n              f = u[l][1];\n\n          if (\"year\" == f) {\n            if (null != i.minTickSize && \"year\" == i.minTickSize[1]) h = Math.floor(i.minTickSize[0]);else {\n              var k = Math.pow(10, Math.floor(Math.log(e.delta / s.year) / Math.LN10)),\n                  d = e.delta / s.year / k;\n              h = 1.5 > d ? 1 : 3 > d ? 2 : 7.5 > d ? 5 : 10, h *= k;\n            }\n            1 > h && (h = 1);\n          }\n\n          e.tickSize = i.tickSize || [h, f];\n          var M = e.tickSize[0];\n          f = e.tickSize[1];\n          var g = M * s[f];\n          \"second\" == f ? r.setSeconds(t(r.getSeconds(), M)) : \"minute\" == f ? r.setMinutes(t(r.getMinutes(), M)) : \"hour\" == f ? r.setHours(t(r.getHours(), M)) : \"month\" == f ? r.setMonth(t(r.getMonth(), M)) : \"quarter\" == f ? r.setMonth(3 * t(r.getMonth() / 3, M)) : \"year\" == f && r.setFullYear(t(r.getFullYear(), M)), r.setMilliseconds(0), g >= s.minute && r.setSeconds(0), g >= s.hour && r.setMinutes(0), g >= s.day && r.setHours(0), g >= 4 * s.day && r.setDate(1), g >= 2 * s.month && r.setMonth(t(r.getMonth(), 3)), g >= 2 * s.quarter && r.setMonth(t(r.getMonth(), 6)), g >= s.year && r.setMonth(0);\n          var y,\n              S = 0,\n              z = Number.NaN;\n\n          do {\n            if (y = z, z = r.getTime(), n.push(z), \"month\" == f || \"quarter\" == f) {\n              if (1 > M) {\n                r.setDate(1);\n                var p = r.getTime();\n                r.setMonth(r.getMonth() + (\"quarter\" == f ? 3 : 1));\n                var v = r.getTime();\n                r.setTime(z + S * s.hour + (v - p) * M), S = r.getHours(), r.setHours(0);\n              } else r.setMonth(r.getMonth() + M * (\"quarter\" == f ? 3 : 1));\n            } else \"year\" == f ? r.setFullYear(r.getFullYear() + M) : r.setTime(z + g);\n          } while (z < e.max && z != y);\n\n          return n;\n        }, r.tickFormatter = function (e, t) {\n          var r = a(e, t.options);\n          if (null != i.timeformat) return n(r, i.timeformat, i.monthNames, i.dayNames);\n          var o,\n              u = t.options.tickSize && \"quarter\" == t.options.tickSize[1] || t.options.minTickSize && \"quarter\" == t.options.minTickSize[1],\n              c = t.tickSize[0] * s[t.tickSize[1]],\n              m = t.max - t.min,\n              l = i.twelveHourClock ? \" %p\" : \"\",\n              h = i.twelveHourClock ? \"%I\" : \"%H\";\n          o = c < s.minute ? h + \":%M:%S\" + l : c < s.day ? m < 2 * s.day ? h + \":%M\" + l : \"%b %d \" + h + \":%M\" + l : c < s.month ? \"%b %d\" : u && c < s.quarter || !u && c < s.year ? m < s.year ? \"%b\" : \"%b %Y\" : u && c < s.year ? m < s.year ? \"Q%q\" : \"Q%q %Y\" : \"%Y\";\n          var f = n(r, o, i.monthNames, i.dayNames);\n          return f;\n        });\n      });\n    });\n  }\n\n  var o = {\n    xaxis: {\n      timezone: null,\n      timeformat: null,\n      twelveHourClock: !1,\n      monthNames: null\n    }\n  },\n      s = {\n    second: 1e3,\n    minute: 6e4,\n    hour: 36e5,\n    day: 864e5,\n    month: 2592e6,\n    quarter: 7776e6,\n    year: 525949.2 * 60 * 1e3\n  },\n      u = [[1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"], [30, \"second\"], [1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"], [30, \"minute\"], [1, \"hour\"], [2, \"hour\"], [4, \"hour\"], [8, \"hour\"], [12, \"hour\"], [1, \"day\"], [2, \"day\"], [3, \"day\"], [0.25, \"month\"], [0.5, \"month\"], [1, \"month\"], [2, \"month\"]],\n      c = u.concat([[3, \"month\"], [6, \"month\"], [1, \"year\"]]),\n      m = u.concat([[1, \"quarter\"], [2, \"quarter\"], [1, \"year\"]]);\n  e.plot.plugins.push({\n    init: i,\n    options: o,\n    name: \"time\",\n    version: \"1.0\"\n  }), e.plot.formatDate = n, e.plot.dateGenerator = a;\n}(jQuery);\n!function (e) {\n  var t = {\n    tooltip: !1,\n    tooltipOpts: {\n      content: \"%s | X: %x | Y: %y.2\",\n      dateFormat: \"%y-%0m-%0d\",\n      shifts: {\n        x: 10,\n        y: 20\n      },\n      defaultTheme: !0\n    }\n  },\n      o = function o(t) {\n    var o = {\n      x: 0,\n      y: 0\n    },\n        n = t.getOptions(),\n        i = function i(e) {\n      o.x = e.x, o.y = e.y;\n    },\n        a = function a(e) {\n      var t = {\n        x: 0,\n        y: 0\n      };\n      t.x = e.pageX, t.y = e.pageY, i(t);\n    },\n        s = function s(t) {\n      var o = new Date(t);\n      return e.plot.formatDate(o, n.tooltipOpts.dateFormat);\n    };\n\n    t.hooks.bindEvents.push(function (t, i) {\n      var r,\n          p = n.tooltipOpts,\n          l = t.getPlaceholder();\n      n.tooltip !== !1 && (e(\"#flotTip\").length > 0 ? r = e(\"#flotTip\") : (r = e(\"<div />\").attr(\"id\", \"flotTip\"), r.appendTo(\"body\").hide().css({\n        position: \"absolute\"\n      }), p.defaultTheme && r.css({\n        background: \"#fff\",\n        \"z-index\": \"100\",\n        padding: \"0.4em 0.6em\",\n        \"border-radius\": \"0.5em\",\n        \"font-size\": \"0.8em\",\n        border: \"1px solid #111\"\n      })), e(l).bind(\"plothover\", function (e, t, i) {\n        if (i) {\n          var a;\n          a = \"time\" === n.xaxis.mode || \"time\" === n.xaxes[0].mode ? d(p.content, i, s) : d(p.content, i), r.html(a).css({\n            left: o.x + p.shifts.x,\n            top: o.y + p.shifts.y\n          }).show();\n        } else r.hide().html(\"\");\n      }), i.mousemove(a));\n    });\n\n    var d = function d(e, t, o) {\n      var n = /%p\\.{0,1}(\\d{0,})/,\n          i = /%s/,\n          a = /%x\\.{0,1}(\\d{0,})/,\n          s = /%y\\.{0,1}(\\d{0,})/;\n      return \"undefined\" != typeof t.series.percent && (e = r(n, e, t.series.percent)), \"undefined\" != typeof t.series.label && (e = e.replace(i, t.series.label)), \"function\" == typeof o ? e = e.replace(a, o(t.series.data[t.dataIndex][0])) : \"number\" == typeof t.series.data[t.dataIndex][0] && (e = r(a, e, t.series.data[t.dataIndex][0])), \"number\" == typeof t.series.data[t.dataIndex][1] && (e = r(s, e, t.series.data[t.dataIndex][1])), e;\n    },\n        r = function r(e, t, o) {\n      var n;\n      return \"null\" !== t.match(e) && (\"\" !== RegExp.$1 && (n = RegExp.$1, o = o.toFixed(n)), t = t.replace(e, o)), t;\n    };\n  };\n\n  e.plot.plugins.push({\n    init: o,\n    options: t,\n    name: \"tooltip\",\n    version: \"0.4.4\"\n  });\n}(jQuery);","map":null,"metadata":{},"sourceType":"module"}