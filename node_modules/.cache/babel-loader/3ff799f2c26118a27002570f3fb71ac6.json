{"ast":null,"code":"// Released under MIT license\n// Copyright (c) 2009-2010 Dominic Baggott\n// Copyright (c) 2009-2010 Ash Berlin\n// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)\n\n/*jshint browser:true, devel:true */\n(function (expose) {\n  /**\n   *  class Markdown\n   *\n   *  Markdown processing in Javascript done right. We have very particular views\n   *  on what constitutes 'right' which include:\n   *\n   *  - produces well-formed HTML (this means that em and strong nesting is\n   *    important)\n   *\n   *  - has an intermediate representation to allow processing of parsed data (We\n   *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\n   *\n   *  - is easily extensible to add new dialects without having to rewrite the\n   *    entire parsing mechanics\n   *\n   *  - has a good test suite\n   *\n   *  This implementation fulfills all of these (except that the test suite could\n   *  do with expanding to automatically run all the fixtures from other Markdown\n   *  implementations.)\n   *\n   *  ##### Intermediate Representation\n   *\n   *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\n   *\n   *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\n   **/\n  var Markdown = expose.Markdown = function (dialect) {\n    switch (typeof dialect) {\n      case \"undefined\":\n        this.dialect = Markdown.dialects.Gruber;\n        break;\n\n      case \"object\":\n        this.dialect = dialect;\n        break;\n\n      default:\n        if (dialect in Markdown.dialects) {\n          this.dialect = Markdown.dialects[dialect];\n        } else {\n          throw new Error(\"Unknown Markdown dialect '\" + String(dialect) + \"'\");\n        }\n\n        break;\n    }\n\n    this.em_state = [];\n    this.strong_state = [];\n    this.debug_indent = \"\";\n  };\n  /**\n   *  parse( markdown, [dialect] ) -> JsonML\n   *  - markdown (String): markdown string to parse\n   *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n   *\n   *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\n   **/\n\n\n  expose.parse = function (source, dialect) {\n    // dialect will default if undefined\n    var md = new Markdown(dialect);\n    return md.toTree(source);\n  };\n  /**\n   *  toHTML( markdown, [dialect]  ) -> String\n   *  toHTML( md_tree ) -> String\n   *  - markdown (String): markdown string to parse\n   *  - md_tree (Markdown.JsonML): parsed markdown tree\n   *\n   *  Take markdown (either as a string or as a JsonML tree) and run it through\n   *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\n   **/\n\n\n  expose.toHTML = function toHTML(source, dialect, options) {\n    var input = expose.toHTMLTree(source, dialect, options);\n    return expose.renderJsonML(input);\n  };\n  /**\n   *  toHTMLTree( markdown, [dialect] ) -> JsonML\n   *  toHTMLTree( md_tree ) -> JsonML\n   *  - markdown (String): markdown string to parse\n   *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n   *  - md_tree (Markdown.JsonML): parsed markdown tree\n   *\n   *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\n   *  to this function, it is first parsed into a markdown tree by calling\n   *  [[parse]].\n   **/\n\n\n  expose.toHTMLTree = function toHTMLTree(input, dialect, options) {\n    // convert string input to an MD tree\n    if (typeof input === \"string\") input = this.parse(input, dialect); // Now convert the MD tree to an HTML tree\n    // remove references from the tree\n\n    var attrs = extract_attr(input),\n        refs = {};\n\n    if (attrs && attrs.references) {\n      refs = attrs.references;\n    }\n\n    var html = convert_tree_to_html(input, refs, options);\n    merge_text_nodes(html);\n    return html;\n  }; // For Spidermonkey based engines\n\n\n  function mk_block_toSource() {\n    return \"Markdown.mk_block( \" + uneval(this.toString()) + \", \" + uneval(this.trailing) + \", \" + uneval(this.lineNumber) + \" )\";\n  } // node\n\n\n  function mk_block_inspect() {\n    var util = require(\"util\");\n\n    return \"Markdown.mk_block( \" + util.inspect(this.toString()) + \", \" + util.inspect(this.trailing) + \", \" + util.inspect(this.lineNumber) + \" )\";\n  }\n\n  var mk_block = Markdown.mk_block = function (block, trail, line) {\n    // Be helpful for default case in tests.\n    if (arguments.length == 1) trail = \"\\n\\n\";\n    var s = new String(block);\n    s.trailing = trail; // To make it clear its not just a string\n\n    s.inspect = mk_block_inspect;\n    s.toSource = mk_block_toSource;\n    if (line != undefined) s.lineNumber = line;\n    return s;\n  };\n\n  function count_lines(str) {\n    var n = 0,\n        i = -1;\n\n    while ((i = str.indexOf(\"\\n\", i + 1)) !== -1) {\n      n++;\n    }\n\n    return n;\n  } // Internal - split source into rough blocks\n\n\n  Markdown.prototype.split_blocks = function splitBlocks(input, startLine) {\n    input = input.replace(/(\\r\\n|\\n|\\r)/g, \"\\n\"); // [\\s\\S] matches _anything_ (newline or space)\n    // [^] is equivalent but doesn't work in IEs.\n\n    var re = /([\\s\\S]+?)($|\\n#|\\n(?:\\s*\\n|$)+)/g,\n        blocks = [],\n        m;\n    var line_no = 1;\n\n    if ((m = /^(\\s*\\n)/.exec(input)) != null) {\n      // skip (but count) leading blank lines\n      line_no += count_lines(m[0]);\n      re.lastIndex = m[0].length;\n    }\n\n    while ((m = re.exec(input)) !== null) {\n      if (m[2] == \"\\n#\") {\n        m[2] = \"\\n\";\n        re.lastIndex--;\n      }\n\n      blocks.push(mk_block(m[1], m[2], line_no));\n      line_no += count_lines(m[0]);\n    }\n\n    return blocks;\n  };\n  /**\n   *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\n   *  - block (String): the block to process\n   *  - next (Array): the following blocks\n   *\n   * Process `block` and return an array of JsonML nodes representing `block`.\n   *\n   * It does this by asking each block level function in the dialect to process\n   * the block until one can. Succesful handling is indicated by returning an\n   * array (with zero or more JsonML nodes), failure by a false value.\n   *\n   * Blocks handlers are responsible for calling [[Markdown#processInline]]\n   * themselves as appropriate.\n   *\n   * If the blocks were split incorrectly or adjacent blocks need collapsing you\n   * can adjust `next` in place using shift/splice etc.\n   *\n   * If any of this default behaviour is not right for the dialect, you can\n   * define a `__call__` method on the dialect that will get invoked to handle\n   * the block processing.\n   */\n\n\n  Markdown.prototype.processBlock = function processBlock(block, next) {\n    var cbs = this.dialect.block,\n        ord = cbs.__order__;\n\n    if (\"__call__\" in cbs) {\n      return cbs.__call__.call(this, block, next);\n    }\n\n    for (var i = 0; i < ord.length; i++) {\n      //D:this.debug( \"Testing\", ord[i] );\n      var res = cbs[ord[i]].call(this, block, next);\n\n      if (res) {\n        //D:this.debug(\"  matched\");\n        if (!isArray(res) || res.length > 0 && !isArray(res[0])) this.debug(ord[i], \"didn't return a proper array\"); //D:this.debug( \"\" );\n\n        return res;\n      }\n    } // Uhoh! no match! Should we throw an error?\n\n\n    return [];\n  };\n\n  Markdown.prototype.processInline = function processInline(block) {\n    return this.dialect.inline.__call__.call(this, String(block));\n  };\n  /**\n   *  Markdown#toTree( source ) -> JsonML\n   *  - source (String): markdown source to parse\n   *\n   *  Parse `source` into a JsonML tree representing the markdown document.\n   **/\n  // custom_tree means set this.tree to `custom_tree` and restore old value on return\n\n\n  Markdown.prototype.toTree = function toTree(source, custom_root) {\n    var blocks = source instanceof Array ? source : this.split_blocks(source); // Make tree a member variable so its easier to mess with in extensions\n\n    var old_tree = this.tree;\n\n    try {\n      this.tree = custom_root || this.tree || [\"markdown\"];\n\n      blocks: while (blocks.length) {\n        var b = this.processBlock(blocks.shift(), blocks); // Reference blocks and the like won't return any content\n\n        if (!b.length) continue blocks;\n        this.tree.push.apply(this.tree, b);\n      }\n\n      return this.tree;\n    } finally {\n      if (custom_root) {\n        this.tree = old_tree;\n      }\n    }\n  }; // Noop by default\n\n\n  Markdown.prototype.debug = function () {\n    var args = Array.prototype.slice.call(arguments);\n    args.unshift(this.debug_indent);\n    if (typeof print !== \"undefined\") print.apply(print, args);\n    if (typeof console !== \"undefined\" && typeof console.log !== \"undefined\") console.log.apply(null, args);\n  };\n\n  Markdown.prototype.loop_re_over_block = function (re, block, cb) {\n    // Dont use /g regexps with this\n    var m,\n        b = block.valueOf();\n\n    while (b.length && (m = re.exec(b)) != null) {\n      b = b.substr(m[0].length);\n      cb.call(this, m);\n    }\n\n    return b;\n  };\n  /**\n   * Markdown.dialects\n   *\n   * Namespace of built-in dialects.\n   **/\n\n\n  Markdown.dialects = {};\n  /**\n   * Markdown.dialects.Gruber\n   *\n   * The default dialect that follows the rules set out by John Gruber's\n   * markdown.pl as closely as possible. Well actually we follow the behaviour of\n   * that script which in some places is not exactly what the syntax web page\n   * says.\n   **/\n\n  Markdown.dialects.Gruber = {\n    block: {\n      atxHeader: function atxHeader(block, next) {\n        var m = block.match(/^(#{1,6})\\s*(.*?)\\s*#*\\s*(?:\\n|$)/);\n        if (!m) return undefined;\n        var header = [\"header\", {\n          level: m[1].length\n        }];\n        Array.prototype.push.apply(header, this.processInline(m[2]));\n        if (m[0].length < block.length) next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));\n        return [header];\n      },\n      setextHeader: function setextHeader(block, next) {\n        var m = block.match(/^(.*)\\n([-=])\\2\\2+(?:\\n|$)/);\n        if (!m) return undefined;\n        var level = m[2] === \"=\" ? 1 : 2;\n        var header = [\"header\", {\n          level: level\n        }, m[1]];\n        if (m[0].length < block.length) next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));\n        return [header];\n      },\n      code: function code(block, next) {\n        // |    Foo\n        // |bar\n        // should be a code block followed by a paragraph. Fun\n        //\n        // There might also be adjacent code block to merge.\n        var ret = [],\n            re = /^(?: {0,3}\\t| {4})(.*)\\n?/,\n            lines; // 4 spaces + content\n\n        if (!block.match(re)) return undefined;\n\n        block_search: do {\n          // Now pull out the rest of the lines\n          var b = this.loop_re_over_block(re, block.valueOf(), function (m) {\n            ret.push(m[1]);\n          });\n\n          if (b.length) {\n            // Case alluded to in first comment. push it back on as a new block\n            next.unshift(mk_block(b, block.trailing));\n            break block_search;\n          } else if (next.length) {\n            // Check the next block - it might be code too\n            if (!next[0].match(re)) break block_search; // Pull how how many blanks lines follow - minus two to account for .join\n\n            ret.push(block.trailing.replace(/[^\\n]/g, \"\").substring(2));\n            block = next.shift();\n          } else {\n            break block_search;\n          }\n        } while (true);\n\n        return [[\"code_block\", ret.join(\"\\n\")]];\n      },\n      horizRule: function horizRule(block, next) {\n        // this needs to find any hr in the block to handle abutting blocks\n        var m = block.match(/^(?:([\\s\\S]*?)\\n)?[ \\t]*([-_*])(?:[ \\t]*\\2){2,}[ \\t]*(?:\\n([\\s\\S]*))?$/);\n\n        if (!m) {\n          return undefined;\n        }\n\n        var jsonml = [[\"hr\"]]; // if there's a leading abutting block, process it\n\n        if (m[1]) {\n          jsonml.unshift.apply(jsonml, this.processBlock(m[1], []));\n        } // if there's a trailing abutting block, stick it into next\n\n\n        if (m[3]) {\n          next.unshift(mk_block(m[3]));\n        }\n\n        return jsonml;\n      },\n      // There are two types of lists. Tight and loose. Tight lists have no whitespace\n      // between the items (and result in text just in the <li>) and loose lists,\n      // which have an empty line between list items, resulting in (one or more)\n      // paragraphs inside the <li>.\n      //\n      // There are all sorts weird edge cases about the original markdown.pl's\n      // handling of lists:\n      //\n      // * Nested lists are supposed to be indented by four chars per level. But\n      //   if they aren't, you can get a nested list by indenting by less than\n      //   four so long as the indent doesn't match an indent of an existing list\n      //   item in the 'nest stack'.\n      //\n      // * The type of the list (bullet or number) is controlled just by the\n      //    first item at the indent. Subsequent changes are ignored unless they\n      //    are for nested lists\n      //\n      lists: function () {\n        // Use a closure to hide a few variables.\n        var any_list = \"[*+-]|\\\\d+\\\\.\",\n            bullet_list = /[*+-]/,\n            number_list = /\\d+\\./,\n            // Capture leading indent as it matters for determining nested lists.\n        is_list_re = new RegExp(\"^( {0,3})(\" + any_list + \")[ \\t]+\"),\n            indent_re = \"(?: {0,3}\\\\t| {4})\"; // TODO: Cache this regexp for certain depths.\n        // Create a regexp suitable for matching an li for a given stack depth\n\n        function regex_for_depth(depth) {\n          return new RegExp( // m[1] = indent, m[2] = list_type\n          \"(?:^(\" + indent_re + \"{0,\" + depth + \"} {0,3})(\" + any_list + \")\\\\s+)|\" + // m[3] = cont\n          \"(^\" + indent_re + \"{0,\" + (depth - 1) + \"}[ ]{0,4})\");\n        }\n\n        function expand_tab(input) {\n          return input.replace(/ {0,3}\\t/g, \"    \");\n        } // Add inline content `inline` to `li`. inline comes from processInline\n        // so is an array of content\n\n\n        function add(li, loose, inline, nl) {\n          if (loose) {\n            li.push([\"para\"].concat(inline));\n            return;\n          } // Hmmm, should this be any block level element or just paras?\n\n\n          var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] == \"para\" ? li[li.length - 1] : li; // If there is already some content in this list, add the new line in\n\n          if (nl && li.length > 1) inline.unshift(nl);\n\n          for (var i = 0; i < inline.length; i++) {\n            var what = inline[i],\n                is_str = typeof what == \"string\";\n\n            if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] == \"string\") {\n              add_to[add_to.length - 1] += what;\n            } else {\n              add_to.push(what);\n            }\n          }\n        } // contained means have an indent greater than the current one. On\n        // *every* line in the block\n\n\n        function get_contained_blocks(depth, blocks) {\n          var re = new RegExp(\"^(\" + indent_re + \"{\" + depth + \"}.*?\\\\n?)*$\"),\n              replace = new RegExp(\"^\" + indent_re + \"{\" + depth + \"}\", \"gm\"),\n              ret = [];\n\n          while (blocks.length > 0) {\n            if (re.exec(blocks[0])) {\n              var b = blocks.shift(),\n                  // Now remove that indent\n              x = b.replace(replace, \"\");\n              ret.push(mk_block(x, b.trailing, b.lineNumber));\n            } else {\n              break;\n            }\n          }\n\n          return ret;\n        } // passed to stack.forEach to turn list items up the stack into paras\n\n\n        function paragraphify(s, i, stack) {\n          var list = s.list;\n          var last_li = list[list.length - 1];\n\n          if (last_li[1] instanceof Array && last_li[1][0] == \"para\") {\n            return;\n          }\n\n          if (i + 1 == stack.length) {\n            // Last stack frame\n            // Keep the same array, but replace the contents\n            last_li.push([\"para\"].concat(last_li.splice(1, last_li.length - 1)));\n          } else {\n            var sublist = last_li.pop();\n            last_li.push([\"para\"].concat(last_li.splice(1, last_li.length - 1)), sublist);\n          }\n        } // The matcher function\n\n\n        return function (block, next) {\n          var m = block.match(is_list_re);\n          if (!m) return undefined;\n\n          function make_list(m) {\n            var list = bullet_list.exec(m[2]) ? [\"bulletlist\"] : [\"numberlist\"];\n            stack.push({\n              list: list,\n              indent: m[1]\n            });\n            return list;\n          }\n\n          var stack = [],\n              // Stack of lists for nesting.\n          list = make_list(m),\n              last_li,\n              loose = false,\n              ret = [stack[0].list],\n              i; // Loop to search over block looking for inner block elements and loose lists\n\n          loose_search: while (true) {\n            // Split into lines preserving new lines at end of line\n            var lines = block.split(/(?=\\n)/); // We have to grab all lines for a li and call processInline on them\n            // once as there are some inline things that can span lines.\n\n            var li_accumulate = \"\"; // Loop over the lines in this block looking for tight lists.\n\n            tight_search: for (var line_no = 0; line_no < lines.length; line_no++) {\n              var nl = \"\",\n                  l = lines[line_no].replace(/^\\n/, function (n) {\n                nl = n;\n                return \"\";\n              }); // TODO: really should cache this\n\n              var line_re = regex_for_depth(stack.length);\n              m = l.match(line_re); //print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );\n              // We have a list item\n\n              if (m[1] !== undefined) {\n                // Process the previous list item, if any\n                if (li_accumulate.length) {\n                  add(last_li, loose, this.processInline(li_accumulate), nl); // Loose mode will have been dealt with. Reset it\n\n                  loose = false;\n                  li_accumulate = \"\";\n                }\n\n                m[1] = expand_tab(m[1]);\n                var wanted_depth = Math.floor(m[1].length / 4) + 1; //print( \"want:\", wanted_depth, \"stack:\", stack.length);\n\n                if (wanted_depth > stack.length) {\n                  // Deep enough for a nested list outright\n                  //print ( \"new nested list\" );\n                  list = make_list(m);\n                  last_li.push(list);\n                  last_li = list[1] = [\"listitem\"];\n                } else {\n                  // We aren't deep enough to be strictly a new level. This is\n                  // where Md.pl goes nuts. If the indent matches a level in the\n                  // stack, put it there, else put it one deeper then the\n                  // wanted_depth deserves.\n                  var found = false;\n\n                  for (i = 0; i < stack.length; i++) {\n                    if (stack[i].indent != m[1]) continue;\n                    list = stack[i].list;\n                    stack.splice(i + 1, stack.length - (i + 1));\n                    found = true;\n                    break;\n                  }\n\n                  if (!found) {\n                    //print(\"not found. l:\", uneval(l));\n                    wanted_depth++;\n\n                    if (wanted_depth <= stack.length) {\n                      stack.splice(wanted_depth, stack.length - wanted_depth); //print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);\n\n                      list = stack[wanted_depth - 1].list; //print(\"list:\", uneval(list) );\n                    } else {\n                      //print (\"made new stack for messy indent\");\n                      list = make_list(m);\n                      last_li.push(list);\n                    }\n                  } //print( uneval(list), \"last\", list === stack[stack.length-1].list );\n\n\n                  last_li = [\"listitem\"];\n                  list.push(last_li);\n                } // end depth of shenegains\n\n\n                nl = \"\";\n              } // Add content\n\n\n              if (l.length > m[0].length) {\n                li_accumulate += nl + l.substr(m[0].length);\n              }\n            } // tight_search\n\n\n            if (li_accumulate.length) {\n              add(last_li, loose, this.processInline(li_accumulate), nl); // Loose mode will have been dealt with. Reset it\n\n              loose = false;\n              li_accumulate = \"\";\n            } // Look at the next block - we might have a loose list. Or an extra\n            // paragraph for the current li\n\n\n            var contained = get_contained_blocks(stack.length, next); // Deal with code blocks or properly nested lists\n\n            if (contained.length > 0) {\n              // Make sure all listitems up the stack are paragraphs\n              forEach(stack, paragraphify, this);\n              last_li.push.apply(last_li, this.toTree(contained, []));\n            }\n\n            var next_block = next[0] && next[0].valueOf() || \"\";\n\n            if (next_block.match(is_list_re) || next_block.match(/^ /)) {\n              block = next.shift(); // Check for an HR following a list: features/lists/hr_abutting\n\n              var hr = this.dialect.block.horizRule(block, next);\n\n              if (hr) {\n                ret.push.apply(ret, hr);\n                break;\n              } // Make sure all listitems up the stack are paragraphs\n\n\n              forEach(stack, paragraphify, this);\n              loose = true;\n              continue loose_search;\n            }\n\n            break;\n          } // loose_search\n\n\n          return ret;\n        };\n      }(),\n      blockquote: function blockquote(block, next) {\n        if (!block.match(/^>/m)) return undefined;\n        var jsonml = []; // separate out the leading abutting block, if any. I.e. in this case:\n        //\n        //  a\n        //  > b\n        //\n\n        if (block[0] != \">\") {\n          var lines = block.split(/\\n/),\n              prev = [],\n              line_no = block.lineNumber; // keep shifting lines until you find a crotchet\n\n          while (lines.length && lines[0][0] != \">\") {\n            prev.push(lines.shift());\n            line_no++;\n          }\n\n          var abutting = mk_block(prev.join(\"\\n\"), \"\\n\", block.lineNumber);\n          jsonml.push.apply(jsonml, this.processBlock(abutting, [])); // reassemble new block of just block quotes!\n\n          block = mk_block(lines.join(\"\\n\"), block.trailing, line_no);\n        } // if the next block is also a blockquote merge it in\n\n\n        while (next.length && next[0][0] == \">\") {\n          var b = next.shift();\n          block = mk_block(block + block.trailing + b, b.trailing, block.lineNumber);\n        } // Strip off the leading \"> \" and re-process as a block.\n\n\n        var input = block.replace(/^> ?/gm, \"\"),\n            old_tree = this.tree,\n            processedBlock = this.toTree(input, [\"blockquote\"]),\n            attr = extract_attr(processedBlock); // If any link references were found get rid of them\n\n        if (attr && attr.references) {\n          delete attr.references; // And then remove the attribute object if it's empty\n\n          if (isEmpty(attr)) {\n            processedBlock.splice(1, 1);\n          }\n        }\n\n        jsonml.push(processedBlock);\n        return jsonml;\n      },\n      referenceDefn: function referenceDefn(block, next) {\n        var re = /^\\s*\\[(.*?)\\]:\\s*(\\S+)(?:\\s+(?:(['\"])(.*?)\\3|\\((.*?)\\)))?\\n?/; // interesting matches are [ , ref_id, url, , title, title ]\n\n        if (!block.match(re)) return undefined; // make an attribute node if it doesn't exist\n\n        if (!extract_attr(this.tree)) {\n          this.tree.splice(1, 0, {});\n        }\n\n        var attrs = extract_attr(this.tree); // make a references hash if it doesn't exist\n\n        if (attrs.references === undefined) {\n          attrs.references = {};\n        }\n\n        var b = this.loop_re_over_block(re, block, function (m) {\n          if (m[2] && m[2][0] == \"<\" && m[2][m[2].length - 1] == \">\") m[2] = m[2].substring(1, m[2].length - 1);\n          var ref = attrs.references[m[1].toLowerCase()] = {\n            href: m[2]\n          };\n          if (m[4] !== undefined) ref.title = m[4];else if (m[5] !== undefined) ref.title = m[5];\n        });\n        if (b.length) next.unshift(mk_block(b, block.trailing));\n        return [];\n      },\n      para: function para(block, next) {\n        // everything's a para!\n        return [[\"para\"].concat(this.processInline(block))];\n      }\n    }\n  };\n  Markdown.dialects.Gruber.inline = {\n    __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {\n      var m,\n          res,\n          lastIndex = 0;\n      patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;\n      var re = new RegExp(\"([\\\\s\\\\S]*?)(\" + (patterns_or_re.source || patterns_or_re) + \")\");\n      m = re.exec(text);\n\n      if (!m) {\n        // Just boring text\n        return [text.length, text];\n      } else if (m[1]) {\n        // Some un-interesting text matched. Return that first\n        return [m[1].length, m[1]];\n      }\n\n      var res;\n\n      if (m[2] in this.dialect.inline) {\n        res = this.dialect.inline[m[2]].call(this, text.substr(m.index), m, previous_nodes || []);\n      } // Default for now to make dev easier. just slurp special and output it.\n\n\n      res = res || [m[2].length, m[2]];\n      return res;\n    },\n    __call__: function inline(text, patterns) {\n      var out = [],\n          res;\n\n      function add(x) {\n        //D:self.debug(\"  adding output\", uneval(x));\n        if (typeof x == \"string\" && typeof out[out.length - 1] == \"string\") out[out.length - 1] += x;else out.push(x);\n      }\n\n      while (text.length > 0) {\n        res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);\n        text = text.substr(res.shift());\n        forEach(res, add);\n      }\n\n      return out;\n    },\n    // These characters are intersting elsewhere, so have rules for them so that\n    // chunks of plain text blocks don't include them\n    \"]\": function _() {},\n    \"}\": function _() {},\n    __escape__: /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-]/,\n    \"\\\\\": function escaped(text) {\n      // [ length of input processed, node/children to add... ]\n      // Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !\n      if (this.dialect.inline.__escape__.exec(text)) return [2, text.charAt(1)];else // Not an esacpe\n        return [1, \"\\\\\"];\n    },\n    \"![\": function image(text) {\n      // Unlike images, alt text is plain text only. no other elements are\n      // allowed in there\n      // ![Alt text](/path/to/img.jpg \"Optional title\")\n      //      1          2            3       4         <--- captures\n      var m = text.match(/^!\\[(.*?)\\][ \\t]*\\([ \\t]*([^\")]*?)(?:[ \\t]+([\"'])(.*?)\\3)?[ \\t]*\\)/);\n\n      if (m) {\n        if (m[2] && m[2][0] == \"<\" && m[2][m[2].length - 1] == \">\") m[2] = m[2].substring(1, m[2].length - 1);\n        m[2] = this.dialect.inline.__call__.call(this, m[2], /\\\\/)[0];\n        var attrs = {\n          alt: m[1],\n          href: m[2] || \"\"\n        };\n        if (m[4] !== undefined) attrs.title = m[4];\n        return [m[0].length, [\"img\", attrs]];\n      } // ![Alt text][id]\n\n\n      m = text.match(/^!\\[(.*?)\\][ \\t]*\\[(.*?)\\]/);\n\n      if (m) {\n        // We can't check if the reference is known here as it likely wont be\n        // found till after. Check it in md tree->hmtl tree conversion\n        return [m[0].length, [\"img_ref\", {\n          alt: m[1],\n          ref: m[2].toLowerCase(),\n          original: m[0]\n        }]];\n      } // Just consume the '!['\n\n\n      return [2, \"![\"];\n    },\n    \"[\": function link(text) {\n      var orig = String(text); // Inline content is possible inside `link text`\n\n      var res = Markdown.DialectHelpers.inline_until_char.call(this, text.substr(1), \"]\"); // No closing ']' found. Just consume the [\n\n      if (!res) return [1, \"[\"];\n      var consumed = 1 + res[0],\n          children = res[1],\n          link,\n          attrs; // At this point the first [...] has been parsed. See what follows to find\n      // out which kind of link we are (reference or direct url)\n\n      text = text.substr(consumed); // [link text](/path/to/img.jpg \"Optional title\")\n      //                 1            2       3         <--- captures\n      // This will capture up to the last paren in the block. We then pull\n      // back based on if there a matching ones in the url\n      //    ([here](/url/(test))\n      // The parens have to be balanced\n\n      var m = text.match(/^\\s*\\([ \\t]*([^\"']*)(?:[ \\t]+([\"'])(.*?)\\2)?[ \\t]*\\)/);\n\n      if (m) {\n        var url = m[1];\n        consumed += m[0].length;\n        if (url && url[0] == \"<\" && url[url.length - 1] == \">\") url = url.substring(1, url.length - 1); // If there is a title we don't have to worry about parens in the url\n\n        if (!m[3]) {\n          var open_parens = 1; // One open that isn't in the capture\n\n          for (var len = 0; len < url.length; len++) {\n            switch (url[len]) {\n              case \"(\":\n                open_parens++;\n                break;\n\n              case \")\":\n                if (--open_parens == 0) {\n                  consumed -= url.length - len;\n                  url = url.substring(0, len);\n                }\n\n                break;\n            }\n          }\n        } // Process escapes only\n\n\n        url = this.dialect.inline.__call__.call(this, url, /\\\\/)[0];\n        attrs = {\n          href: url || \"\"\n        };\n        if (m[3] !== undefined) attrs.title = m[3];\n        link = [\"link\", attrs].concat(children);\n        return [consumed, link];\n      } // [Alt text][id]\n      // [Alt text] [id]\n\n\n      m = text.match(/^\\s*\\[(.*?)\\]/);\n\n      if (m) {\n        consumed += m[0].length; // [links][] uses links as its reference\n\n        attrs = {\n          ref: (m[1] || String(children)).toLowerCase(),\n          original: orig.substr(0, consumed)\n        };\n        link = [\"link_ref\", attrs].concat(children); // We can't check if the reference is known here as it likely wont be\n        // found till after. Check it in md tree->hmtl tree conversion.\n        // Store the original so that conversion can revert if the ref isn't found.\n\n        return [consumed, link];\n      } // [id]\n      // Only if id is plain (no formatting.)\n\n\n      if (children.length == 1 && typeof children[0] == \"string\") {\n        attrs = {\n          ref: children[0].toLowerCase(),\n          original: orig.substr(0, consumed)\n        };\n        link = [\"link_ref\", attrs, children[0]];\n        return [consumed, link];\n      } // Just consume the \"[\"\n\n\n      return [1, \"[\"];\n    },\n    \"<\": function autoLink(text) {\n      var m;\n\n      if ((m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\\.[a-zA-Z]+))>/)) != null) {\n        if (m[3]) {\n          return [m[0].length, [\"link\", {\n            href: \"mailto:\" + m[3]\n          }, m[3]]];\n        } else if (m[2] == \"mailto\") {\n          return [m[0].length, [\"link\", {\n            href: m[1]\n          }, m[1].substr(\"mailto:\".length)]];\n        } else return [m[0].length, [\"link\", {\n          href: m[1]\n        }, m[1]]];\n      }\n\n      return [1, \"<\"];\n    },\n    \"`\": function inlineCode(text) {\n      // Inline code block. as many backticks as you like to start it\n      // Always skip over the opening ticks.\n      var m = text.match(/(`+)(([\\s\\S]*?)\\1)/);\n      if (m && m[2]) return [m[1].length + m[2].length, [\"inlinecode\", m[3]]];else {\n        // TODO: No matching end code found - warn!\n        return [1, \"`\"];\n      }\n    },\n    \"  \\n\": function lineBreak(text) {\n      return [3, [\"linebreak\"]];\n    }\n  }; // Meta Helper/generator method for em and strong handling\n\n  function strong_em(tag, md) {\n    var state_slot = tag + \"_state\",\n        other_slot = tag == \"strong\" ? \"em_state\" : \"strong_state\";\n\n    function CloseTag(len) {\n      this.len_after = len;\n      this.name = \"close_\" + md;\n    }\n\n    return function (text, orig_match) {\n      if (this[state_slot][0] == md) {\n        // Most recent em is of this type\n        //D:this.debug(\"closing\", md);\n        this[state_slot].shift(); // \"Consume\" everything to go back to the recrusion in the else-block below\n\n        return [text.length, new CloseTag(text.length - md.length)];\n      } else {\n        // Store a clone of the em/strong states\n        var other = this[other_slot].slice(),\n            state = this[state_slot].slice();\n        this[state_slot].unshift(md); //D:this.debug_indent += \"  \";\n        // Recurse\n\n        var res = this.processInline(text.substr(md.length)); //D:this.debug_indent = this.debug_indent.substr(2);\n\n        var last = res[res.length - 1]; //D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );\n\n        var check = this[state_slot].shift();\n\n        if (last instanceof CloseTag) {\n          res.pop(); // We matched! Huzzah.\n\n          var consumed = text.length - last.len_after;\n          return [consumed, [tag].concat(res)];\n        } else {\n          // Restore the state of the other kind. We might have mistakenly closed it.\n          this[other_slot] = other;\n          this[state_slot] = state; // We can't reuse the processed result as it could have wrong parsing contexts in it.\n\n          return [md.length, md];\n        }\n      }\n    }; // End returned function\n  }\n\n  Markdown.dialects.Gruber.inline[\"**\"] = strong_em(\"strong\", \"**\");\n  Markdown.dialects.Gruber.inline[\"__\"] = strong_em(\"strong\", \"__\");\n  Markdown.dialects.Gruber.inline[\"*\"] = strong_em(\"em\", \"*\");\n  Markdown.dialects.Gruber.inline[\"_\"] = strong_em(\"em\", \"_\"); // Build default order from insertion order.\n\n  Markdown.buildBlockOrder = function (d) {\n    var ord = [];\n\n    for (var i in d) {\n      if (i == \"__order__\" || i == \"__call__\") continue;\n      ord.push(i);\n    }\n\n    d.__order__ = ord;\n  }; // Build patterns for inline matcher\n\n\n  Markdown.buildInlinePatterns = function (d) {\n    var patterns = [];\n\n    for (var i in d) {\n      // __foo__ is reserved and not a pattern\n      if (i.match(/^__.*__$/)) continue;\n      var l = i.replace(/([\\\\.*+?|()\\[\\]{}])/g, \"\\\\$1\").replace(/\\n/, \"\\\\n\");\n      patterns.push(i.length == 1 ? l : \"(?:\" + l + \")\");\n    }\n\n    patterns = patterns.join(\"|\");\n    d.__patterns__ = patterns; //print(\"patterns:\", uneval( patterns ) );\n\n    var fn = d.__call__;\n\n    d.__call__ = function (text, pattern) {\n      if (pattern != undefined) {\n        return fn.call(this, text, pattern);\n      } else {\n        return fn.call(this, text, patterns);\n      }\n    };\n  };\n\n  Markdown.DialectHelpers = {};\n\n  Markdown.DialectHelpers.inline_until_char = function (text, want) {\n    var consumed = 0,\n        nodes = [];\n\n    while (true) {\n      if (text.charAt(consumed) == want) {\n        // Found the character we were looking for\n        consumed++;\n        return [consumed, nodes];\n      }\n\n      if (consumed >= text.length) {\n        // No closing char found. Abort.\n        return null;\n      }\n\n      var res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));\n\n      consumed += res[0]; // Add any returned nodes.\n\n      nodes.push.apply(nodes, res.slice(1));\n    }\n  }; // Helper function to make sub-classing a dialect easier\n\n\n  Markdown.subclassDialect = function (d) {\n    function Block() {}\n\n    Block.prototype = d.block;\n\n    function Inline() {}\n\n    Inline.prototype = d.inline;\n    return {\n      block: new Block(),\n      inline: new Inline()\n    };\n  };\n\n  Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);\n  Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);\n  Markdown.dialects.Maruku = Markdown.subclassDialect(Markdown.dialects.Gruber);\n\n  Markdown.dialects.Maruku.processMetaHash = function processMetaHash(meta_string) {\n    var meta = split_meta_hash(meta_string),\n        attr = {};\n\n    for (var i = 0; i < meta.length; ++i) {\n      // id: #foo\n      if (/^#/.test(meta[i])) {\n        attr.id = meta[i].substring(1);\n      } // class: .foo\n      else if (/^\\./.test(meta[i])) {\n          // if class already exists, append the new one\n          if (attr[\"class\"]) {\n            attr[\"class\"] = attr[\"class\"] + meta[i].replace(/./, \" \");\n          } else {\n            attr[\"class\"] = meta[i].substring(1);\n          }\n        } // attribute: foo=bar\n        else if (/\\=/.test(meta[i])) {\n            var s = meta[i].split(/\\=/);\n            attr[s[0]] = s[1];\n          }\n    }\n\n    return attr;\n  };\n\n  function split_meta_hash(meta_string) {\n    var meta = meta_string.split(\"\"),\n        parts = [\"\"],\n        in_quotes = false;\n\n    while (meta.length) {\n      var letter = meta.shift();\n\n      switch (letter) {\n        case \" \":\n          // if we're in a quoted section, keep it\n          if (in_quotes) {\n            parts[parts.length - 1] += letter;\n          } // otherwise make a new part\n          else {\n              parts.push(\"\");\n            }\n\n          break;\n\n        case \"'\":\n        case '\"':\n          // reverse the quotes and move straight on\n          in_quotes = !in_quotes;\n          break;\n\n        case \"\\\\\":\n          // shift off the next letter to be used straight away.\n          // it was escaped so we'll keep it whatever it is\n          letter = meta.shift();\n\n        default:\n          parts[parts.length - 1] += letter;\n          break;\n      }\n    }\n\n    return parts;\n  }\n\n  Markdown.dialects.Maruku.block.document_meta = function document_meta(block, next) {\n    // we're only interested in the first block\n    if (block.lineNumber > 1) return undefined; // document_meta blocks consist of one or more lines of `Key: Value\\n`\n\n    if (!block.match(/^(?:\\w+:.*\\n)*\\w+:.*$/)) return undefined; // make an attribute node if it doesn't exist\n\n    if (!extract_attr(this.tree)) {\n      this.tree.splice(1, 0, {});\n    }\n\n    var pairs = block.split(/\\n/);\n\n    for (p in pairs) {\n      var m = pairs[p].match(/(\\w+):\\s*(.*)$/),\n          key = m[1].toLowerCase(),\n          value = m[2];\n      this.tree[1][key] = value;\n    } // document_meta produces no content!\n\n\n    return [];\n  };\n\n  Markdown.dialects.Maruku.block.block_meta = function block_meta(block, next) {\n    // check if the last line of the block is an meta hash\n    var m = block.match(/(^|\\n) {0,3}\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}$/);\n    if (!m) return undefined; // process the meta hash\n\n    var attr = this.dialect.processMetaHash(m[2]);\n    var hash; // if we matched ^ then we need to apply meta to the previous block\n\n    if (m[1] === \"\") {\n      var node = this.tree[this.tree.length - 1];\n      hash = extract_attr(node); // if the node is a string (rather than JsonML), bail\n\n      if (typeof node === \"string\") return undefined; // create the attribute hash if it doesn't exist\n\n      if (!hash) {\n        hash = {};\n        node.splice(1, 0, hash);\n      } // add the attributes in\n\n\n      for (a in attr) {\n        hash[a] = attr[a];\n      } // return nothing so the meta hash is removed\n\n\n      return [];\n    } // pull the meta hash off the block and process what's left\n\n\n    var b = block.replace(/\\n.*$/, \"\"),\n        result = this.processBlock(b, []); // get or make the attributes hash\n\n    hash = extract_attr(result[0]);\n\n    if (!hash) {\n      hash = {};\n      result[0].splice(1, 0, hash);\n    } // attach the attributes to the block\n\n\n    for (a in attr) {\n      hash[a] = attr[a];\n    }\n\n    return result;\n  };\n\n  Markdown.dialects.Maruku.block.definition_list = function definition_list(block, next) {\n    // one or more terms followed by one or more definitions, in a single block\n    var tight = /^((?:[^\\s:].*\\n)+):\\s+([\\s\\S]+)$/,\n        list = [\"dl\"],\n        i,\n        m; // see if we're dealing with a tight or loose block\n\n    if (m = block.match(tight)) {\n      // pull subsequent tight DL blocks out of `next`\n      var blocks = [block];\n\n      while (next.length && tight.exec(next[0])) {\n        blocks.push(next.shift());\n      }\n\n      for (var b = 0; b < blocks.length; ++b) {\n        var m = blocks[b].match(tight),\n            terms = m[1].replace(/\\n$/, \"\").split(/\\n/),\n            defns = m[2].split(/\\n:\\s+/); // print( uneval( m ) );\n\n        for (i = 0; i < terms.length; ++i) {\n          list.push([\"dt\", terms[i]]);\n        }\n\n        for (i = 0; i < defns.length; ++i) {\n          // run inline processing over the definition\n          list.push([\"dd\"].concat(this.processInline(defns[i].replace(/(\\n)\\s+/, \"$1\"))));\n        }\n      }\n    } else {\n      return undefined;\n    }\n\n    return [list];\n  }; // splits on unescaped instances of @ch. If @ch is not a character the result\n  // can be unpredictable\n\n\n  Markdown.dialects.Maruku.block.table = function table(block, next) {\n    var _split_on_unescaped = function _split_on_unescaped(s, ch) {\n      ch = ch || '\\\\s';\n\n      if (ch.match(/^[\\\\|\\[\\]{}?*.+^$]$/)) {\n        ch = '\\\\' + ch;\n      }\n\n      var res = [],\n          r = new RegExp('^((?:\\\\\\\\.|[^\\\\\\\\' + ch + '])*)' + ch + '(.*)'),\n          m;\n\n      while (m = s.match(r)) {\n        res.push(m[1]);\n        s = m[2];\n      }\n\n      res.push(s);\n      return res;\n    };\n\n    var leading_pipe = /^ {0,3}\\|(.+)\\n {0,3}\\|\\s*([\\-:]+[\\-| :]*)\\n((?:\\s*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        // find at least an unescaped pipe in each line\n    no_leading_pipe = /^ {0,3}(\\S(?:\\\\.|[^\\\\|])*\\|.*)\\n {0,3}([\\-:]+\\s*\\|[\\-| :]*)\\n((?:(?:\\\\.|[^\\\\|])*\\|.*(?:\\n|$))*)(?=\\n|$)/,\n        i,\n        m;\n\n    if (m = block.match(leading_pipe)) {\n      // remove leading pipes in contents\n      // (header and horizontal rule already have the leading pipe left out)\n      m[3] = m[3].replace(/^\\s*\\|/gm, '');\n    } else if (!(m = block.match(no_leading_pipe))) {\n      return undefined;\n    }\n\n    var table = [\"table\", [\"thead\", [\"tr\"]], [\"tbody\"]]; // remove trailing pipes, then split on pipes\n    // (no escaped pipes are allowed in horizontal rule)\n\n    m[2] = m[2].replace(/\\|\\s*$/, '').split('|'); // process alignment\n\n    var html_attrs = [];\n    forEach(m[2], function (s) {\n      if (s.match(/^\\s*-+:\\s*$/)) html_attrs.push({\n        align: \"right\"\n      });else if (s.match(/^\\s*:-+\\s*$/)) html_attrs.push({\n        align: \"left\"\n      });else if (s.match(/^\\s*:-+:\\s*$/)) html_attrs.push({\n        align: \"center\"\n      });else html_attrs.push({});\n    }); // now for the header, avoid escaped pipes\n\n    m[1] = _split_on_unescaped(m[1].replace(/\\|\\s*$/, ''), '|');\n\n    for (i = 0; i < m[1].length; i++) {\n      table[1][1].push(['th', html_attrs[i] || {}].concat(this.processInline(m[1][i].trim())));\n    } // now for body contents\n\n\n    forEach(m[3].replace(/\\|\\s*$/mg, '').split('\\n'), function (row) {\n      var html_row = ['tr'];\n      row = _split_on_unescaped(row, '|');\n\n      for (i = 0; i < row.length; i++) {\n        html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));\n      }\n\n      table[2].push(html_row);\n    }, this);\n    return [table];\n  };\n\n  Markdown.dialects.Maruku.inline[\"{:\"] = function inline_meta(text, matches, out) {\n    if (!out.length) {\n      return [2, \"{:\"];\n    } // get the preceeding element\n\n\n    var before = out[out.length - 1];\n\n    if (typeof before === \"string\") {\n      return [2, \"{:\"];\n    } // match a meta hash\n\n\n    var m = text.match(/^\\{:\\s*((?:\\\\\\}|[^\\}])*)\\s*\\}/); // no match, false alarm\n\n    if (!m) {\n      return [2, \"{:\"];\n    } // attach the attributes to the preceeding element\n\n\n    var meta = this.dialect.processMetaHash(m[1]),\n        attr = extract_attr(before);\n\n    if (!attr) {\n      attr = {};\n      before.splice(1, 0, attr);\n    }\n\n    for (var k in meta) {\n      attr[k] = meta[k];\n    } // cut out the string and replace it with nothing\n\n\n    return [m[0].length, \"\"];\n  };\n\n  Markdown.dialects.Maruku.inline.__escape__ = /^\\\\[\\\\`\\*_{}\\[\\]()#\\+.!\\-|:]/;\n  Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);\n  Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) == \"[object Array]\";\n  };\n\n  var forEach; // Don't mess with Array.prototype. Its not friendly\n\n  if (Array.prototype.forEach) {\n    forEach = function forEach(arr, cb, thisp) {\n      return arr.forEach(cb, thisp);\n    };\n  } else {\n    forEach = function forEach(arr, cb, thisp) {\n      for (var i = 0; i < arr.length; i++) {\n        cb.call(thisp || arr, arr[i], i, arr);\n      }\n    };\n  }\n\n  var isEmpty = function isEmpty(obj) {\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  function extract_attr(jsonml) {\n    return isArray(jsonml) && jsonml.length > 1 && typeof jsonml[1] === \"object\" && !isArray(jsonml[1]) ? jsonml[1] : undefined;\n  }\n  /**\n   *  renderJsonML( jsonml[, options] ) -> String\n   *  - jsonml (Array): JsonML array to render to XML\n   *  - options (Object): options\n   *\n   *  Converts the given JsonML into well-formed XML.\n   *\n   *  The options currently understood are:\n   *\n   *  - root (Boolean): wether or not the root node should be included in the\n   *    output, or just its children. The default `false` is to not include the\n   *    root itself.\n   */\n\n\n  expose.renderJsonML = function (jsonml, options) {\n    options = options || {}; // include the root element in the rendered output?\n\n    options.root = options.root || false;\n    var content = [];\n\n    if (options.root) {\n      content.push(render_tree(jsonml));\n    } else {\n      jsonml.shift(); // get rid of the tag\n\n      if (jsonml.length && typeof jsonml[0] === \"object\" && !(jsonml[0] instanceof Array)) {\n        jsonml.shift(); // get rid of the attributes\n      }\n\n      while (jsonml.length) {\n        content.push(render_tree(jsonml.shift()));\n      }\n    }\n\n    return content.join(\"\\n\\n\");\n  };\n\n  function escapeHTML(text) {\n    return text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\");\n  }\n\n  function render_tree(jsonml) {\n    // basic case\n    if (typeof jsonml === \"string\") {\n      return escapeHTML(jsonml);\n    }\n\n    var tag = jsonml.shift(),\n        attributes = {},\n        content = [];\n\n    if (jsonml.length && typeof jsonml[0] === \"object\" && !(jsonml[0] instanceof Array)) {\n      attributes = jsonml.shift();\n    }\n\n    while (jsonml.length) {\n      content.push(render_tree(jsonml.shift()));\n    }\n\n    var tag_attrs = \"\";\n\n    for (var a in attributes) {\n      tag_attrs += \" \" + a + '=\"' + escapeHTML(attributes[a]) + '\"';\n    } // be careful about adding whitespace here for inline elements\n\n\n    if (tag == \"img\" || tag == \"br\" || tag == \"hr\") {\n      return \"<\" + tag + tag_attrs + \"/>\";\n    } else {\n      return \"<\" + tag + tag_attrs + \">\" + content.join(\"\") + \"</\" + tag + \">\";\n    }\n  }\n\n  function convert_tree_to_html(tree, references, options) {\n    var i;\n    options = options || {}; // shallow clone\n\n    var jsonml = tree.slice(0);\n\n    if (typeof options.preprocessTreeNode === \"function\") {\n      jsonml = options.preprocessTreeNode(jsonml, references);\n    } // Clone attributes if they exist\n\n\n    var attrs = extract_attr(jsonml);\n\n    if (attrs) {\n      jsonml[1] = {};\n\n      for (i in attrs) {\n        jsonml[1][i] = attrs[i];\n      }\n\n      attrs = jsonml[1];\n    } // basic case\n\n\n    if (typeof jsonml === \"string\") {\n      return jsonml;\n    } // convert this node\n\n\n    switch (jsonml[0]) {\n      case \"header\":\n        jsonml[0] = \"h\" + jsonml[1].level;\n        delete jsonml[1].level;\n        break;\n\n      case \"bulletlist\":\n        jsonml[0] = \"ul\";\n        break;\n\n      case \"numberlist\":\n        jsonml[0] = \"ol\";\n        break;\n\n      case \"listitem\":\n        jsonml[0] = \"li\";\n        break;\n\n      case \"para\":\n        jsonml[0] = \"p\";\n        break;\n\n      case \"markdown\":\n        jsonml[0] = \"html\";\n        if (attrs) delete attrs.references;\n        break;\n\n      case \"code_block\":\n        jsonml[0] = \"pre\";\n        i = attrs ? 2 : 1;\n        var code = [\"code\"];\n        code.push.apply(code, jsonml.splice(i, jsonml.length - i));\n        jsonml[i] = code;\n        break;\n\n      case \"inlinecode\":\n        jsonml[0] = \"code\";\n        break;\n\n      case \"img\":\n        jsonml[1].src = jsonml[1].href;\n        delete jsonml[1].href;\n        break;\n\n      case \"linebreak\":\n        jsonml[0] = \"br\";\n        break;\n\n      case \"link\":\n        jsonml[0] = \"a\";\n        break;\n\n      case \"link_ref\":\n        jsonml[0] = \"a\"; // grab this ref and clean up the attribute node\n\n        var ref = references[attrs.ref]; // if the reference exists, make the link\n\n        if (ref) {\n          delete attrs.ref; // add in the href and title, if present\n\n          attrs.href = ref.href;\n\n          if (ref.title) {\n            attrs.title = ref.title;\n          } // get rid of the unneeded original text\n\n\n          delete attrs.original;\n        } // the reference doesn't exist, so revert to plain text\n        else {\n            return attrs.original;\n          }\n\n        break;\n\n      case \"img_ref\":\n        jsonml[0] = \"img\"; // grab this ref and clean up the attribute node\n\n        var ref = references[attrs.ref]; // if the reference exists, make the link\n\n        if (ref) {\n          delete attrs.ref; // add in the href and title, if present\n\n          attrs.src = ref.href;\n\n          if (ref.title) {\n            attrs.title = ref.title;\n          } // get rid of the unneeded original text\n\n\n          delete attrs.original;\n        } // the reference doesn't exist, so revert to plain text\n        else {\n            return attrs.original;\n          }\n\n        break;\n    } // convert all the children\n\n\n    i = 1; // deal with the attribute node, if it exists\n\n    if (attrs) {\n      // if there are keys, skip over it\n      for (var key in jsonml[1]) {\n        i = 2;\n        break;\n      } // if there aren't, remove it\n\n\n      if (i === 1) {\n        jsonml.splice(i, 1);\n      }\n    }\n\n    for (; i < jsonml.length; ++i) {\n      jsonml[i] = convert_tree_to_html(jsonml[i], references, options);\n    }\n\n    return jsonml;\n  } // merges adjacent text nodes into a single node\n\n\n  function merge_text_nodes(jsonml) {\n    // skip the tag name and attribute hash\n    var i = extract_attr(jsonml) ? 2 : 1;\n\n    while (i < jsonml.length) {\n      // if it's a string check the next item too\n      if (typeof jsonml[i] === \"string\") {\n        if (i + 1 < jsonml.length && typeof jsonml[i + 1] === \"string\") {\n          // merge the second string into the first and remove it\n          jsonml[i] += jsonml.splice(i + 1, 1)[0];\n        } else {\n          ++i;\n        }\n      } // if it's not a string recurse\n      else {\n          merge_text_nodes(jsonml[i]);\n          ++i;\n        }\n    }\n  }\n})(function () {\n  if (typeof exports === \"undefined\") {\n    window.markdown = {};\n    return window.markdown;\n  } else {\n    return exports;\n  }\n}());","map":null,"metadata":{},"sourceType":"script"}