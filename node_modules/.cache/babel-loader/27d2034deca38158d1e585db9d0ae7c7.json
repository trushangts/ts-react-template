{"ast":null,"code":"/* global jQuery:true */\n\n/*\n * Fuel UX Wizard\n * https://github.com/ExactTarget/fuelux\n *\n * Copyright (c) 2014 ExactTarget\n * Licensed under the BSD New license.\n */\n// -- BEGIN UMD WRAPPER PREFACE --\n// For more information on UMD visit:\n// https://github.com/umdjs/umd/blob/master/jqueryPlugin.js\n(function umdFactory(factory) {\n  if (typeof define === 'function' && define.amd) {\n    // if AMD loader is available, register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof exports === 'object') {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // OR use browser globals if AMD is not present\n    factory(jQuery);\n  }\n})(function WizardWrapper($) {\n  // -- END UMD WRAPPER PREFACE --\n  // -- BEGIN MODULE CODE HERE --\n  var old = $.fn.wizard; // WIZARD CONSTRUCTOR AND PROTOTYPE\n\n  var Wizard = function Wizard(element, options) {\n    this.$element = $(element);\n    this.options = $.extend({}, $.fn.wizard.defaults, options);\n    this.options.disablePreviousStep = this.$element.attr('data-restrict') === 'previous' ? true : this.options.disablePreviousStep;\n    this.currentStep = this.options.selectedItem.step;\n    this.numSteps = this.$element.find('.steps li').length;\n    this.$prevBtn = this.$element.find('button.btn-prev');\n    this.$nextBtn = this.$element.find('button.btn-next');\n    var kids = this.$nextBtn.children().detach();\n    this.nextText = $.trim(this.$nextBtn.text());\n    this.$nextBtn.append(kids);\n    var steps = this.$element.children('.steps-container'); // maintains backwards compatibility with < 3.8, will be removed in the future\n\n    if (steps.length === 0) {\n      steps = this.$element;\n      this.$element.addClass('no-steps-container');\n\n      if (window && window.console && window.console.warn) {\n        window.console.warn('please update your wizard markup to include \".steps-container\" as seen in http://getfuelux.com/javascript.html#wizard-usage-markup');\n      }\n    }\n\n    steps = steps.find('.steps'); // handle events\n\n    this.$prevBtn.on('click.fu.wizard', $.proxy(this.previous, this));\n    this.$nextBtn.on('click.fu.wizard', $.proxy(this.next, this));\n    steps.on('click.fu.wizard', 'li.complete', $.proxy(this.stepclicked, this));\n    this.selectedItem(this.options.selectedItem);\n\n    if (this.options.disablePreviousStep) {\n      this.$prevBtn.attr('disabled', true);\n      this.$element.find('.steps').addClass('previous-disabled');\n    }\n  };\n\n  Wizard.prototype = {\n    constructor: Wizard,\n    destroy: function destroy() {\n      this.$element.remove(); // any external bindings [none]\n      // empty elements to return to original markup [none]\n      // returns string of markup\n\n      return this.$element[0].outerHTML;\n    },\n    //index is 1 based\n    //second parameter can be array of objects [{ ... }, { ... }] or you can pass n additional objects as args\n    //object structure is as follows (all params are optional): { badge: '', label: '', pane: '' }\n    addSteps: function addSteps(index) {\n      var items = [].slice.call(arguments).slice(1);\n      var $steps = this.$element.find('.steps');\n      var $stepContent = this.$element.find('.step-content');\n      var i, l, $pane, $startPane, $startStep, $step;\n      index = index === -1 || index > this.numSteps + 1 ? this.numSteps + 1 : index;\n\n      if (items[0] instanceof Array) {\n        items = items[0];\n      }\n\n      $startStep = $steps.find('li:nth-child(' + index + ')');\n      $startPane = $stepContent.find('.step-pane:nth-child(' + index + ')');\n\n      if ($startStep.length < 1) {\n        $startStep = null;\n      }\n\n      for (i = 0, l = items.length; i < l; i++) {\n        $step = $('<li data-step=\"' + index + '\"><span class=\"badge badge-info\"></span></li>');\n        $step.append(items[i].label || '').append('<span class=\"chevron\"></span>');\n        $step.find('.badge').append(items[i].badge || index);\n        $pane = $('<div class=\"step-pane\" data-step=\"' + index + '\"></div>');\n        $pane.append(items[i].pane || '');\n\n        if (!$startStep) {\n          $steps.append($step);\n          $stepContent.append($pane);\n        } else {\n          $startStep.before($step);\n          $startPane.before($pane);\n        }\n\n        index++;\n      }\n\n      this.syncSteps();\n      this.numSteps = $steps.find('li').length;\n      this.setState();\n    },\n    //index is 1 based, howMany is number to remove\n    removeSteps: function removeSteps(index, howMany) {\n      var action = 'nextAll';\n      var i = 0;\n      var $steps = this.$element.find('.steps');\n      var $stepContent = this.$element.find('.step-content');\n      var $start;\n      howMany = howMany !== undefined ? howMany : 1;\n\n      if (index > $steps.find('li').length) {\n        $start = $steps.find('li:last');\n      } else {\n        $start = $steps.find('li:nth-child(' + index + ')').prev();\n\n        if ($start.length < 1) {\n          action = 'children';\n          $start = $steps;\n        }\n      }\n\n      $start[action]().each(function () {\n        var item = $(this);\n        var step = item.attr('data-step');\n\n        if (i < howMany) {\n          item.remove();\n          $stepContent.find('.step-pane[data-step=\"' + step + '\"]:first').remove();\n        } else {\n          return false;\n        }\n\n        i++;\n      });\n      this.syncSteps();\n      this.numSteps = $steps.find('li').length;\n      this.setState();\n    },\n    setState: function setState() {\n      var canMovePrev = this.currentStep > 1; //remember, steps index is 1 based...\n\n      var isFirstStep = this.currentStep === 1;\n      var isLastStep = this.currentStep === this.numSteps; // disable buttons based on current step\n\n      if (!this.options.disablePreviousStep) {\n        this.$prevBtn.attr('disabled', isFirstStep === true || canMovePrev === false);\n      } // change button text of last step, if specified\n\n\n      var last = this.$nextBtn.attr('data-last');\n\n      if (last) {\n        this.lastText = last; // replace text\n\n        var text = this.nextText;\n\n        if (isLastStep === true) {\n          text = this.lastText; // add status class to wizard\n\n          this.$element.addClass('complete');\n        } else {\n          this.$element.removeClass('complete');\n        }\n\n        var kids = this.$nextBtn.children().detach();\n        this.$nextBtn.text(text).append(kids);\n      } // reset classes for all steps\n\n\n      var $steps = this.$element.find('.steps li');\n      $steps.removeClass('active').removeClass('complete');\n      $steps.find('span.badge').removeClass('badge-info').removeClass('badge-success'); // set class for all previous steps\n\n      var prevSelector = '.steps li:lt(' + (this.currentStep - 1) + ')';\n      var $prevSteps = this.$element.find(prevSelector);\n      $prevSteps.addClass('complete');\n      $prevSteps.find('span.badge').addClass('badge-success'); // set class for current step\n\n      var currentSelector = '.steps li:eq(' + (this.currentStep - 1) + ')';\n      var $currentStep = this.$element.find(currentSelector);\n      $currentStep.addClass('active');\n      $currentStep.find('span.badge').addClass('badge-info'); // set display of target element\n\n      var $stepContent = this.$element.find('.step-content');\n      var target = $currentStep.attr('data-step');\n      $stepContent.find('.step-pane').removeClass('active');\n      $stepContent.find('.step-pane[data-step=\"' + target + '\"]:first').addClass('active'); // reset the wizard position to the left\n\n      this.$element.find('.steps').first().attr('style', 'margin-left: 0'); // check if the steps are wider than the container div\n\n      var totalWidth = 0;\n      this.$element.find('.steps > li').each(function () {\n        totalWidth += $(this).outerWidth();\n      });\n      var containerWidth = 0;\n\n      if (this.$element.find('.actions').length) {\n        containerWidth = this.$element.width() - this.$element.find('.actions').first().outerWidth();\n      } else {\n        containerWidth = this.$element.width();\n      }\n\n      if (totalWidth > containerWidth) {\n        // set the position so that the last step is on the right\n        var newMargin = totalWidth - containerWidth;\n        this.$element.find('.steps').first().attr('style', 'margin-left: -' + newMargin + 'px'); // set the position so that the active step is in a good\n        // position if it has been moved out of view\n\n        if (this.$element.find('li.active').first().position().left < 200) {\n          newMargin += this.$element.find('li.active').first().position().left - 200;\n\n          if (newMargin < 1) {\n            this.$element.find('.steps').first().attr('style', 'margin-left: 0');\n          } else {\n            this.$element.find('.steps').first().attr('style', 'margin-left: -' + newMargin + 'px');\n          }\n        }\n      } // only fire changed event after initializing\n\n\n      if (typeof this.initialized !== 'undefined') {\n        var e = $.Event('changed.fu.wizard');\n        this.$element.trigger(e, {\n          step: this.currentStep\n        });\n      }\n\n      this.initialized = true;\n    },\n    stepclicked: function stepclicked(e) {\n      var li = $(e.currentTarget);\n      var index = this.$element.find('.steps li').index(li);\n\n      if (index < this.currentStep && this.options.disablePreviousStep) {\n        //enforce restrictions\n        return;\n      } else {\n        var evt = $.Event('stepclicked.fu.wizard');\n        this.$element.trigger(evt, {\n          step: index + 1\n        });\n\n        if (evt.isDefaultPrevented()) {\n          return;\n        }\n\n        this.currentStep = index + 1;\n        this.setState();\n      }\n    },\n    syncSteps: function syncSteps() {\n      var i = 1;\n      var $steps = this.$element.find('.steps');\n      var $stepContent = this.$element.find('.step-content');\n      $steps.children().each(function () {\n        var item = $(this);\n        var badge = item.find('.badge');\n        var step = item.attr('data-step');\n\n        if (!isNaN(parseInt(badge.html(), 10))) {\n          badge.html(i);\n        }\n\n        item.attr('data-step', i);\n        $stepContent.find('.step-pane[data-step=\"' + step + '\"]:last').attr('data-step', i);\n        i++;\n      });\n    },\n    previous: function previous() {\n      if (this.options.disablePreviousStep || this.currentStep === 1) {\n        return;\n      }\n\n      var e = $.Event('actionclicked.fu.wizard');\n      this.$element.trigger(e, {\n        step: this.currentStep,\n        direction: 'previous'\n      });\n\n      if (e.isDefaultPrevented()) {\n        return;\n      } // don't increment ...what? Why?\n\n\n      this.currentStep -= 1;\n      this.setState(); // only set focus if focus is still on the $nextBtn (avoid stomping on a focus set programmatically in actionclicked callback)\n\n      if (this.$prevBtn.is(':focus')) {\n        var firstFormField = this.$element.find('.active').find('input, select, textarea')[0];\n\n        if (typeof firstFormField !== 'undefined') {\n          // allow user to start typing immediately instead of having to click on the form field.\n          $(firstFormField).focus();\n        } else if (this.$element.find('.active input:first').length === 0 && this.$prevBtn.is(':disabled')) {\n          //only set focus on a button as the last resort if no form fields exist and the just clicked button is now disabled\n          this.$nextBtn.focus();\n        }\n      }\n    },\n    next: function next() {\n      var e = $.Event('actionclicked.fu.wizard');\n      this.$element.trigger(e, {\n        step: this.currentStep,\n        direction: 'next'\n      });\n\n      if (e.isDefaultPrevented()) {\n        return;\n      } // respect preventDefault in case dev has attached validation to step and wants to stop propagation based on it.\n\n\n      if (this.currentStep < this.numSteps) {\n        this.currentStep += 1;\n        this.setState();\n      } else {\n        //is last step\n        this.$element.trigger('finished.fu.wizard');\n      } // only set focus if focus is still on the $nextBtn (avoid stomping on a focus set programmatically in actionclicked callback)\n\n\n      if (this.$nextBtn.is(':focus')) {\n        var firstFormField = this.$element.find('.active').find('input, select, textarea')[0];\n\n        if (typeof firstFormField !== 'undefined') {\n          // allow user to start typing immediately instead of having to click on the form field.\n          $(firstFormField).focus();\n        } else if (this.$element.find('.active input:first').length === 0 && this.$nextBtn.is(':disabled')) {\n          //only set focus on a button as the last resort if no form fields exist and the just clicked button is now disabled\n          this.$prevBtn.focus();\n        }\n      }\n    },\n    selectedItem: function selectedItem(_selectedItem) {\n      var retVal, step;\n\n      if (_selectedItem) {\n        step = _selectedItem.step || -1; //allow selection of step by data-name\n\n        step = Number(this.$element.find('.steps li[data-name=\"' + step + '\"]').first().attr('data-step')) || Number(step);\n\n        if (1 <= step && step <= this.numSteps) {\n          this.currentStep = step;\n          this.setState();\n        } else {\n          step = this.$element.find('.steps li.active:first').attr('data-step');\n\n          if (!isNaN(step)) {\n            this.currentStep = parseInt(step, 10);\n            this.setState();\n          }\n        }\n\n        retVal = this;\n      } else {\n        retVal = {\n          step: this.currentStep\n        };\n\n        if (this.$element.find('.steps li.active:first[data-name]').length) {\n          retVal.stepname = this.$element.find('.steps li.active:first').attr('data-name');\n        }\n      }\n\n      return retVal;\n    }\n  }; // WIZARD PLUGIN DEFINITION\n\n  $.fn.wizard = function (option) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    var methodReturn;\n    var $set = this.each(function () {\n      var $this = $(this);\n      var data = $this.data('fu.wizard');\n      var options = typeof option === 'object' && option;\n\n      if (!data) {\n        $this.data('fu.wizard', data = new Wizard(this, options));\n      }\n\n      if (typeof option === 'string') {\n        methodReturn = data[option].apply(data, args);\n      }\n    });\n    return methodReturn === undefined ? $set : methodReturn;\n  };\n\n  $.fn.wizard.defaults = {\n    disablePreviousStep: false,\n    selectedItem: {\n      step: -1\n    } //-1 means it will attempt to look for \"active\" class in order to set the step\n\n  };\n  $.fn.wizard.Constructor = Wizard;\n\n  $.fn.wizard.noConflict = function () {\n    $.fn.wizard = old;\n    return this;\n  }; // DATA-API\n\n\n  $(document).on('mouseover.fu.wizard.data-api', '[data-initialize=wizard]', function (e) {\n    var $control = $(e.target).closest('.wizard');\n\n    if (!$control.data('fu.wizard')) {\n      $control.wizard($control.data());\n    }\n  }); // Must be domReady for AMD compatibility\n\n  $(function () {\n    $('[data-initialize=wizard]').each(function () {\n      var $this = $(this);\n      if ($this.data('fu.wizard')) return;\n      $this.wizard($this.data());\n    });\n  }); // -- BEGIN UMD WRAPPER AFTERWORD --\n}); // -- END UMD WRAPPER AFTERWORD --","map":null,"metadata":{},"sourceType":"script"}