{"ast":null,"code":"/**\n * @license\n * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/*global Dygraph:false */\n'use strict';\n/*\nBits of jankiness:\n- Direct layout access\n- Direct area access\n- Should include calculation of ticks, not just the drawing.\n\nOptions left to make axis-friendly.\n  ('drawAxesAtZero')\n  ('xAxisHeight')\n*/\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nvar _dygraphUtils = require('../dygraph-utils');\n\nvar utils = _interopRequireWildcard(_dygraphUtils);\n/**\n * Draws the axes. This includes the labels on the x- and y-axes, as well\n * as the tick marks on the axes.\n * It does _not_ draw the grid lines which span the entire chart.\n */\n\n\nvar axes = function axes() {\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.toString = function () {\n  return 'Axes Plugin';\n};\n\naxes.prototype.activate = function (g) {\n  return {\n    layout: this.layout,\n    clearChart: this.clearChart,\n    willDrawChart: this.willDrawChart\n  };\n};\n\naxes.prototype.layout = function (e) {\n  var g = e.dygraph;\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');\n    e.reserveSpaceLeft(w);\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    var h; // NOTE: I think this is probably broken now, since g.getOption() now\n    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always\n    // has a value.)\n\n    if (g.getOption('xAxisHeight')) {\n      h = g.getOption('xAxisHeight');\n    } else {\n      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');\n    }\n\n    e.reserveSpaceBottom(h);\n  }\n\n  if (g.numAxes() == 2) {\n    if (g.getOptionForAxis('drawAxis', 'y2')) {\n      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');\n      e.reserveSpaceRight(w);\n    }\n  } else if (g.numAxes() > 2) {\n    g.error('Only two y-axes are supported at this time. (Trying ' + 'to use ' + g.numAxes() + ')');\n  }\n};\n\naxes.prototype.detachLabels = function () {\n  function removeArray(ary) {\n    for (var i = 0; i < ary.length; i++) {\n      var el = ary[i];\n      if (el.parentNode) el.parentNode.removeChild(el);\n    }\n  }\n\n  removeArray(this.xlabels_);\n  removeArray(this.ylabels_);\n  this.xlabels_ = [];\n  this.ylabels_ = [];\n};\n\naxes.prototype.clearChart = function (e) {\n  this.detachLabels();\n};\n\naxes.prototype.willDrawChart = function (e) {\n  var _this = this;\n\n  var g = e.dygraph;\n\n  if (!g.getOptionForAxis('drawAxis', 'x') && !g.getOptionForAxis('drawAxis', 'y') && !g.getOptionForAxis('drawAxis', 'y2')) {\n    return;\n  } // Round pixels to half-integer boundaries for crisper drawing.\n\n\n  function halfUp(x) {\n    return Math.round(x) + 0.5;\n  }\n\n  function halfDown(y) {\n    return Math.round(y) - 0.5;\n  }\n\n  var context = e.drawingContext;\n  var containerDiv = e.canvas.parentNode;\n  var canvasWidth = g.width_; // e.canvas.width is affected by pixel ratio.\n\n  var canvasHeight = g.height_;\n  var label, x, y, tick, i;\n\n  var makeLabelStyle = function makeLabelStyle(axis) {\n    return {\n      position: 'absolute',\n      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',\n      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px'\n    };\n  };\n\n  var labelStyles = {\n    x: makeLabelStyle('x'),\n    y: makeLabelStyle('y'),\n    y2: makeLabelStyle('y2')\n  };\n\n  var makeDiv = function makeDiv(txt, axis, prec_axis) {\n    /*\n     * This seems to be called with the following three sets of axis/prec_axis:\n     * x: undefined\n     * y: y1\n     * y: y2\n     */\n    var div = document.createElement('div');\n    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];\n    utils.update(div.style, labelStyle); // TODO: combine outer & inner divs\n\n    var inner_div = document.createElement('div');\n    inner_div.className = 'dygraph-axis-label' + ' dygraph-axis-label-' + axis + (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');\n    inner_div.innerHTML = txt;\n    div.appendChild(inner_div);\n    return div;\n  }; // axis lines\n\n\n  context.save();\n  var layout = g.layout_;\n  var area = e.dygraph.plotter_.area; // Helper for repeated axis-option accesses.\n\n  var makeOptionGetter = function makeOptionGetter(axis) {\n    return function (option) {\n      return g.getOptionForAxis(option, axis);\n    };\n  };\n\n  if (g.getOptionForAxis('drawAxis', 'y')) {\n    if (layout.yticks && layout.yticks.length > 0) {\n      var num_axes = g.numAxes();\n      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];\n      layout.yticks.forEach(function (tick) {\n        if (tick.label === undefined) return; // this tick only has a grid line.\n\n        x = area.x;\n        var sgn = 1;\n        var prec_axis = 'y1';\n        var getAxisOption = getOptions[0];\n\n        if (tick.axis == 1) {\n          // right-side y-axis\n          x = area.x + area.w;\n          sgn = -1;\n          prec_axis = 'y2';\n          getAxisOption = getOptions[1];\n        }\n\n        var fontSize = getAxisOption('axisLabelFontSize');\n        y = area.y + tick.pos * area.h;\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);\n        var top = y - fontSize / 2;\n        if (top < 0) top = 0;\n\n        if (top + fontSize + 3 > canvasHeight) {\n          label.style.bottom = '0';\n        } else {\n          label.style.top = top + 'px';\n        } // TODO: replace these with css classes?\n\n\n        if (tick.axis === 0) {\n          label.style.left = area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize') + 'px';\n          label.style.textAlign = 'right';\n        } else if (tick.axis == 1) {\n          label.style.left = area.x + area.w + getAxisOption('axisTickSize') + 'px';\n          label.style.textAlign = 'left';\n        }\n\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n\n        _this.ylabels_.push(label);\n      }); // The lowest tick on the y-axis often overlaps with the leftmost\n      // tick on the x-axis. Shift the bottom tick up a little bit to\n      // compensate if necessary.\n\n      var bottomTick = this.ylabels_[0]; // Interested in the y2 axis also?\n\n      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');\n      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;\n\n      if (bottom > canvasHeight - fontSize) {\n        bottomTick.style.top = parseInt(bottomTick.style.top, 10) - fontSize / 2 + 'px';\n      }\n    } // draw a vertical line on the left to separate the chart from the labels.\n\n\n    var axisX;\n\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentXCoord(0);\n      if (r > 1 || r < 0 || isNaN(r)) r = 0;\n      axisX = halfUp(area.x + r * area.w);\n    } else {\n      axisX = halfUp(area.x);\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');\n    context.beginPath();\n    context.moveTo(axisX, halfDown(area.y));\n    context.lineTo(axisX, halfDown(area.y + area.h));\n    context.closePath();\n    context.stroke(); // if there's a secondary y-axis, draw a vertical line for that, too.\n\n    if (g.numAxes() == 2) {\n      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');\n      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');\n      context.beginPath();\n      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));\n      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));\n      context.closePath();\n      context.stroke();\n    }\n  }\n\n  if (g.getOptionForAxis('drawAxis', 'x')) {\n    if (layout.xticks) {\n      var getAxisOption = makeOptionGetter('x');\n      layout.xticks.forEach(function (tick) {\n        if (tick.label === undefined) return; // this tick only has a grid line.\n\n        x = area.x + tick.pos * area.w;\n        y = area.y + area.h;\n        /* Tick marks are currently clipped, so don't bother drawing them.\n        context.beginPath();\n        context.moveTo(halfUp(x), halfDown(y));\n        context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));\n        context.closePath();\n        context.stroke();\n        */\n\n        label = makeDiv(tick.label, 'x');\n        label.style.textAlign = 'center';\n        label.style.top = y + getAxisOption('axisTickSize') + 'px';\n        var left = x - getAxisOption('axisLabelWidth') / 2;\n\n        if (left + getAxisOption('axisLabelWidth') > canvasWidth) {\n          left = canvasWidth - getAxisOption('axisLabelWidth');\n          label.style.textAlign = 'right';\n        }\n\n        if (left < 0) {\n          left = 0;\n          label.style.textAlign = 'left';\n        }\n\n        label.style.left = left + 'px';\n        label.style.width = getAxisOption('axisLabelWidth') + 'px';\n        containerDiv.appendChild(label);\n\n        _this.xlabels_.push(label);\n      });\n    }\n\n    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');\n    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');\n    context.beginPath();\n    var axisY;\n\n    if (g.getOption('drawAxesAtZero')) {\n      var r = g.toPercentYCoord(0, 0);\n      if (r > 1 || r < 0) r = 1;\n      axisY = halfDown(area.y + r * area.h);\n    } else {\n      axisY = halfDown(area.y + area.h);\n    }\n\n    context.moveTo(halfUp(area.x), axisY);\n    context.lineTo(halfUp(area.x + area.w), axisY);\n    context.closePath();\n    context.stroke();\n  }\n\n  context.restore();\n};\n\nexports['default'] = axes;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}