{"ast":null,"code":"/**\n * @license\n * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview DataHandler implementation for the combination \n * of error bars and fractions options.\n * @author David Eberlein (david.eberlein@ch.sauter-bc.com)\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar _bars = require('./bars');\n\nvar _bars2 = _interopRequireDefault(_bars);\n/**\n * @constructor\n * @extends Dygraph.DataHandlers.BarsHandler\n */\n\n\nvar FractionsBarsHandler = function FractionsBarsHandler() {};\n\nFractionsBarsHandler.prototype = new _bars2[\"default\"]();\n/** @inheritDoc */\n\nFractionsBarsHandler.prototype.extractSeries = function (rawData, i, options) {\n  // TODO(danvk): pre-allocate series here.\n  var series = [];\n  var x, y, point, num, den, value, stddev, variance;\n  var mult = 100.0;\n  var sigma = options.get(\"sigma\");\n  var logScale = options.get('logscale');\n\n  for (var j = 0; j < rawData.length; j++) {\n    x = rawData[j][0];\n    point = rawData[j][i];\n\n    if (logScale && point !== null) {\n      // On the log scale, points less than zero do not exist.\n      // This will create a gap in the chart.\n      if (point[0] <= 0 || point[1] <= 0) {\n        point = null;\n      }\n    } // Extract to the unified data format.\n\n\n    if (point !== null) {\n      num = point[0];\n      den = point[1];\n\n      if (num !== null && !isNaN(num)) {\n        value = den ? num / den : 0.0;\n        stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n        variance = mult * stddev;\n        y = mult * value; // preserve original values in extras for further filtering\n\n        series.push([x, y, [y - variance, y + variance, num, den]]);\n      } else {\n        series.push([x, num, [num, num, num, den]]);\n      }\n    } else {\n      series.push([x, null, [null, null, null, null]]);\n    }\n  }\n\n  return series;\n};\n/** @inheritDoc */\n\n\nFractionsBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {\n  rollPeriod = Math.min(rollPeriod, originalData.length);\n  var rollingData = [];\n  var sigma = options.get(\"sigma\");\n  var wilsonInterval = options.get(\"wilsonInterval\");\n  var low, high, i, stddev;\n  var num = 0;\n  var den = 0; // numerator/denominator\n\n  var mult = 100.0;\n\n  for (i = 0; i < originalData.length; i++) {\n    num += originalData[i][2][2];\n    den += originalData[i][2][3];\n\n    if (i - rollPeriod >= 0) {\n      num -= originalData[i - rollPeriod][2][2];\n      den -= originalData[i - rollPeriod][2][3];\n    }\n\n    var date = originalData[i][0];\n    var value = den ? num / den : 0.0;\n\n    if (wilsonInterval) {\n      // For more details on this confidence interval, see:\n      // http://en.wikipedia.org/wiki/Binomial_confidence_interval\n      if (den) {\n        var p = value < 0 ? 0 : value,\n            n = den;\n        var pm = sigma * Math.sqrt(p * (1 - p) / n + sigma * sigma / (4 * n * n));\n        var denom = 1 + sigma * sigma / den;\n        low = (p + sigma * sigma / (2 * den) - pm) / denom;\n        high = (p + sigma * sigma / (2 * den) + pm) / denom;\n        rollingData[i] = [date, p * mult, [low * mult, high * mult]];\n      } else {\n        rollingData[i] = [date, 0, [0, 0]];\n      }\n    } else {\n      stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;\n      rollingData[i] = [date, mult * value, [mult * (value - stddev), mult * (value + stddev)]];\n    }\n  }\n\n  return rollingData;\n};\n\nexports[\"default\"] = FractionsBarsHandler;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}