{"ast":null,"code":"/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Based on PlotKitLayout, but modified to meet the needs of\n * dygraphs.\n */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nvar _dygraphUtils = require('./dygraph-utils');\n\nvar utils = _interopRequireWildcard(_dygraphUtils);\n/**\n * Creates a new DygraphLayout object.\n *\n * This class contains all the data to be charted.\n * It uses data coordinates, but also records the chart range (in data\n * coordinates) and hence is able to calculate percentage positions ('In this\n * view, Point A lies 25% down the x-axis.')\n *\n * Two things that it does not do are:\n * 1. Record pixel coordinates for anything.\n * 2. (oddly) determine anything about the layout of chart elements.\n *\n * The naming is a vestige of Dygraph's original PlotKit roots.\n *\n * @constructor\n */\n\n\nvar DygraphLayout = function DygraphLayout(dygraph) {\n  this.dygraph_ = dygraph;\n  /**\n   * Array of points for each series.\n   *\n   * [series index][row index in series] = |Point| structure,\n   * where series index refers to visible series only, and the\n   * point index is for the reduced set of points for the current\n   * zoom region (including one point just outside the window).\n   * All points in the same row index share the same X value.\n   *\n   * @type {Array.<Array.<Dygraph.PointType>>}\n   */\n\n  this.points = [];\n  this.setNames = [];\n  this.annotations = [];\n  this.yAxes_ = null; // TODO(danvk): it's odd that xTicks_ and yTicks_ are inputs, but xticks and\n  // yticks are outputs. Clean this up.\n\n  this.xTicks_ = null;\n  this.yTicks_ = null;\n};\n/**\n * Add points for a single series.\n *\n * @param {string} setname Name of the series.\n * @param {Array.<Dygraph.PointType>} set_xy Points for the series.\n */\n\n\nDygraphLayout.prototype.addDataset = function (setname, set_xy) {\n  this.points.push(set_xy);\n  this.setNames.push(setname);\n};\n/**\n * Returns the box which the chart should be drawn in. This is the canvas's\n * box, less space needed for the axis and chart labels.\n *\n * @return {{x: number, y: number, w: number, h: number}}\n */\n\n\nDygraphLayout.prototype.getPlotArea = function () {\n  return this.area_;\n}; // Compute the box which the chart should be drawn in. This is the canvas's\n// box, less space needed for axis, chart labels, and other plug-ins.\n// NOTE: This should only be called by Dygraph.predraw_().\n\n\nDygraphLayout.prototype.computePlotArea = function () {\n  var area = {\n    // TODO(danvk): per-axis setting.\n    x: 0,\n    y: 0\n  };\n  area.w = this.dygraph_.width_ - area.x - this.dygraph_.getOption('rightGap');\n  area.h = this.dygraph_.height_; // Let plugins reserve space.\n\n  var e = {\n    chart_div: this.dygraph_.graphDiv,\n    reserveSpaceLeft: function reserveSpaceLeft(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.x += px;\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceRight: function reserveSpaceRight(px) {\n      var r = {\n        x: area.x + area.w - px,\n        y: area.y,\n        w: px,\n        h: area.h\n      };\n      area.w -= px;\n      return r;\n    },\n    reserveSpaceTop: function reserveSpaceTop(px) {\n      var r = {\n        x: area.x,\n        y: area.y,\n        w: area.w,\n        h: px\n      };\n      area.y += px;\n      area.h -= px;\n      return r;\n    },\n    reserveSpaceBottom: function reserveSpaceBottom(px) {\n      var r = {\n        x: area.x,\n        y: area.y + area.h - px,\n        w: area.w,\n        h: px\n      };\n      area.h -= px;\n      return r;\n    },\n    chartRect: function chartRect() {\n      return {\n        x: area.x,\n        y: area.y,\n        w: area.w,\n        h: area.h\n      };\n    }\n  };\n  this.dygraph_.cascadeEvents_('layout', e);\n  this.area_ = area;\n};\n\nDygraphLayout.prototype.setAnnotations = function (ann) {\n  // The Dygraph object's annotations aren't parsed. We parse them here and\n  // save a copy. If there is no parser, then the user must be using raw format.\n  this.annotations = [];\n\n  var parse = this.dygraph_.getOption('xValueParser') || function (x) {\n    return x;\n  };\n\n  for (var i = 0; i < ann.length; i++) {\n    var a = {};\n\n    if (!ann[i].xval && ann[i].x === undefined) {\n      console.error(\"Annotations must have an 'x' property\");\n      return;\n    }\n\n    if (ann[i].icon && !(ann[i].hasOwnProperty('width') && ann[i].hasOwnProperty('height'))) {\n      console.error(\"Must set width and height when setting \" + \"annotation.icon property\");\n      return;\n    }\n\n    utils.update(a, ann[i]);\n    if (!a.xval) a.xval = parse(a.x);\n    this.annotations.push(a);\n  }\n};\n\nDygraphLayout.prototype.setXTicks = function (xTicks) {\n  this.xTicks_ = xTicks;\n}; // TODO(danvk): add this to the Dygraph object's API or move it into Layout.\n\n\nDygraphLayout.prototype.setYAxes = function (yAxes) {\n  this.yAxes_ = yAxes;\n};\n\nDygraphLayout.prototype.evaluate = function () {\n  this._xAxis = {};\n\n  this._evaluateLimits();\n\n  this._evaluateLineCharts();\n\n  this._evaluateLineTicks();\n\n  this._evaluateAnnotations();\n};\n\nDygraphLayout.prototype._evaluateLimits = function () {\n  var xlimits = this.dygraph_.xAxisRange();\n  this._xAxis.minval = xlimits[0];\n  this._xAxis.maxval = xlimits[1];\n  var xrange = xlimits[1] - xlimits[0];\n  this._xAxis.scale = xrange !== 0 ? 1 / xrange : 1.0;\n\n  if (this.dygraph_.getOptionForAxis(\"logscale\", 'x')) {\n    this._xAxis.xlogrange = utils.log10(this._xAxis.maxval) - utils.log10(this._xAxis.minval);\n    this._xAxis.xlogscale = this._xAxis.xlogrange !== 0 ? 1.0 / this._xAxis.xlogrange : 1.0;\n  }\n\n  for (var i = 0; i < this.yAxes_.length; i++) {\n    var axis = this.yAxes_[i];\n    axis.minyval = axis.computedValueRange[0];\n    axis.maxyval = axis.computedValueRange[1];\n    axis.yrange = axis.maxyval - axis.minyval;\n    axis.yscale = axis.yrange !== 0 ? 1.0 / axis.yrange : 1.0;\n\n    if (this.dygraph_.getOption(\"logscale\")) {\n      axis.ylogrange = utils.log10(axis.maxyval) - utils.log10(axis.minyval);\n      axis.ylogscale = axis.ylogrange !== 0 ? 1.0 / axis.ylogrange : 1.0;\n\n      if (!isFinite(axis.ylogrange) || isNaN(axis.ylogrange)) {\n        console.error('axis ' + i + ' of graph at ' + axis.g + ' can\\'t be displayed in log scale for range [' + axis.minyval + ' - ' + axis.maxyval + ']');\n      }\n    }\n  }\n};\n\nDygraphLayout.calcXNormal_ = function (value, xAxis, logscale) {\n  if (logscale) {\n    return (utils.log10(value) - utils.log10(xAxis.minval)) * xAxis.xlogscale;\n  } else {\n    return (value - xAxis.minval) * xAxis.scale;\n  }\n};\n/**\n * @param {DygraphAxisType} axis\n * @param {number} value\n * @param {boolean} logscale\n * @return {number}\n */\n\n\nDygraphLayout.calcYNormal_ = function (axis, value, logscale) {\n  if (logscale) {\n    var x = 1.0 - (utils.log10(value) - utils.log10(axis.minyval)) * axis.ylogscale;\n    return isFinite(x) ? x : NaN; // shim for v8 issue; see pull request 276\n  } else {\n    return 1.0 - (value - axis.minyval) * axis.yscale;\n  }\n};\n\nDygraphLayout.prototype._evaluateLineCharts = function () {\n  var isStacked = this.dygraph_.getOption(\"stackedGraph\");\n  var isLogscaleForX = this.dygraph_.getOptionForAxis(\"logscale\", 'x');\n\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n    var setName = this.setNames[setIdx];\n    var connectSeparated = this.dygraph_.getOption('connectSeparatedPoints', setName);\n    var axis = this.dygraph_.axisPropertiesForSeries(setName); // TODO (konigsberg): use optionsForAxis instead.\n\n    var logscale = this.dygraph_.attributes_.getForSeries(\"logscale\", setName);\n\n    for (var j = 0; j < points.length; j++) {\n      var point = points[j]; // Range from 0-1 where 0 represents left and 1 represents right.\n\n      point.x = DygraphLayout.calcXNormal_(point.xval, this._xAxis, isLogscaleForX); // Range from 0-1 where 0 represents top and 1 represents bottom\n\n      var yval = point.yval;\n\n      if (isStacked) {\n        point.y_stacked = DygraphLayout.calcYNormal_(axis, point.yval_stacked, logscale);\n\n        if (yval !== null && !isNaN(yval)) {\n          yval = point.yval_stacked;\n        }\n      }\n\n      if (yval === null) {\n        yval = NaN;\n\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    }\n\n    this.dygraph_.dataHandler_.onLineEvaluated(points, axis, logscale);\n  }\n};\n\nDygraphLayout.prototype._evaluateLineTicks = function () {\n  var i, tick, label, pos, v, has_tick;\n  this.xticks = [];\n\n  for (i = 0; i < this.xTicks_.length; i++) {\n    tick = this.xTicks_[i];\n    label = tick.label;\n    has_tick = !('label_v' in tick);\n    v = has_tick ? tick.v : tick.label_v;\n    pos = this.dygraph_.toPercentXCoord(v);\n\n    if (pos >= 0.0 && pos < 1.0) {\n      this.xticks.push({\n        pos: pos,\n        label: label,\n        has_tick: has_tick\n      });\n    }\n  }\n\n  this.yticks = [];\n\n  for (i = 0; i < this.yAxes_.length; i++) {\n    var axis = this.yAxes_[i];\n\n    for (var j = 0; j < axis.ticks.length; j++) {\n      tick = axis.ticks[j];\n      label = tick.label;\n      has_tick = !('label_v' in tick);\n      v = has_tick ? tick.v : tick.label_v;\n      pos = this.dygraph_.toPercentYCoord(v, i);\n\n      if (pos > 0.0 && pos <= 1.0) {\n        this.yticks.push({\n          axis: i,\n          pos: pos,\n          label: label,\n          has_tick: has_tick\n        });\n      }\n    }\n  }\n};\n\nDygraphLayout.prototype._evaluateAnnotations = function () {\n  // Add the annotations to the point to which they belong.\n  // Make a map from (setName, xval) to annotation for quick lookups.\n  var i;\n  var annotations = {};\n\n  for (i = 0; i < this.annotations.length; i++) {\n    var a = this.annotations[i];\n    annotations[a.xval + \",\" + a.series] = a;\n  }\n\n  this.annotated_points = []; // Exit the function early if there are no annotations.\n\n  if (!this.annotations || !this.annotations.length) {\n    return;\n  } // TODO(antrob): loop through annotations not points.\n\n\n  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {\n    var points = this.points[setIdx];\n\n    for (i = 0; i < points.length; i++) {\n      var p = points[i];\n      var k = p.xval + \",\" + p.name;\n\n      if (k in annotations) {\n        p.annotation = annotations[k];\n        this.annotated_points.push(p);\n      }\n    }\n  }\n};\n/**\n * Convenience function to remove all the data sets from a graph\n */\n\n\nDygraphLayout.prototype.removeAllDatasets = function () {\n  delete this.points;\n  delete this.setNames;\n  delete this.setPointsLengths;\n  delete this.setPointsOffsets;\n  this.points = [];\n  this.setNames = [];\n  this.setPointsLengths = [];\n  this.setPointsOffsets = [];\n};\n\nexports['default'] = DygraphLayout;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}