{"ast":null,"code":"import _classCallCheck from \"/opt/lampp/htdocs/reactApp/React_16.x/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/opt/lampp/htdocs/reactApp/React_16.x/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport SpeechRecognition from \"./utils/SpeechRecognitionApi\";\nimport { config } from \"../../config/config\";\nimport * as actions from \"./VoiceActions\";\nexport var VoiceRecognition =\n/*#__PURE__*/\nfunction () {\n  function VoiceRecognition() {\n    var _this = this;\n\n    _classCallCheck(this, VoiceRecognition);\n\n    this.commandsList = [];\n    this.recognition = null;\n    this.autoRestart = false;\n    this.lastStartedAt = 0;\n    this.callbacks = {\n      start: [],\n      error: [],\n      end: [],\n      result: [],\n      resultMatch: [],\n      resultNoMatch: [],\n      errorNetwork: [],\n      errorPermissionBlocked: [],\n      errorPermissionDenied: []\n    };\n\n    this.init = function (commands) {\n      var resetCommands = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var recognition = _this.recognition; // Abort previous instances of recognition already running\n\n      if (recognition && recognition.abort) {\n        recognition.abort();\n      } // initiate SpeechRecognition\n\n\n      recognition = new SpeechRecognition(); // Set the max number of alternative transcripts to try and match with a command\n\n      recognition.maxAlternatives = 5;\n      recognition.continuous = true; // Sets the language to the default 'en-US'. This can be changed with smartSpeechRecognition.setLanguage()\n\n      recognition.lang = config.voice_command_lang || \"en-US\";\n\n      recognition.onstart = function () {\n        // invokeCallbacks(callbacks.start);\n        //debugState\n        if (config.debugState) {\n          console.log(\"%c âœ” SUCCESS: User allowed access the microphone service to start \", config.debugStyle_success);\n          console.log(\"Language setting is set to: \" + recognition.lang, config.debugStyle);\n        }\n\n        actions.voiceControlStart();\n      };\n\n      recognition.onerror = function (event) {\n        // this.invokeCallbacks(this.callbacks.error);\n        switch (event.error) {\n          case \"network\":\n            // this.invokeCallbacks(this.callbacks.errorNetwork);\n            break;\n\n          case \"not-allowed\":\n          case \"service-not-allowed\":\n            // if permission to use the mic is denied, turn off auto-restart\n            _this.autoRestart = false; //debugState\n\n            if (config.debugState) {\n              console.log(\"%c WARNING: Microphone was not detected (either user denied access or it is not installed properly) \", config.debugStyle_warning);\n            } // determine if permission was denied by user or automatically.\n\n\n            if (new Date().getTime() - _this.lastStartedAt < 200) {// invokeCallbacks(callbacks.errorPermissionBlocked);\n            } else {// invokeCallbacks(callbacks.errorPermissionDenied);\n                //console.log(\"You need your mic to be active\")\n              }\n\n            actions.voiceControlError(event);\n            break;\n\n          default:\n            break;\n        }\n      };\n\n      recognition.onend = function (event) {\n        // invokeCallbacks(this.callbacks.end);\n        // smartSpeechRecognition will auto restart if it is closed automatically and not by user action.\n        actions.voiceControlEnd(event);\n\n        if (_this.autoRestart) {\n          // play nicely with the browser, and never restart smartSpeechRecognition automatically more than once per second\n          var timeSinceLastStart = new Date().getTime() - _this.lastStartedAt;\n\n          if (timeSinceLastStart < 1000) {\n            setTimeout(function () {\n              _this.start({});\n            }, 1000 - timeSinceLastStart);\n          } else {\n            _this.start({});\n          }\n        }\n      };\n\n      recognition.onresult = function (event) {\n        // this.invokeCallbacks(this.callbacks.result);\n        var results = event.results[event.resultIndex];\n        var commandText; // go over each of the 5 results and alternative results received (we've set maxAlternatives to 5 above)\n\n        for (var i = 0; i < results.length; i++) {\n          // the text recognized\n          commandText = results[i].transcript.trim();\n\n          if (config.debugState) {\n            console.log(\"Speech recognized: %c\" + commandText, config.debugStyle);\n          } // try and match recognized text to one of the commands on the list\n\n\n          for (var j = 0, l = _this.commandsList.length; j < l; j++) {\n            var result = _this.commandsList[j].command.exec(commandText);\n\n            if (result) {\n              var parameters = result.slice(1);\n\n              if (config.debugState) {\n                console.log(\"command matched: %c\" + _this.commandsList[j].originalPhrase, config.debugStyle);\n\n                if (parameters.length) {\n                  console.log(\"with parameters\", parameters);\n                }\n              }\n\n              if (_this.commandsList[j].type === actions.VOICE_CONTROL_ACTION) {\n                actions.voiceControlCommand(_this.commandsList[j]);\n              } else {\n                // execute the matched command\n                _this.commandsList[j].callback.apply(_this, parameters);\n              } // this.invokeCallbacks(this.callbacks.resultMatch);\n              // for commands \"sound on\", \"stop\" and \"mute\" do not play sound or display message\n\n\n              var ignoreCallsFor = [\"sound on\", \"mute\", \"stop\"];\n\n              if (ignoreCallsFor.indexOf(_this.commandsList[j].originalPhrase) < 0) {\n                actions.voiceControlMatch(_this.commandsList[j].originalPhrase);\n              } // end if\n\n\n              return true;\n            }\n          } // end for\n\n        } // end for\n        // invokeCallbacks(callbacks.resultNoMatch);\n        //console.log(\"no match found for: \" + commandText)\n\n\n        actions.voiceControlNoMatch(commandText);\n        return false;\n      }; // build commands list\n\n\n      if (resetCommands) {\n        _this.commandsList = [];\n      }\n\n      if (commands.length) {\n        _this.addCommands(commands);\n      }\n\n      _this.recognition = recognition;\n    };\n\n    this.start = function () {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _this.initIfNeeded(options);\n\n      if (options.autoRestart !== undefined) {\n        _this.autoRestart = !!options.autoRestart;\n      } else {\n        _this.autoRestart = true;\n      }\n\n      _this.lastStartedAt = new Date().getTime();\n\n      _this.recognition.start();\n    };\n\n    this.abort = function () {\n      _this.autoRestart = false;\n\n      if (_this.recognition && _this.recognition.abort) {\n        _this.recognition.abort();\n      }\n\n      actions.voiceControlAbort();\n    };\n\n    this.addCommands = function (commands) {\n      var action, command;\n\n      _this.initIfNeeded();\n\n      Object.keys(commands).forEach(function (phrase) {\n        action = window[commands[phrase]] || commands[phrase]; //convert command to regex\n\n        command = _this.commandToRegExp(phrase);\n\n        if (typeof action === \"function\") {\n          _this.commandsList.push({\n            type: actions.VOICE_CONTROL_CALLBACK,\n            command: command,\n            callback: action,\n            originalPhrase: phrase\n          });\n        }\n\n        if (typeof action === \"object\") {\n          _this.commandsList.push({\n            type: actions.VOICE_CONTROL_ACTION,\n            command: command,\n            payload: action.payload,\n            actionType: action.type,\n            originalPhrase: phrase\n          });\n        }\n      });\n\n      if (config.debugState) {\n        console.log(\"Commands successfully loaded: %c\" + _this.commandsList.length, config.debugStyle);\n      }\n    };\n\n    if (!this.commandsList.length) {\n      this.addCommands(config.commands);\n    }\n  }\n\n  _createClass(VoiceRecognition, [{\n    key: \"commandToRegExp\",\n    value: function commandToRegExp(command) {\n      var optionalParam = /\\s*\\((.*?)\\)\\s*/g,\n          optionalRegex = /(\\(\\?:[^)]+\\))\\?/g,\n          namedParam = /(\\(\\?)?:\\w+/g,\n          splatParam = /\\*\\w+/g,\n          escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\n      command = command.replace(escapeRegExp, \"\\\\$&\").replace(optionalParam, \"(?:$1)?\").replace(namedParam, function (match, optional) {\n        return optional ? match : \"([^\\\\s]+)\";\n      }).replace(splatParam, \"(.*?)\").replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n      return new RegExp(\"^\" + command + \"$\", \"i\");\n    }\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return !!this.recognition;\n    }\n  }, {\n    key: \"initIfNeeded\",\n    value: function initIfNeeded() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.isInitialized()) {\n        this.init(options, false);\n      }\n    } // Initialize smartSpeechRecognition with a list of commands to recognize.\n    // e.g. smartSpeechRecognition.init({'hello :name': helloFunction})\n    // smartSpeechRecognition understands commands with named variables, splats, and optional words.\n\n  }, {\n    key: \"debug\",\n    // Turn on output of debug messages to the console. Ugly, but super-handy!\n    value: function debug(newState) {\n      if (arguments.length > 0) {\n        config.debugState = !!newState;\n      } else {\n        config.debugState = true;\n      }\n    } // Set the language the user will speak in. If not called, defaults to 'en-US'.\n    // e.g. 'fr-FR' (French-France), 'es-CR' (EspaÃ±ol-Costa Rica)\n\n  }, {\n    key: \"setLanguage\",\n    value: function setLanguage(language) {\n      this.initIfNeeded();\n      this.recognition.lang = language;\n    } // Add additional commands that smartSpeechRecognition will respond to. Similar in syntax to smartSpeechRecognition.init()\n\n  }, {\n    key: \"removeCommands\",\n    // Remove existing commands. Called with a single phrase, array of phrases, or methodically. Pass no params to remove all commands.\n    value: function removeCommands(commandsToRemove) {\n      if (commandsToRemove === undefined) {\n        this.commandsList = [];\n        return;\n      }\n\n      commandsToRemove = Array.isArray(commandsToRemove) ? commandsToRemove : [commandsToRemove];\n      this.commandsList = this.commandsList.filter(function (command) {\n        for (var i = 0; i < commandsToRemove.length; i++) {\n          if (commandsToRemove[i] === command.originalPhrase) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    } // Lets the user add a callback of one of 9 types:\n    // start, error, end, result, resultMatch, resultNoMatch, errorNetwork, errorPermissionBlocked, errorPermissionDenied\n    // Can also optionally receive a context for the callback function as the third argument\n\n  }, {\n    key: \"addCallback\",\n    value: function addCallback(type, callback, context) {\n      if (this.callbacks[type] === undefined) {\n        return;\n      }\n\n      var cb = window[callback] || callback;\n\n      if (typeof cb !== \"function\") {\n        return;\n      }\n\n      this.callbacks[type].push({\n        callback: cb,\n        context: context || this\n      });\n    }\n  }, {\n    key: \"invokeCallbacks\",\n    value: function invokeCallbacks(callbacks) {\n      callbacks.forEach(function (callback) {\n        callback.callback.apply(callback.context);\n      });\n    }\n  }]);\n\n  return VoiceRecognition;\n}();","map":{"version":3,"sources":["/opt/lampp/htdocs/reactApp/React_16.x/src/common/voice-control/VoiceRecognition.js"],"names":["SpeechRecognition","config","actions","VoiceRecognition","commandsList","recognition","autoRestart","lastStartedAt","callbacks","start","error","end","result","resultMatch","resultNoMatch","errorNetwork","errorPermissionBlocked","errorPermissionDenied","init","commands","resetCommands","abort","maxAlternatives","continuous","lang","voice_command_lang","onstart","debugState","console","log","debugStyle_success","debugStyle","voiceControlStart","onerror","event","debugStyle_warning","Date","getTime","voiceControlError","onend","voiceControlEnd","timeSinceLastStart","setTimeout","onresult","results","resultIndex","commandText","i","length","transcript","trim","j","l","command","exec","parameters","slice","originalPhrase","type","VOICE_CONTROL_ACTION","voiceControlCommand","callback","apply","ignoreCallsFor","indexOf","voiceControlMatch","voiceControlNoMatch","addCommands","options","initIfNeeded","undefined","voiceControlAbort","action","Object","keys","forEach","phrase","window","commandToRegExp","push","VOICE_CONTROL_CALLBACK","payload","actionType","optionalParam","optionalRegex","namedParam","splatParam","escapeRegExp","replace","match","optional","RegExp","isInitialized","newState","arguments","language","commandsToRemove","Array","isArray","filter","context","cb"],"mappings":"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","sourcesContent":["import SpeechRecognition from \"./utils/SpeechRecognitionApi\";\nimport { config } from \"../../config/config\";\n\nimport * as actions from \"./VoiceActions\";\n\nexport class VoiceRecognition {\n  commandsList = [];\n  recognition = null;\n  autoRestart = false;\n  lastStartedAt = 0;\n\n  constructor() {\n    if (!this.commandsList.length) {\n      this.addCommands(config.commands);\n    }\n  }\n\n  callbacks = {\n    start: [],\n    error: [],\n    end: [],\n    result: [],\n    resultMatch: [],\n    resultNoMatch: [],\n    errorNetwork: [],\n    errorPermissionBlocked: [],\n    errorPermissionDenied: []\n  };\n\n  commandToRegExp(command) {\n    const optionalParam = /\\s*\\((.*?)\\)\\s*/g,\n      optionalRegex = /(\\(\\?:[^)]+\\))\\?/g,\n      namedParam = /(\\(\\?)?:\\w+/g,\n      splatParam = /\\*\\w+/g,\n      escapeRegExp = /[-{}[\\]+?.,\\\\^$|#]/g;\n    command = command\n      .replace(escapeRegExp, \"\\\\$&\")\n      .replace(optionalParam, \"(?:$1)?\")\n      .replace(namedParam, (match, optional) => {\n        return optional ? match : \"([^\\\\s]+)\";\n      })\n      .replace(splatParam, \"(.*?)\")\n      .replace(optionalRegex, \"\\\\s*$1?\\\\s*\");\n    return new RegExp(\"^\" + command + \"$\", \"i\");\n  }\n\n  isInitialized() {\n    return !!this.recognition;\n  }\n\n  initIfNeeded(options = {}) {\n    if (!this.isInitialized()) {\n      this.init(options, false);\n    }\n  }\n\n  // Initialize smartSpeechRecognition with a list of commands to recognize.\n  // e.g. smartSpeechRecognition.init({'hello :name': helloFunction})\n  // smartSpeechRecognition understands commands with named variables, splats, and optional words.\n\n  init = (commands, resetCommands = true) => {\n    let recognition = this.recognition;\n\n    // Abort previous instances of recognition already running\n    if (recognition && recognition.abort) {\n      recognition.abort();\n    }\n\n    // initiate SpeechRecognition\n    recognition = new SpeechRecognition();\n\n    // Set the max number of alternative transcripts to try and match with a command\n    recognition.maxAlternatives = 5;\n    recognition.continuous = true;\n    // Sets the language to the default 'en-US'. This can be changed with smartSpeechRecognition.setLanguage()\n    recognition.lang = config.voice_command_lang || \"en-US\";\n\n    recognition.onstart = () => {\n      // invokeCallbacks(callbacks.start);\n      //debugState\n      if (config.debugState) {\n        console.log(\n          \"%c âœ” SUCCESS: User allowed access the microphone service to start \",\n          config.debugStyle_success\n        );\n        console.log(\n          \"Language setting is set to: \" + recognition.lang,\n          config.debugStyle\n        );\n      }\n\n      actions.voiceControlStart();\n    };\n\n    recognition.onerror = event => {\n      // this.invokeCallbacks(this.callbacks.error);\n      switch (event.error) {\n        case \"network\":\n          // this.invokeCallbacks(this.callbacks.errorNetwork);\n          break;\n        case \"not-allowed\":\n        case \"service-not-allowed\":\n          // if permission to use the mic is denied, turn off auto-restart\n          this.autoRestart = false;\n          //debugState\n          if (config.debugState) {\n            console.log(\n              \"%c WARNING: Microphone was not detected (either user denied access or it is not installed properly) \",\n              config.debugStyle_warning\n            );\n          }\n          // determine if permission was denied by user or automatically.\n          if (new Date().getTime() - this.lastStartedAt < 200) {\n            // invokeCallbacks(callbacks.errorPermissionBlocked);\n          } else {\n            // invokeCallbacks(callbacks.errorPermissionDenied);\n            //console.log(\"You need your mic to be active\")\n          }\n\n          actions.voiceControlError(event);\n          break;\n\n        default:\n          break;\n      }\n    };\n\n    recognition.onend = event => {\n      // invokeCallbacks(this.callbacks.end);\n      // smartSpeechRecognition will auto restart if it is closed automatically and not by user action.\n\n      actions.voiceControlEnd(event);\n\n      if (this.autoRestart) {\n        // play nicely with the browser, and never restart smartSpeechRecognition automatically more than once per second\n        const timeSinceLastStart = new Date().getTime() - this.lastStartedAt;\n        if (timeSinceLastStart < 1000) {\n          setTimeout(() => {\n            this.start({});\n          }, 1000 - timeSinceLastStart);\n        } else {\n          this.start({});\n        }\n      }\n    };\n\n    recognition.onresult = event => {\n      // this.invokeCallbacks(this.callbacks.result);\n\n      const results = event.results[event.resultIndex];\n      let commandText;\n\n      // go over each of the 5 results and alternative results received (we've set maxAlternatives to 5 above)\n      for (let i = 0; i < results.length; i++) {\n        // the text recognized\n        commandText = results[i].transcript.trim();\n        if (config.debugState) {\n          console.log(\"Speech recognized: %c\" + commandText, config.debugStyle);\n        }\n\n        // try and match recognized text to one of the commands on the list\n        for (let j = 0, l = this.commandsList.length; j < l; j++) {\n          const result = this.commandsList[j].command.exec(commandText);\n          if (result) {\n            const parameters = result.slice(1);\n            if (config.debugState) {\n              console.log(\n                \"command matched: %c\" + this.commandsList[j].originalPhrase,\n                config.debugStyle\n              );\n              if (parameters.length) {\n                console.log(\"with parameters\", parameters);\n              }\n            }\n\n            if (this.commandsList[j].type === actions.VOICE_CONTROL_ACTION) {\n              actions.voiceControlCommand(this.commandsList[j]);\n            } else {\n              // execute the matched command\n              this.commandsList[j].callback.apply(this, parameters);\n            }\n            // this.invokeCallbacks(this.callbacks.resultMatch);\n\n            // for commands \"sound on\", \"stop\" and \"mute\" do not play sound or display message\n            const ignoreCallsFor = [\"sound on\", \"mute\", \"stop\"];\n\n            if (\n              ignoreCallsFor.indexOf(this.commandsList[j].originalPhrase) < 0\n            ) {\n              actions.voiceControlMatch(this.commandsList[j].originalPhrase);\n            } // end if\n\n            return true;\n          }\n        } // end for\n      } // end for\n\n      // invokeCallbacks(callbacks.resultNoMatch);\n      //console.log(\"no match found for: \" + commandText)\n\n      actions.voiceControlNoMatch(commandText);\n\n      return false;\n    };\n\n    // build commands list\n    if (resetCommands) {\n      this.commandsList = [];\n    }\n    if (commands.length) {\n      this.addCommands(commands);\n    }\n\n    this.recognition = recognition;\n  };\n\n  // Start listening (asking for permission first, if needed).\n  // Call this after you've initialized smartSpeechRecognition with commands.\n  // Receives an optional options object:\n  // { autoRestart: true }\n  start = (options = {}) => {\n    this.initIfNeeded(options);\n    if (options.autoRestart !== undefined) {\n      this.autoRestart = !!options.autoRestart;\n    } else {\n      this.autoRestart = true;\n    }\n\n    this.lastStartedAt = new Date().getTime();\n\n    this.recognition.start();\n  };\n\n  // abort the listening session (aka stop)\n  abort = () => {\n    this.autoRestart = false;\n    if (this.recognition && this.recognition.abort) {\n      this.recognition.abort();\n    }\n    actions.voiceControlAbort();\n  };\n\n  // Turn on output of debug messages to the console. Ugly, but super-handy!\n  debug(newState) {\n    if (arguments.length > 0) {\n      config.debugState = !!newState;\n    } else {\n      config.debugState = true;\n    }\n  }\n\n  // Set the language the user will speak in. If not called, defaults to 'en-US'.\n  // e.g. 'fr-FR' (French-France), 'es-CR' (EspaÃ±ol-Costa Rica)\n  setLanguage(language) {\n    this.initIfNeeded();\n    this.recognition.lang = language;\n  }\n\n  // Add additional commands that smartSpeechRecognition will respond to. Similar in syntax to smartSpeechRecognition.init()\n  addCommands = commands => {\n    let action, command;\n\n    this.initIfNeeded();\n\n    Object.keys(commands).forEach(phrase => {\n      action = window[commands[phrase]] || commands[phrase];\n      //convert command to regex\n      command = this.commandToRegExp(phrase);\n\n      if (typeof action === \"function\") {\n        this.commandsList.push({\n          type: actions.VOICE_CONTROL_CALLBACK,\n          command: command,\n          callback: action,\n          originalPhrase: phrase\n        });\n      }\n      if (typeof action === \"object\") {\n        this.commandsList.push({\n          type: actions.VOICE_CONTROL_ACTION,\n          command: command,\n          payload: action.payload,\n          actionType: action.type,\n          originalPhrase: phrase\n        });\n      }\n    });\n\n    if (config.debugState) {\n      console.log(\n        \"Commands successfully loaded: %c\" + this.commandsList.length,\n        config.debugStyle\n      );\n    }\n  };\n\n  // Remove existing commands. Called with a single phrase, array of phrases, or methodically. Pass no params to remove all commands.\n  removeCommands(commandsToRemove) {\n    if (commandsToRemove === undefined) {\n      this.commandsList = [];\n      return;\n    }\n    commandsToRemove = Array.isArray(commandsToRemove)\n      ? commandsToRemove\n      : [commandsToRemove];\n    this.commandsList = this.commandsList.filter(command => {\n      for (let i = 0; i < commandsToRemove.length; i++) {\n        if (commandsToRemove[i] === command.originalPhrase) {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  // Lets the user add a callback of one of 9 types:\n  // start, error, end, result, resultMatch, resultNoMatch, errorNetwork, errorPermissionBlocked, errorPermissionDenied\n  // Can also optionally receive a context for the callback function as the third argument\n  addCallback(type, callback, context) {\n    if (this.callbacks[type] === undefined) {\n      return;\n    }\n    var cb = window[callback] || callback;\n    if (typeof cb !== \"function\") {\n      return;\n    }\n    this.callbacks[type].push({\n      callback: cb,\n      context: context || this\n    });\n  }\n\n  invokeCallbacks(callbacks) {\n    callbacks.forEach(callback => {\n      callback.callback.apply(callback.context);\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}