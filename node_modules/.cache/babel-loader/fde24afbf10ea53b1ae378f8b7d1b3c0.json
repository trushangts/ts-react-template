{"ast":null,"code":"/**\n * @license\n * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)\n * MIT-licensed (http://opensource.org/licenses/MIT)\n */\n\n/**\n * @fileoverview Description of this file.\n * @author danvk@google.com (Dan Vanderkam)\n *\n * A ticker is a function with the following interface:\n *\n * function(a, b, pixels, options_view, dygraph, forced_values);\n * -> [ { v: tick1_v, label: tick1_label[, label_v: label_v1] },\n *      { v: tick2_v, label: tick2_label[, label_v: label_v2] },\n *      ...\n *    ]\n *\n * The returned value is called a \"tick list\".\n *\n * Arguments\n * ---------\n *\n * [a, b] is the range of the axis for which ticks are being generated. For a\n * numeric axis, these will simply be numbers. For a date axis, these will be\n * millis since epoch (convertable to Date objects using \"new Date(a)\" and \"new\n * Date(b)\").\n *\n * opts provides access to chart- and axis-specific options. It can be used to\n * access number/date formatting code/options, check for a log scale, etc.\n *\n * pixels is the length of the axis in pixels. opts('pixelsPerLabel') is the\n * minimum amount of space to be allotted to each label. For instance, if\n * pixels=400 and opts('pixelsPerLabel')=40 then the ticker should return\n * between zero and ten (400/40) ticks.\n *\n * dygraph is the Dygraph object for which an axis is being constructed.\n *\n * forced_values is used for secondary y-axes. The tick positions are typically\n * set by the primary y-axis, so the secondary y-axis has no choice in where to\n * put these. It simply has to generate labels for these data values.\n *\n * Tick lists\n * ----------\n * Typically a tick will have both a grid/tick line and a label at one end of\n * that line (at the bottom for an x-axis, at left or right for the y-axis).\n *\n * A tick may be missing one of these two components:\n * - If \"label_v\" is specified instead of \"v\", then there will be no tick or\n *   gridline, just a label.\n * - Similarly, if \"label\" is not specified, then there will be a gridline\n *   without a label.\n *\n * This flexibility is useful in a few situations:\n * - For log scales, some of the tick lines may be too close to all have labels.\n * - For date scales where years are being displayed, it is desirable to display\n *   tick marks at the beginnings of years but labels (e.g. \"2006\") in the\n *   middle of the years.\n */\n\n/*jshint sub:true */\n\n/*global Dygraph:false */\n\"use strict\";\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nvar _dygraphUtils = require('./dygraph-utils');\n\nvar utils = _interopRequireWildcard(_dygraphUtils);\n/** @typedef {Array.<{v:number, label:string, label_v:(string|undefined)}>} */\n\n\nvar TickList = undefined; // the ' = undefined' keeps jshint happy.\n\n/** @typedef {function(\n *    number,\n *    number,\n *    number,\n *    function(string):*,\n *    Dygraph=,\n *    Array.<number>=\n *  ): TickList}\n */\n\nvar Ticker = undefined; // the ' = undefined' keeps jshint happy.\n\n/** @type {Ticker} */\n\nvar numericLinearTicks = function numericLinearTicks(a, b, pixels, opts, dygraph, vals) {\n  var nonLogscaleOpts = function nonLogscaleOpts(opt) {\n    if (opt === 'logscale') return false;\n    return opts(opt);\n  };\n\n  return numericTicks(a, b, pixels, nonLogscaleOpts, dygraph, vals);\n};\n\nexports.numericLinearTicks = numericLinearTicks;\n/** @type {Ticker} */\n\nvar numericTicks = function numericTicks(a, b, pixels, opts, dygraph, vals) {\n  var pixels_per_tick =\n  /** @type{number} */\n  opts('pixelsPerLabel');\n  var ticks = [];\n  var i, j, tickV, nTicks;\n\n  if (vals) {\n    for (i = 0; i < vals.length; i++) {\n      ticks.push({\n        v: vals[i]\n      });\n    }\n  } else {\n    // TODO(danvk): factor this log-scale block out into a separate function.\n    if (opts(\"logscale\")) {\n      nTicks = Math.floor(pixels / pixels_per_tick);\n      var minIdx = utils.binarySearch(a, PREFERRED_LOG_TICK_VALUES, 1);\n      var maxIdx = utils.binarySearch(b, PREFERRED_LOG_TICK_VALUES, -1);\n\n      if (minIdx == -1) {\n        minIdx = 0;\n      }\n\n      if (maxIdx == -1) {\n        maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;\n      } // Count the number of tick values would appear, if we can get at least\n      // nTicks / 4 accept them.\n\n\n      var lastDisplayed = null;\n\n      if (maxIdx - minIdx >= nTicks / 4) {\n        for (var idx = maxIdx; idx >= minIdx; idx--) {\n          var tickValue = PREFERRED_LOG_TICK_VALUES[idx];\n          var pixel_coord = Math.log(tickValue / a) / Math.log(b / a) * pixels;\n          var tick = {\n            v: tickValue\n          };\n\n          if (lastDisplayed === null) {\n            lastDisplayed = {\n              tickValue: tickValue,\n              pixel_coord: pixel_coord\n            };\n          } else {\n            if (Math.abs(pixel_coord - lastDisplayed.pixel_coord) >= pixels_per_tick) {\n              lastDisplayed = {\n                tickValue: tickValue,\n                pixel_coord: pixel_coord\n              };\n            } else {\n              tick.label = \"\";\n            }\n          }\n\n          ticks.push(tick);\n        } // Since we went in backwards order.\n\n\n        ticks.reverse();\n      }\n    } // ticks.length won't be 0 if the log scale function finds values to insert.\n\n\n    if (ticks.length === 0) {\n      // Basic idea:\n      // Try labels every 1, 2, 5, 10, 20, 50, 100, etc.\n      // Calculate the resulting tick spacing (i.e. this.height_ / nTicks).\n      // The first spacing greater than pixelsPerYLabel is what we use.\n      // TODO(danvk): version that works on a log scale.\n      var kmg2 = opts(\"labelsKMG2\");\n      var mults, base;\n\n      if (kmg2) {\n        mults = [1, 2, 4, 8, 16, 32, 64, 128, 256];\n        base = 16;\n      } else {\n        mults = [1, 2, 5, 10, 20, 50, 100];\n        base = 10;\n      } // Get the maximum number of permitted ticks based on the\n      // graph's pixel size and pixels_per_tick setting.\n\n\n      var max_ticks = Math.ceil(pixels / pixels_per_tick); // Now calculate the data unit equivalent of this tick spacing.\n      // Use abs() since graphs may have a reversed Y axis.\n\n      var units_per_tick = Math.abs(b - a) / max_ticks; // Based on this, get a starting scale which is the largest\n      // integer power of the chosen base (10 or 16) that still remains\n      // below the requested pixels_per_tick spacing.\n\n      var base_power = Math.floor(Math.log(units_per_tick) / Math.log(base));\n      var base_scale = Math.pow(base, base_power); // Now try multiples of the starting scale until we find one\n      // that results in tick marks spaced sufficiently far apart.\n      // The \"mults\" array should cover the range 1 .. base^2 to\n      // adjust for rounding and edge effects.\n\n      var scale, low_val, high_val, spacing;\n\n      for (j = 0; j < mults.length; j++) {\n        scale = base_scale * mults[j];\n        low_val = Math.floor(a / scale) * scale;\n        high_val = Math.ceil(b / scale) * scale;\n        nTicks = Math.abs(high_val - low_val) / scale;\n        spacing = pixels / nTicks;\n        if (spacing > pixels_per_tick) break;\n      } // Construct the set of ticks.\n      // Allow reverse y-axis if it's explicitly requested.\n\n\n      if (low_val > high_val) scale *= -1;\n\n      for (i = 0; i <= nTicks; i++) {\n        tickV = low_val + i * scale;\n        ticks.push({\n          v: tickV\n        });\n      }\n    }\n  }\n\n  var formatter =\n  /**@type{AxisLabelFormatter}*/\n  opts('axisLabelFormatter'); // Add labels to the ticks.\n\n  for (i = 0; i < ticks.length; i++) {\n    if (ticks[i].label !== undefined) continue; // Use current label.\n    // TODO(danvk): set granularity to something appropriate here.\n\n    ticks[i].label = formatter.call(dygraph, ticks[i].v, 0, opts, dygraph);\n  }\n\n  return ticks;\n};\n\nexports.numericTicks = numericTicks;\n/** @type {Ticker} */\n\nvar dateTicker = function dateTicker(a, b, pixels, opts, dygraph, vals) {\n  var chosen = pickDateTickGranularity(a, b, pixels, opts);\n\n  if (chosen >= 0) {\n    return getDateAxis(a, b, chosen, opts, dygraph);\n  } else {\n    // this can happen if self.width_ is zero.\n    return [];\n  }\n};\n\nexports.dateTicker = dateTicker; // Time granularity enumeration\n\nvar Granularity = {\n  MILLISECONDLY: 0,\n  TWO_MILLISECONDLY: 1,\n  FIVE_MILLISECONDLY: 2,\n  TEN_MILLISECONDLY: 3,\n  FIFTY_MILLISECONDLY: 4,\n  HUNDRED_MILLISECONDLY: 5,\n  FIVE_HUNDRED_MILLISECONDLY: 6,\n  SECONDLY: 7,\n  TWO_SECONDLY: 8,\n  FIVE_SECONDLY: 9,\n  TEN_SECONDLY: 10,\n  THIRTY_SECONDLY: 11,\n  MINUTELY: 12,\n  TWO_MINUTELY: 13,\n  FIVE_MINUTELY: 14,\n  TEN_MINUTELY: 15,\n  THIRTY_MINUTELY: 16,\n  HOURLY: 17,\n  TWO_HOURLY: 18,\n  SIX_HOURLY: 19,\n  DAILY: 20,\n  TWO_DAILY: 21,\n  WEEKLY: 22,\n  MONTHLY: 23,\n  QUARTERLY: 24,\n  BIANNUAL: 25,\n  ANNUAL: 26,\n  DECADAL: 27,\n  CENTENNIAL: 28,\n  NUM_GRANULARITIES: 29\n};\nexports.Granularity = Granularity; // Date components enumeration (in the order of the arguments in Date)\n// TODO: make this an @enum\n\nvar DateField = {\n  DATEFIELD_Y: 0,\n  DATEFIELD_M: 1,\n  DATEFIELD_D: 2,\n  DATEFIELD_HH: 3,\n  DATEFIELD_MM: 4,\n  DATEFIELD_SS: 5,\n  DATEFIELD_MS: 6,\n  NUM_DATEFIELDS: 7\n};\n/**\n * The value of datefield will start at an even multiple of \"step\", i.e.\n *   if datefield=SS and step=5 then the first tick will be on a multiple of 5s.\n *\n * For granularities <= HOURLY, ticks are generated every `spacing` ms.\n *\n * At coarser granularities, ticks are generated by incrementing `datefield` by\n *   `step`. In this case, the `spacing` value is only used to estimate the\n *   number of ticks. It should roughly correspond to the spacing between\n *   adjacent ticks.\n *\n * @type {Array.<{datefield:number, step:number, spacing:number}>}\n */\n\nvar TICK_PLACEMENT = [];\nTICK_PLACEMENT[Granularity.MILLISECONDLY] = {\n  datefield: DateField.DATEFIELD_MS,\n  step: 1,\n  spacing: 1\n};\nTICK_PLACEMENT[Granularity.TWO_MILLISECONDLY] = {\n  datefield: DateField.DATEFIELD_MS,\n  step: 2,\n  spacing: 2\n};\nTICK_PLACEMENT[Granularity.FIVE_MILLISECONDLY] = {\n  datefield: DateField.DATEFIELD_MS,\n  step: 5,\n  spacing: 5\n};\nTICK_PLACEMENT[Granularity.TEN_MILLISECONDLY] = {\n  datefield: DateField.DATEFIELD_MS,\n  step: 10,\n  spacing: 10\n};\nTICK_PLACEMENT[Granularity.FIFTY_MILLISECONDLY] = {\n  datefield: DateField.DATEFIELD_MS,\n  step: 50,\n  spacing: 50\n};\nTICK_PLACEMENT[Granularity.HUNDRED_MILLISECONDLY] = {\n  datefield: DateField.DATEFIELD_MS,\n  step: 100,\n  spacing: 100\n};\nTICK_PLACEMENT[Granularity.FIVE_HUNDRED_MILLISECONDLY] = {\n  datefield: DateField.DATEFIELD_MS,\n  step: 500,\n  spacing: 500\n};\nTICK_PLACEMENT[Granularity.SECONDLY] = {\n  datefield: DateField.DATEFIELD_SS,\n  step: 1,\n  spacing: 1000 * 1\n};\nTICK_PLACEMENT[Granularity.TWO_SECONDLY] = {\n  datefield: DateField.DATEFIELD_SS,\n  step: 2,\n  spacing: 1000 * 2\n};\nTICK_PLACEMENT[Granularity.FIVE_SECONDLY] = {\n  datefield: DateField.DATEFIELD_SS,\n  step: 5,\n  spacing: 1000 * 5\n};\nTICK_PLACEMENT[Granularity.TEN_SECONDLY] = {\n  datefield: DateField.DATEFIELD_SS,\n  step: 10,\n  spacing: 1000 * 10\n};\nTICK_PLACEMENT[Granularity.THIRTY_SECONDLY] = {\n  datefield: DateField.DATEFIELD_SS,\n  step: 30,\n  spacing: 1000 * 30\n};\nTICK_PLACEMENT[Granularity.MINUTELY] = {\n  datefield: DateField.DATEFIELD_MM,\n  step: 1,\n  spacing: 1000 * 60\n};\nTICK_PLACEMENT[Granularity.TWO_MINUTELY] = {\n  datefield: DateField.DATEFIELD_MM,\n  step: 2,\n  spacing: 1000 * 60 * 2\n};\nTICK_PLACEMENT[Granularity.FIVE_MINUTELY] = {\n  datefield: DateField.DATEFIELD_MM,\n  step: 5,\n  spacing: 1000 * 60 * 5\n};\nTICK_PLACEMENT[Granularity.TEN_MINUTELY] = {\n  datefield: DateField.DATEFIELD_MM,\n  step: 10,\n  spacing: 1000 * 60 * 10\n};\nTICK_PLACEMENT[Granularity.THIRTY_MINUTELY] = {\n  datefield: DateField.DATEFIELD_MM,\n  step: 30,\n  spacing: 1000 * 60 * 30\n};\nTICK_PLACEMENT[Granularity.HOURLY] = {\n  datefield: DateField.DATEFIELD_HH,\n  step: 1,\n  spacing: 1000 * 3600\n};\nTICK_PLACEMENT[Granularity.TWO_HOURLY] = {\n  datefield: DateField.DATEFIELD_HH,\n  step: 2,\n  spacing: 1000 * 3600 * 2\n};\nTICK_PLACEMENT[Granularity.SIX_HOURLY] = {\n  datefield: DateField.DATEFIELD_HH,\n  step: 6,\n  spacing: 1000 * 3600 * 6\n};\nTICK_PLACEMENT[Granularity.DAILY] = {\n  datefield: DateField.DATEFIELD_D,\n  step: 1,\n  spacing: 1000 * 86400\n};\nTICK_PLACEMENT[Granularity.TWO_DAILY] = {\n  datefield: DateField.DATEFIELD_D,\n  step: 2,\n  spacing: 1000 * 86400 * 2\n};\nTICK_PLACEMENT[Granularity.WEEKLY] = {\n  datefield: DateField.DATEFIELD_D,\n  step: 7,\n  spacing: 1000 * 604800\n};\nTICK_PLACEMENT[Granularity.MONTHLY] = {\n  datefield: DateField.DATEFIELD_M,\n  step: 1,\n  spacing: 1000 * 7200 * 365.2524\n}; // 1e3 * 60 * 60 * 24 * 365.2524 / 12\n\nTICK_PLACEMENT[Granularity.QUARTERLY] = {\n  datefield: DateField.DATEFIELD_M,\n  step: 3,\n  spacing: 1000 * 21600 * 365.2524\n}; // 1e3 * 60 * 60 * 24 * 365.2524 / 4\n\nTICK_PLACEMENT[Granularity.BIANNUAL] = {\n  datefield: DateField.DATEFIELD_M,\n  step: 6,\n  spacing: 1000 * 43200 * 365.2524\n}; // 1e3 * 60 * 60 * 24 * 365.2524 / 2\n\nTICK_PLACEMENT[Granularity.ANNUAL] = {\n  datefield: DateField.DATEFIELD_Y,\n  step: 1,\n  spacing: 1000 * 86400 * 365.2524\n}; // 1e3 * 60 * 60 * 24 * 365.2524 * 1\n\nTICK_PLACEMENT[Granularity.DECADAL] = {\n  datefield: DateField.DATEFIELD_Y,\n  step: 10,\n  spacing: 1000 * 864000 * 365.2524\n}; // 1e3 * 60 * 60 * 24 * 365.2524 * 10\n\nTICK_PLACEMENT[Granularity.CENTENNIAL] = {\n  datefield: DateField.DATEFIELD_Y,\n  step: 100,\n  spacing: 1000 * 8640000 * 365.2524\n}; // 1e3 * 60 * 60 * 24 * 365.2524 * 100\n\n/**\n * This is a list of human-friendly values at which to show tick marks on a log\n * scale. It is k * 10^n, where k=1..9 and n=-39..+39, so:\n * ..., 1, 2, 3, 4, 5, ..., 9, 10, 20, 30, ..., 90, 100, 200, 300, ...\n * NOTE: this assumes that utils.LOG_SCALE = 10.\n * @type {Array.<number>}\n */\n\nvar PREFERRED_LOG_TICK_VALUES = function () {\n  var vals = [];\n\n  for (var power = -39; power <= 39; power++) {\n    var range = Math.pow(10, power);\n\n    for (var mult = 1; mult <= 9; mult++) {\n      var val = range * mult;\n      vals.push(val);\n    }\n  }\n\n  return vals;\n}();\n/**\n * Determine the correct granularity of ticks on a date axis.\n *\n * @param {number} a Left edge of the chart (ms)\n * @param {number} b Right edge of the chart (ms)\n * @param {number} pixels Size of the chart in the relevant dimension (width).\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @return {number} The appropriate axis granularity for this chart. See the\n *     enumeration of possible values in dygraph-tickers.js.\n */\n\n\nvar pickDateTickGranularity = function pickDateTickGranularity(a, b, pixels, opts) {\n  var pixels_per_tick =\n  /** @type{number} */\n  opts('pixelsPerLabel');\n\n  for (var i = 0; i < Granularity.NUM_GRANULARITIES; i++) {\n    var num_ticks = numDateTicks(a, b, i);\n\n    if (pixels / num_ticks >= pixels_per_tick) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Compute the number of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @return {number} (Approximate) number of ticks that would result.\n */\n\n\nvar numDateTicks = function numDateTicks(start_time, end_time, granularity) {\n  var spacing = TICK_PLACEMENT[granularity].spacing;\n  return Math.round(1.0 * (end_time - start_time) / spacing);\n};\n/**\n * Compute the positions and labels of ticks on a date axis for a given granularity.\n * @param {number} start_time\n * @param {number} end_time\n * @param {number} granularity (one of the granularities enumerated above)\n * @param {function(string):*} opts Function mapping from option name -&gt; value.\n * @param {Dygraph=} dg\n * @return {!TickList}\n */\n\n\nvar getDateAxis = function getDateAxis(start_time, end_time, granularity, opts, dg) {\n  var formatter =\n  /** @type{AxisLabelFormatter} */\n  opts(\"axisLabelFormatter\");\n  var utc = opts(\"labelsUTC\");\n  var accessors = utc ? utils.DateAccessorsUTC : utils.DateAccessorsLocal;\n  var datefield = TICK_PLACEMENT[granularity].datefield;\n  var step = TICK_PLACEMENT[granularity].step;\n  var spacing = TICK_PLACEMENT[granularity].spacing; // Choose a nice tick position before the initial instant.\n  // Currently, this code deals properly with the existent daily granularities:\n  // DAILY (with step of 1) and WEEKLY (with step of 7 but specially handled).\n  // Other daily granularities (say TWO_DAILY) should also be handled specially\n  // by setting the start_date_offset to 0.\n\n  var start_date = new Date(start_time);\n  var date_array = [];\n  date_array[DateField.DATEFIELD_Y] = accessors.getFullYear(start_date);\n  date_array[DateField.DATEFIELD_M] = accessors.getMonth(start_date);\n  date_array[DateField.DATEFIELD_D] = accessors.getDate(start_date);\n  date_array[DateField.DATEFIELD_HH] = accessors.getHours(start_date);\n  date_array[DateField.DATEFIELD_MM] = accessors.getMinutes(start_date);\n  date_array[DateField.DATEFIELD_SS] = accessors.getSeconds(start_date);\n  date_array[DateField.DATEFIELD_MS] = accessors.getMilliseconds(start_date);\n  var start_date_offset = date_array[datefield] % step;\n\n  if (granularity == Granularity.WEEKLY) {\n    // This will put the ticks on Sundays.\n    start_date_offset = accessors.getDay(start_date);\n  }\n\n  date_array[datefield] -= start_date_offset;\n\n  for (var df = datefield + 1; df < DateField.NUM_DATEFIELDS; df++) {\n    // The minimum value is 1 for the day of month, and 0 for all other fields.\n    date_array[df] = df === DateField.DATEFIELD_D ? 1 : 0;\n  } // Generate the ticks.\n  // For granularities not coarser than HOURLY we use the fact that:\n  //   the number of milliseconds between ticks is constant\n  //   and equal to the defined spacing.\n  // Otherwise we rely on the 'roll over' property of the Date functions:\n  //   when some date field is set to a value outside of its logical range,\n  //   the excess 'rolls over' the next (more significant) field.\n  // However, when using local time with DST transitions,\n  // there are dates that do not represent any time value at all\n  // (those in the hour skipped at the 'spring forward'),\n  // and the JavaScript engines usually return an equivalent value.\n  // Hence we have to check that the date is properly increased at each step,\n  // returning a date at a nice tick position.\n\n\n  var ticks = [];\n  var tick_date = accessors.makeDate.apply(null, date_array);\n  var tick_time = tick_date.getTime();\n\n  if (granularity <= Granularity.HOURLY) {\n    if (tick_time < start_time) {\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n\n    while (tick_time <= end_time) {\n      ticks.push({\n        v: tick_time,\n        label: formatter.call(dg, tick_date, granularity, opts, dg)\n      });\n      tick_time += spacing;\n      tick_date = new Date(tick_time);\n    }\n  } else {\n    if (tick_time < start_time) {\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n\n    while (tick_time <= end_time) {\n      if (granularity >= Granularity.DAILY || accessors.getHours(tick_date) % step === 0) {\n        ticks.push({\n          v: tick_time,\n          label: formatter.call(dg, tick_date, granularity, opts, dg)\n        });\n      }\n\n      date_array[datefield] += step;\n      tick_date = accessors.makeDate.apply(null, date_array);\n      tick_time = tick_date.getTime();\n    }\n  }\n\n  return ticks;\n};\n\nexports.getDateAxis = getDateAxis;","map":null,"metadata":{},"sourceType":"script"}